# lessons.py

# This file contains the curriculum for the Python tutor.
# It is a list of dictionaries, where each dictionary represents a lesson.

# I will parse the full list provided by the user later.
# For now, starting with the first few fundamental lessons.

# The order is based on the user's list, read from bottom to top.

LESSONS = [
    {
        "id": "EX1-0",
        "title": "使用 print() 印出訊息",
        "explanation": """
## 什麼是 print()？

在 Python 中，「函式」(function) 就像一個小工具，可以幫我們完成特定的任務。
`print()` 是您會學到的第一個，也是最有用的函式之一。

**它的功能是什麼？**
`print()` 的功能是將您指定的任何文字、數字或其他資料「印」在螢幕上，讓您可以看到結果。

## 為什麼需要引號？

當您想要印出文字時，Python 需要知道「這是文字，不是程式碼指令」。
**引號的作用就是告訴 Python：「這裡面的內容是文字，請直接印出來，不要當作程式碼執行。」**

例如：
- 沒有引號：`print(Hello)` → Python 會以為 `Hello` 是一個變數名稱，會出錯！
- 有引號：`print("Hello")` → Python 知道這是文字，會直接印出 Hello

## 引號的種類

Python 接受兩種引號：
- **雙引號** `"`：例如 `"Hello"`
- **單引號** `'`：例如 `'Hello'`

兩種都可以用，效果完全一樣！選擇您喜歡的就好。

## 完整的語法結構

讓我們拆解 `print("Hello, World!")` 這行程式碼：

1. **`print`** - 這是函式的名稱，告訴 Python 要執行「印出」這個動作
2. **`()`** - 這是括號，裡面放要印出的內容
3. **`"Hello, World!"`** - 這是用引號包起來的文字（我們稱為「字串」）

**為什麼需要括號？**
括號告訴 Python：「這些是要傳給 print() 函式的資料」。就像打電話時，您需要把要說的話放在電話聽筒裡一樣！

## 實際範例

要印出 "Hello, World!"，您可以這樣寫：

```
print("Hello, World!")
```

**逐步說明：**
- `print` → 我要使用「印出」功能
- `(` → 開始告訴 Python 要印什麼
- `"Hello, World!"` → 要印的文字（用引號包起來）
- `)` → 結束，告訴 Python 就是這些了

執行後，螢幕上就會顯示：`Hello, World!`

**注意：** 引號本身不會被印出來，它們只是用來標記文字的範圍！
""",
        "exercise": "輪到您了！請寫一行程式碼，在螢幕上印出 **Hello, Python!**",
        "hint": "使用 print() 函式，並將 Hello, Python! 這段文字放在括號和引號中。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "Hello, Python!\n"
        }
    },
    {
        "id": "PT1-0",
        "title": "印出多行訊息",
        "explanation": """
## 如何印出多行？

您可以連續使用好幾個 `print()` 函式，來印出多行訊息。

**為什麼需要多個 print()？**
每個 `print()` 函式會印出一行，然後自動換行。所以如果您想要印出兩行不同的內容，就需要使用兩個 `print()`。

## 程式執行的順序

**重要概念：** 程式會**由上到下，一次執行一行**，就像您閱讀文章一樣，從第一行讀到最後一行。

例如：
```
print("第一行")
print("第二行")
```

**執行過程：**
1. Python 先執行第一行：`print("第一行")` → 螢幕顯示「第一行」，然後換行
2. Python 再執行第二行：`print("第二行")` → 螢幕顯示「第二行」，然後換行

**結果：**
```
第一行
第二行
```

## 為什麼每個 print() 會自動換行？

這是 `print()` 函式的預設行為。每次執行 `print()` 後，它會自動在輸出後面加上一個「換行符號」，讓下一次的輸出從新的一行開始。

**類比：** 就像您寫完一行字後，按 Enter 鍵換到下一行一樣！

## 實際範例

如果您想要印出：
```
Hello
World
```

您需要寫：
```
print("Hello")
print("World")
```

**記住：** 每一行要印的內容，都需要一個獨立的 `print()` 函式！
""",
        "exercise": "請撰寫程式，在螢幕上分兩行印出以下內容：\n第一行是：Hello, Gemini!\n第二行是：I'm learning Python.",
        "hint": "您需要使用兩個 print() 函式，每一行對應一個。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "Hello, Gemini!\nI'm learning Python.\n"
        }
    },
    {
        "id": "EX1-1",
        "title": "數字與基本運算",
        "explanation": """
## print() 可以印數字嗎？

當然可以！`print()` 不僅可以印出文字，也可以印出數字。

## 為什麼數字不需要引號？

**重要區別：**
- **文字（字串）**：需要用引號包起來，例如 `"Hello"` → 告訴 Python 這是文字
- **數字**：不需要引號，例如 `123` → Python 知道這是數字，可以直接使用

**為什麼？**
因為數字是 Python 可以直接理解的資料型態，不需要特別標記。但文字如果不加引號，Python 會以為是變數名稱或程式碼指令，就會出錯！

例如：
- `print(123)` → ✅ 正確！Python 知道 123 是數字
- `print("123")` → ✅ 也正確！但這是「文字 123」，不是數字
- `print(abc)` → ❌ 錯誤！Python 以為 abc 是變數名稱

## 讓 Python 幫我們計算

**更厲害的是：** 您可以直接在 `print()` 裡面寫數學算式，Python 會先計算，然後印出結果！

例如：
```
print(10 + 5)
```

**執行過程：**
1. Python 看到 `10 + 5`
2. Python 先計算：10 + 5 = 15
3. Python 將結果 15 傳給 `print()`
4. 螢幕顯示：`15`

## Python 的數學運算子

Python 的數學運算子跟您在學校學的一樣：

| 符號 | 名稱 | 範例 | 結果 |
|------|------|------|------|
| `+` | 加 | `10 + 5` | `15` |
| `-` | 減 | `10 - 5` | `5` |
| `*` | 乘 | `10 * 5` | `50` |
| `/` | 除 | `10 / 5` | `2.0` |

**注意：** 乘法用 `*`（星號），不是 `×`！這是因為鍵盤上沒有 `×` 符號，所以程式語言都用 `*` 來表示乘法。

**為什麼除法結果是 2.0 而不是 2？**
在 Python 中，除法 `/` 的結果永遠是「浮點數」（小數），即使能整除也會顯示 `.0`。這是 Python 的設計，確保計算的精度。

## 實際範例

要計算 10 + 5 並印出結果：
```
print(10 + 5)
```

螢幕上就會顯示：`15`

**記住：** 數字不需要引號，可以直接寫在 `print()` 裡面！
""",
        "exercise": "請寫一行程式碼，計算 123 乘以 456，並將結果印出來。",
        "hint": "乘法是使用 `*` 符號。不需要用引號將數字包起來。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "56088\n"
        }
    },
    {
        "id": "PT1-1",
        "title": "計算並印出多個結果",
        "explanation": """
## 結合所學的知識

結合您所學的，我們可以計算多個數學式，並將它們的結果分別印在不同行。

**為什麼需要多個 print()？**
每個 `print()` 會印出一行並自動換行，所以如果要印出多個不同的結果，就需要多個 `print()`。

## 實際範例

例如，計算 100-1 跟 100-2：
```
print(100 - 1)
print(100 - 2)
```

**執行過程：**
1. 第一個 `print(100 - 1)`：
   - Python 先計算：100 - 1 = 99
   - 印出 99，然後換行
2. 第二個 `print(100 - 2)`：
   - Python 先計算：100 - 2 = 98
   - 印出 98，然後換行

**螢幕輸出：**
```
99
98
```

**記住：** 每個計算都需要一個獨立的 `print()`，這樣結果才會印在不同行！
""",
        "exercise": "請寫兩行程式碼，分別計算並印出以下兩個問題的答案：\n1. 9876 和 1234 的「乘積」(product) 是多少？\n2. 9876 和 1234 的「差」(difference) 是多少？",
        "hint": "您需要寫兩個 `print()`。第一個裡面是 `9876 * 1234`，第二個是 `9876 - 1234`。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "12186984\n8642\n"
        }
    },
    {
        "id": "PT1-2",
        "title": "進階計算：商和餘數",
        "explanation": """
## 為什麼需要整數除法和餘數？

在數學中，當我們做除法時，有時候我們只關心「商」（整數部分），有時候我們只關心「餘數」。

**生活中的例子：**
- 有 10 個蘋果，要分給 3 個人，每人可以分到幾個？（商）
- 有 10 個蘋果，分給 3 個人後，還剩幾個？（餘數）

## 兩個特殊的運算子

除了基本的 `+ - * /`，Python 還提供另外兩個在解題時非常有用的運算子：

### 1. `//` (整數除法)

**符號說明：**
- `//` 是兩個斜線，表示「整數除法」
- 這個運算子會計算除法，但會**無條件捨去小數點**，只回傳整數的部分，也就是「商」

**為什麼需要 `//`？**
因為普通的除法 `/` 會回傳小數（浮點數），但有時候我們只需要整數部分。

**範例：**
```
10 / 3 = 3.333...  # 普通除法
10 // 3 = 3        # 整數除法（只取整數部分）
```

### 2. `%` (模數/餘數)

**符號說明：**
- `%` 是百分比符號，但在 Python 中表示「模數運算」或「取餘數」
- 這個運算子會計算兩數相除後的「餘數」

**為什麼叫「模數」？**
「模數」是數學術語，表示「取餘數」的運算。

**範例：**
```
10 % 3 = 1  # 10 除以 3 的餘數是 1
```

**如何理解？**
10 ÷ 3 = 3 ... 1（3 餘 1），所以 `10 % 3 = 1`

## 實際範例

例如，10 除以 3 等於 3 餘 1：
```
print(10 // 3)  # 會印出 3 (商)
print(10 % 3)   # 會印出 1 (餘數)
```

**執行過程：**
1. `10 // 3`：
   - 計算：10 ÷ 3 = 3.333...
   - 取整數部分：3
   - 印出：3
2. `10 % 3`：
   - 計算：10 ÷ 3 = 3 餘 1
   - 取餘數：1
   - 印出：1

**記住：**
- `//` → 取商（整數部分）
- `%` → 取餘數
""",
        "exercise": "請計算 123 除以 7 的「商」和「餘數」，並將它們分別印在兩行。",
        "hint": "第一行使用 `print(123 // 7)`，第二行使用 `print(123 % 7)`。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "17\n4\n"
        }
    },
    {
        "id": "HW1",
        "title": "變數與綜合應用：計算學期成績",
        "explanation": """
## 為什麼需要變數？

當我們的計算變得複雜時，直接寫一長串數字會讓程式碼很難閱讀和修改。

**沒有變數的問題：**
```
print(85 * 0.4 + 90 * 0.6)
```
- 看不懂這些數字代表什麼
- 如果要改成績，要找到所有地方修改
- 容易出錯

**使用變數的好處：**
```
midterm_score = 85
final_score = 90
final_grade = midterm_score * 0.4 + final_score * 0.6
print(final_grade)
```
- 清楚知道每個數字的意義
- 只需要改一個地方
- 程式碼更容易理解

## 什麼是變數？

**變數（Variable）** 就像是為資料貼上標籤的命名容器。

**生活中的類比：**
就像您有一個盒子，上面貼著「期中考成績」的標籤，裡面放著 85 分。之後您就可以用「期中考成績」來代表這個 85 分。

## 變數的語法

```
變數名稱 = 值
```

**為什麼用 `=` 符號？**
`=` 在 Python 中表示「賦值」（assign），意思是「把右邊的值存到左邊的變數裡」。

**注意：** 這不是數學的「等於」！在 Python 中：
- `x = 10` 表示「把 10 存到 x 裡」
- `x == 10` 才表示「檢查 x 是否等於 10」

## 變數名稱的規則

**為什麼變數名稱不能隨便取？**
Python 有一些規則：

1. **只能包含：** 英文字母、數字、底線 `_`
2. **不能以數字開頭：** `2score` ❌，`score2` ✅
3. **不能是 Python 的關鍵字：** `if`、`print` 等不能當變數名
4. **區分大小寫：** `Score` 和 `score` 是不同的變數

**為什麼要有這些規則？**
為了避免混淆，讓 Python 能清楚區分變數名稱和程式碼指令。

## 實際範例

計算學期成績：
```
midterm_score = 85    # 期中考成績
final_score = 90      # 期末考成績
final_grade = midterm_score * 0.4 + final_score * 0.6
print(final_grade)
```

**執行過程：**
1. 建立變數 `midterm_score`，存入 85
2. 建立變數 `final_score`，存入 90
3. 計算：`85 * 0.4 + 90 * 0.6 = 34 + 54 = 88`
4. 將結果 88 存入 `final_grade`
5. 印出 `final_grade` 的值：88

**為什麼要用變數而不是直接寫數字？**
如果期中考成績改成 80，您只需要改第一行：
```
midterm_score = 80  # 只改這裡
```
其他地方的計算會自動使用新的值！這就是變數的威力。
""",
        "exercise": "假設平時成績 `assignment_grade` 為 80，期中考 `midterm_grade` 為 75，期末考 `final_grade` 為 92。\n學期總成績的計算方式為：平時成績佔 30%，期中考佔 30%，期末考佔 40%。\n請用變數寫出計算過程，並印出最後的學期總成績。",
        "hint": "你需要建立三個變數來儲存成績，然後在第四個變數中進行加權計算，最後用 `print` 印出第四個變數。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "83.3\n"
        }
    },
    {
        "id": "EX2-0",
        "title": "變數值的交換",
        "explanation": """
## 為什麼需要交換變數值？

在寫程式時，有時我們需要交換兩個變數的值。例如 `a = 10`, `b = 20`，交換後要變成 `a = 20`, `b = 10`。

**實際應用：**
- 排序演算法
- 資料交換
- 變數重新分配

**為什麼不能直接賦值？**
因為如果直接 `a = b`，`a` 的值會丟失，無法再賦值給 `b`。

## 傳統方法：使用暫時變數

**為什麼需要暫時變數？**
因為我們需要一個「中繼站」來暫時儲存一個值。

**語法：**
```
temp = a
a = b
b = temp
```

**執行過程：**
1. `temp = a` → 將 `a` 的值（10）儲存到 `temp`
2. `a = b` → 將 `b` 的值（20）賦值給 `a`（現在 `a = 20`）
3. `b = temp` → 將 `temp` 的值（10）賦值給 `b`（現在 `b = 10`）

**為什麼需要三步？**
因為我們需要先保存 `a` 的值，才能安全地交換。

## Python 的簡潔語法

**為什麼 Python 可以一行完成？**
因為 Python 支援「元組解包」（tuple unpacking），可以同時賦值。

**語法：**
```
a, b = b, a
```

**執行過程：**
1. Python 先計算右邊：`(b, a)` → `(20, 10)`（建立一個元組）
2. Python 再解包賦值：`a = 20`, `b = 10`

**為什麼不會出錯？**
因為 Python 會先計算右邊的所有值，然後再賦值給左邊，所以不會互相覆蓋。

## 實際範例

### 傳統方法

```
a = 10
b = 20
temp = a
a = b
b = temp
print(a, b)  # 20 10
```

### Python 簡潔方法

```
a = 10
b = 20
a, b = b, a
print(a, b)  # 20 10
```

**執行過程：**
1. `a = 10`, `b = 20`
2. `a, b = b, a`：
   - 右邊：`(b, a)` → `(20, 10)`
   - 左邊：`a = 20`, `b = 10`
3. 結果：`a = 20`, `b = 10`

**記住：** 
- 傳統方法需要三步：保存 → 交換 → 還原
- Python 可以一行完成：`a, b = b, a`
- Python 會先計算右邊，再賦值給左邊
- 這種語法更簡潔、更 Pythonic
""",
        "exercise": "有兩個變數 `x = 10` 和 `y = 20`。請用一行程式碼交換它們的值，然後分別在兩行中印出 `x` 和 `y` 的新值（x 在上，y 在下）。",
        "hint": "試試看 Python 獨特的交換語法 `x, y = y, x`，然後用兩個 `print()` 函式印出結果。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "20\n10\n"
        }
    },
    {
        "id": "EX2-1",
        "title": "流程控制：if 條件判斷",
        "explanation": """
## 為什麼需要 if？

目前為止，我們的程式都是由上到下一直線地執行。但如果我們想讓程式在「特定條件」下才執行某段程式碼呢？

**生活中的例子：**
- 如果今天下雨，就帶傘
- 如果成績 >= 60，就印出「及格」
- 如果年齡 >= 18，就印出「您是成年人」

這就是「條件判斷」的概念！

## if 的基本結構

```
if 條件:
    如果條件成立，就執行這裡的程式碼
```

## 為什麼需要冒號 `:`？

**冒號 `:` 的作用：**
冒號告訴 Python：「條件判斷的內容結束了，接下來是要執行的程式碼」。就像中文的「如果...，那麼...」中的逗號一樣，用來分隔條件和動作。

**語法規則：** 條件後面**一定要有冒號**，這是 Python 的語法要求，沒有冒號會出錯！

## 為什麼需要縮排？

**縮排（Indentation）是什麼？**
縮排就是在程式碼前面加上空格，讓程式碼往右移動。

**為什麼需要縮排？**
Python 使用縮排來判斷「哪些程式碼屬於 if 區塊」。這就像寫文章時，段落的第一行要縮排一樣，讓 Python 知道這些程式碼是在「如果條件成立時」才要執行的。

**重要規則：**
- `if` 後面的程式碼必須**縮排**
- 通常使用**四個空格**（或一個 Tab 鍵）
- 所有屬於 if 的程式碼都要有**相同的縮排量**

**為什麼不能用大括號 `{}`？**
其他程式語言（如 C、Java）用大括號來標示程式碼區塊，但 Python 選擇用縮排。這樣的好處是程式碼看起來更整潔，強制您寫出易讀的程式碼！

## 比較運算子

**為什麼用 `==` 而不是 `=`？**
- `=` 是「賦值」，例如 `x = 10` 表示「把 10 存到變數 x」
- `==` 是「比較」，例如 `x == 10` 表示「檢查 x 是否等於 10」

Python 用兩個等號來避免混淆！

**常用的比較符號：**
- `==`：等於
- `!=`：不等於
- `>`：大於
- `<`：小於
- `>=`：大於或等於
- `<=`：小於或等於

## 互動式輸入：input()

**什麼是 input()？**
`input()` 是一個函式，可以讓程式暫停執行，等待使用者從鍵盤輸入資料。

**基本用法：**
```
age = input()  # 等待使用者輸入，然後將輸入的內容存到變數 age
```

**為什麼需要 int(input())？**
`input()` 回傳的是**字串**（文字），如果我們需要數字，必須使用 `int()` 來轉換：

```
age = int(input())  # 先取得使用者輸入，然後轉換成整數
```

**執行過程：**
1. 程式執行到 `int(input())` 時會暫停
2. 等待使用者在輸入框中輸入數字（例如：25）
3. 將輸入的內容轉換成整數並存到變數 `age`
4. 程式繼續執行

## 實際範例

**範例 1：使用固定值**
```
score = 100
if score == 100:
    print("太完美了！")
```

**範例 2：使用互動式輸入**
```
age = int(input())
if age >= 18:
    print("您是成年人")
```

**執行過程（範例 2）：**
1. 程式執行到 `int(input())` 時暫停，等待輸入
2. 使用者輸入：`25`（然後按 Enter）
3. `age` 變數被設為 `25`（整數）
4. 檢查條件：`age >= 18` → `25 >= 18` → 是 True
5. 因為條件成立，執行縮排的程式碼：`print("您是成年人")`
6. 螢幕顯示：`您是成年人`

**如果輸入小於 18 會怎樣？**
如果使用者輸入 `15`，條件 `15 >= 18` 會是 False，Python 就會跳過縮排的程式碼，不會印出任何內容。

## 常見錯誤

❌ **忘記冒號：**
```
if age >= 18    # 錯誤！缺少冒號
    print("您是成年人")
```

✅ **正確寫法：**
```
if age >= 18:   # 有冒號
    print("您是成年人")
```

❌ **忘記縮排：**
```
if age >= 18:
print("您是成年人")    # 錯誤！沒有縮排
```

✅ **正確寫法：**
```
if age >= 18:
    print("您是成年人")    # 有縮排（四個空格）
```

❌ **忘記 int() 轉換：**
```
age = input()  # 錯誤！age 是字串，無法與數字比較
if age >= 18:  # 會出錯！
    print("您是成年人")
```

✅ **正確寫法：**
```
age = int(input())  # 正確！將輸入轉換成整數
if age >= 18:
    print("您是成年人")
```
""",
        "exercise": "請寫一個程式，使用 `int(input())` 來接收使用者輸入的年齡，然後用 `if` 判斷式檢查：如果年齡大於或等於 18，就印出「您是成年人」。\n\n**提示：** 當程式執行時，您可以在輸入框中輸入數字（例如：25）來測試程式。",
        "hint": "使用 `age = int(input())` 來接收輸入，然後用 `if age >= 18:` 來判斷。記得冒號和下一行的縮排！",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "您是成年人\n",
            "test_inputs": ["25"]
        }
    },
    {
        "id": "EX2-2",
        "title": "邏輯與巢狀 if",
        "explanation": """
## 為什麼需要邏輯運算子？

有時候我們需要組合多個條件，例如「今天是假日**而且**天氣好」，或者「今天不是假日」。

**邏輯運算子**可以幫助我們組合條件。

## 什麼是布林值？

**布林值（Boolean）** 只有兩個值：
- `True`（真、是）
- `False`（假、否）

**為什麼需要布林值？**
條件判斷的結果就是布林值。例如 `5 > 3` 的結果是 `True`，`5 < 3` 的結果是 `False`。

## 邏輯運算子：not

`not` 是一個邏輯運算子，它可以將一個布林值**反轉**。

**語法：**
```
not 布林值
```

**效果：**
- `not True` → `False`（真變成假）
- `not False` → `True`（假變成真）

**為什麼需要 not？**
有時候我們需要檢查「不是...」的情況，例如「今天不忙」就是 `not is_busy`。

## 什麼是巢狀 if？

**巢狀 if** 就是在一個 `if` 裡面再放一個 `if`，形成多層次的判斷。

**為什麼需要巢狀 if？**
當我們需要「先檢查一個條件，如果成立，再檢查另一個條件」時，就需要巢狀 if。

**生活中的例子：**
- 如果今天是假日（第一層判斷）
  - 而且天氣好（第二層判斷）
    - 那就去郊遊

## 實際範例

```
is_holiday = True
is_raining = False
if is_holiday:
    if not is_raining:
        print("太棒了，是個出遊的好日子！")
```

**執行過程：**
1. 檢查外層條件：`is_holiday` 是 `True` → 進入 if 區塊
2. 檢查內層條件：`not is_raining` → `not False` → `True` → 進入內層 if 區塊
3. 執行：`print("太棒了，是個出遊的好日子！")`

**如果 `is_holiday` 是 `False` 會怎樣？**
外層條件不成立，Python 會直接跳過整個 if 區塊，不會檢查內層條件。

**記住：** 巢狀 if 需要多層縮排，內層的 if 要比外層的 if 多縮排一層！
""",
        "exercise": "有兩個布林變數 `is_holiday = True` 和 `is_busy = False`。請寫一個判斷式，如果今天是假日 (`is_holiday` 是 `True`)，**而且**今天不忙 (`is_busy` **不是** `True`)，就印出「可以放鬆一下」。",
        "hint": "您需要一個 `if` 裡面包著另一個 `if`。外層檢查 `is_holiday`，內層檢查 `not is_busy`。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "可以放鬆一下\n"
        }
    },
    {
        "id": "EX2-3",
        "title": "巢狀 if 與換行輸出",
        "explanation": """
## 組合多個條件

我們可以組合多個條件判斷，並且在每個條件下印出不同的訊息。

**為什麼需要組合條件？**
有時候我們需要同時滿足多個條件，例如「成績優秀**而且**出席良好」。

## 換行符號：\\n

`print()` 函式預設會在輸出後自動換行。如果我們想要在**一個** `print()` 中印出多行，可以使用 `\\n`（換行符號）。

**什麼是 `\\n`？**
- `\\n` 是一個**特殊字元**，表示「換行」
- 反斜線 `\\` 告訴 Python「這是一個特殊字元，不是普通的 n」
- `n` 表示「newline」（新行）

**為什麼需要 `\\`？**
因為如果只寫 `n`，Python 會把它當作普通的字母 n。加上 `\\` 後，Python 才知道這是「換行符號」。

## 實際範例

```
print("第一行\\n第二行")
```

**執行過程：**
1. Python 看到字串 `"第一行\\n第二行"`
2. Python 將 `\\n` 轉換為換行
3. 印出：第一行，然後換行，然後第二行

**結果：**
```
第一行
第二行
```

## 兩種印出多行的方法

### 方法 1：使用多個 print()
```
print("第一行")
print("第二行")
```

### 方法 2：使用一個 print() 和 `\\n`
```
print("第一行\\n第二行")
```

**兩種方法效果相同，選擇您喜歡的就好！**

**注意：** 在字串中，`\\n` 必須寫成 `\\n`（兩個字元：反斜線和 n），不是 `/n`！
""",
        "exercise": "有兩個變數 `score = 85` 和 `attendance = True`。請寫程式：\n如果 `score >= 80` 且 `attendance == True`，就印出「成績優秀」和「出席良好」（分兩行）。",
        "hint": "使用巢狀 if 或 `and` 運算子。可以用 `\\n` 在一個 print 中換行，或用兩個 print。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "成績優秀\n出席良好\n"
        }
    },
    {
        "id": "EX2-4",
        "title": "錯誤處理：try-except",
        "explanation": """
## 為什麼需要錯誤處理？

在程式執行時，可能會發生錯誤（例如除以零、型別轉換失敗等）。如果沒有處理，程式會直接停止，這對使用者來說很不友善。

**錯誤處理**可以讓我們優雅地處理錯誤，讓程式繼續執行或顯示友善的錯誤訊息。

**生活中的類比：**
就像您開車時，如果遇到問題（例如沒油），您會處理它（去加油），而不是直接停車不動。

## 什麼是 try-except？

`try-except` 是 Python 的錯誤處理機制。

**基本語法：**
```
try:
    # 可能會出錯的程式碼
except:
    # 如果出錯，執行這裡的程式碼
```

**為什麼用 try？**
`try` 是「嘗試」的意思，告訴 Python「請嘗試執行這段程式碼，如果出錯就處理它」。

**為什麼用 except？**
`except` 是「例外」的意思，表示「如果發生例外（錯誤），就執行這裡的程式碼」。

## 執行流程

1. Python 先執行 `try` 區塊的程式碼
2. 如果沒有錯誤 → 正常執行，跳過 `except` 區塊
3. 如果有錯誤 → 立即跳到 `except` 區塊，執行錯誤處理程式碼

## 實際範例

```
try:
    result = 10 / 0
    print(result)
except:
    print("發生錯誤：不能除以零")
```

**執行過程：**
1. 進入 `try` 區塊
2. 執行 `result = 10 / 0` → **發生錯誤**（不能除以零）
3. Python 立即跳到 `except` 區塊
4. 執行 `print("發生錯誤：不能除以零")`
5. 程式繼續執行（不會因為錯誤而停止）

**如果沒有 try-except：**
```
result = 10 / 0  # 程式會直接停止，顯示錯誤訊息
```

**記住：** `try` 和 `except` 後面都需要冒號 `:`，而且區塊內的程式碼需要縮排！
""",
        "exercise": "請寫一個程式，嘗試將字串 'abc' 轉換成整數並印出。如果轉換失敗，就印出「轉換失敗」。",
        "hint": "使用 int('abc') 會出錯，所以要用 try-except 來捕捉錯誤。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "轉換失敗\n"
        }
    },
    {
        "id": "PT2-1",
        "title": "成績計算：判斷平均成績是否及格",
        "explanation": """
## 結合多個概念

現在我們來練習結合變數、運算和條件判斷。這是實際程式設計中常見的模式。

**為什麼需要結合？**
實際問題通常需要多個步驟：
1. 取得資料（變數）
2. 計算結果（運算）
3. 根據結果做判斷（條件判斷）

## 計算平均成績

假設有兩科成績，我們可以計算平均，然後判斷是否及格（假設 60 分及格）。

**為什麼用括號？**
在計算平均時，我們需要先加總，再除以 2。括號確保運算順序正確。

**運算順序：**
- 沒有括號：`math + english / 2` → 先算除法，再算加法（錯誤！）
- 有括號：`(math + english) / 2` → 先算加法，再算除法（正確！）

## if-else 結構

**什麼是 else？**
`else` 表示「否則」，當 `if` 的條件不成立時，就執行 `else` 區塊。

**語法：**
```
if 條件:
    條件成立時執行
else:
    條件不成立時執行
```

**為什麼需要 else？**
有時候我們需要處理「兩種情況」：條件成立和條件不成立。

## 實際範例

```
math = 70
english = 80
average = (math + english) / 2
if average >= 60:
    print("及格")
else:
    print("不及格")
```

**執行過程：**
1. 計算平均：`(70 + 80) / 2 = 150 / 2 = 75`
2. 檢查條件：`75 >= 60` → `True`
3. 因為條件成立，執行 `print("及格")`
4. 跳過 `else` 區塊

**如果平均是 50 會怎樣？**
1. 計算平均：`50`
2. 檢查條件：`50 >= 60` → `False`
3. 跳過 `if` 區塊
4. 執行 `else` 區塊：`print("不及格")`

**記住：** `if` 和 `else` 是配對的，`else` 不需要寫條件（因為它是「否則」的意思）！

## 接收多個輸入（使用 input()）

**注意：** 如果您還沒學過 `input()` 和 `int()`，可以先使用固定值練習（見下方「使用固定值」的範例）。

當我們需要接收多個輸入時，可以連續使用多個 `input()`：

```
math_score = int(input())
english_score = int(input())
```

**關於 `int()`：**
- `input()` 回傳的是**字串**（文字），例如 `"65"` 是字串
- `int()` 可以將字串轉換成**整數**（數字），例如 `int("65")` 會變成數字 `65`
- 因為我們需要進行數學運算（計算平均），所以必須使用 `int()` 將輸入轉換成數字

**執行過程：**
1. 第一個 `int(input())` 會等待使用者輸入數學成績（例如：輸入 `65`）
2. `int()` 將 `"65"` 轉換成數字 `65`，存到 `math_score`
3. 第二個 `int(input())` 會等待使用者輸入英文成績（例如：輸入 `55`）
4. `int()` 將 `"55"` 轉換成數字 `55`，存到 `english_score`
5. 程式會依序接收這兩個輸入值

**使用固定值的範例（如果您還沒學 input()）：**
```
math_score = 65
english_score = 55
average = (math_score + english_score) / 2
if average >= 60:
    print("及格")
else:
    print("不及格")
```
""",
        "exercise": "請寫一個程式，使用 `int(input())` 接收兩科成績（先數學，後英文），然後計算平均成績。如果平均大於或等於 60，就印出「及格」，否則印出「不及格」。\n\n**提示：** \n- 如果您還沒學過 `input()` 和 `int()`，可以先使用固定值練習：`math_score = 65` 和 `english_score = 55`\n- 當程式執行時，您需要輸入兩個數字。例如：先輸入 65（數學），然後輸入 55（英文）。",
        "hint": "使用兩個 `int(input())` 來接收兩科成績，先計算平均，然後用 if-else 判斷。如果還沒學過 input()，可以先使用固定值：`math_score = 65` 和 `english_score = 55`。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "及格\n",
            "test_inputs": ["65", "55"]
        }
    },
    {
        "id": "PT2-2",
        "title": "成績判定：錯誤、及格、補考或不及格",
        "explanation": """
## 為什麼需要多個條件？

有時候我們需要判斷多種情況，例如成績等級：
- 錯誤（分數不合理）
- 及格
- 補考
- 不及格

**為什麼不能用多個 if？**
如果使用多個獨立的 `if`，可能會同時執行多個區塊。我們需要「只執行一個」區塊。

## if-elif-else 結構

Python 提供了 `elif`（else if 的縮寫）來處理多個條件。

**語法：**
```
if 條件1:
    處理情況1
elif 條件2:
    處理情況2
elif 條件3:
    處理情況3
else:
    處理其他情況
```

**為什麼用 elif？**
`elif` 表示「否則如果」，意思是「如果前面的條件都不成立，再檢查這個條件」。

**執行順序：**
1. 檢查 `if` 條件 → 如果成立，執行並結束
2. 檢查第一個 `elif` 條件 → 如果成立，執行並結束
3. 檢查第二個 `elif` 條件 → 如果成立，執行並結束
4. ...（依此類推）
5. 如果所有條件都不成立，執行 `else`

**重要：** 只會執行**第一個成立**的條件區塊，之後的條件不會再檢查！

## 實際範例

判斷成績等級：
- 如果分數 < 0 或 > 100：錯誤
- 如果分數 >= 60：及格
- 如果分數 >= 50：補考
- 否則：不及格

**為什麼要先檢查錯誤情況？**
因為如果分數不合理，就不需要檢查其他條件了。這是「防禦性程式設計」的概念。

**為什麼條件順序很重要？**
如果先檢查 `>= 50`，再檢查 `>= 60`，那麼 70 分會先符合 `>= 50`，就不會檢查 `>= 60` 了！

**正確的順序：**
1. 先檢查錯誤（最特殊的情況）
2. 再檢查高分（>= 60）
3. 再檢查中等（>= 50）
4. 最後處理其他（不及格）

**記住：** `elif` 是 `else if` 的縮寫，可以有多個 `elif`，但只能有一個 `else`！

## 檢查輸入範圍

在實際程式中，我們經常需要檢查使用者輸入是否在合理範圍內：

```
score = int(input())
if score < 0 or score > 100:
    print("錯誤")
```

這樣可以確保輸入的資料是有效的。
""",
        "exercise": "請寫一個程式，使用 `int(input())` 接收一個成績分數，然後根據以下規則判斷並印出結果：\n- 如果分數 < 0 或 > 100，印出「錯誤」\n- 如果分數 >= 60，印出「及格」\n- 如果分數 >= 50，印出「補考」\n- 否則印出「不及格」\n\n**提示：** 當程式執行時，您可以在輸入框中輸入一個數字（例如：55）來測試程式。",
        "hint": "使用 `int(input())` 接收輸入，然後用 if-elif-else 結構判斷。注意要先檢查錯誤情況（< 0 或 > 100）。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "補考\n",
            "test_inputs": ["55"]
        }
    },
    {
        "id": "PT2-3",
        "title": "帳密檢查：為成績計算系統加上帳密檢查",
        "explanation": """
## 為什麼需要帳密檢查？

在實際應用中，我們經常需要檢查使用者輸入的帳號和密碼是否正確，這是系統安全的基本要求。

**實際應用：**
- 系統登入
- 資料保護
- 使用者認證

**為什麼需要兩個條件？**
因為帳號和密碼都要正確才能登入，缺一不可。

## 邏輯運算子：and

**什麼是 and？**
`and` 表示「而且」，兩個條件都要成立。

**語法：**
```
條件1 and 條件2
```

**執行邏輯：**
- 如果條件1是 `False`，直接回傳 `False`（不檢查條件2）
- 如果條件1是 `True`，才檢查條件2
- 只有兩個條件都是 `True`，才回傳 `True`

**為什麼用 and？**
因為登入需要「帳號正確」**而且**「密碼正確」。

## 條件判斷

**為什麼需要兩個 ==？**
因為我們要分別檢查帳號和密碼是否正確。

**語法：**
```
if input_username == username and input_password == password:
    print("登入成功")
else:
    print("帳號或密碼錯誤")
```

**執行邏輯：**
1. 檢查：`input_username == username`
2. 檢查：`input_password == password`
3. 如果兩個都是 `True` → 登入成功
4. 如果任何一個是 `False` → 登入失敗

## 實際範例

```
username = "admin"
password = "1234"
input_username = "admin"
input_password = "1234"

if input_username == username and input_password == password:
    print("登入成功")
else:
    print("帳號或密碼錯誤")
```

**執行過程：**
1. 檢查：`"admin" == "admin"` → `True`
2. 檢查：`"1234" == "1234"` → `True`
3. `True and True` → `True`
4. 印出：`登入成功`

**如果帳號錯誤：**
```
input_username = "user"
if "user" == "admin" and ...  # False，直接回傳 False
# 不檢查密碼，直接印出「帳號或密碼錯誤」
```

**如果密碼錯誤：**
```
input_password = "wrong"
if "admin" == "admin" and "wrong" == "1234":  # True and False → False
# 印出「帳號或密碼錯誤」
```

**記住：** 
- 使用 `and` 檢查兩個條件
- 兩個條件都要成立才登入成功
- `and` 會短路評估（第一個條件是 False 就不檢查第二個）
- 帳號和密碼都要正確才能登入
""",
        "exercise": "系統設定的帳號是 'student'，密碼是 'python123'。\n使用者輸入的帳號是 input_user = 'student'，密碼是 input_pass = 'python123'。\n請檢查帳號和密碼是否都正確，如果正確就印出「登入成功」，否則印出「登入失敗」。",
        "hint": "使用 `and` 運算子來同時檢查兩個條件。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "登入成功\n"
        }
    },
    {
        "id": "HW2_1",
        "title": "門票計算",
        "explanation": """
## 為什麼需要條件判斷計算票價？

讓我們來練習一個實際的應用：計算門票價格，這是條件判斷的實際應用。

**實際應用：**
- 票務系統
- 價格計算
- 分級收費

**為什麼需要多個條件？**
因為不同年齡有不同的票價，需要根據年齡判斷。

## 票價規則

**假設：**
- 成人票（18-64 歲）：500 元
- 兒童票（未滿 18 歲）：250 元
- 長者票（65 歲以上）：300 元

**為什麼需要三個條件？**
因為有三種不同的票價，需要分別判斷。

## if-elif-else 結構

**為什麼用 elif？**
因為我們要檢查多個條件，但只執行一個區塊。

**語法：**
```
if 條件1:
    執行區塊1
elif 條件2:
    執行區塊2
else:
    執行區塊3
```

**執行邏輯：**
1. 先檢查條件1，如果是 `True`，執行區塊1，結束
2. 如果條件1是 `False`，檢查條件2，如果是 `True`，執行區塊2，結束
3. 如果條件1和條件2都是 `False`，執行 else 區塊

## 判斷順序

**為什麼先檢查 >= 65？**
因為長者票的條件最明確（65 歲以上），先檢查可以避免被其他條件覆蓋。

**語法：**
```
if age >= 65:
    price = 300
elif age < 18:
    price = 250
else:
    price = 500
```

**執行邏輯：**
1. 如果 `age >= 65` → 長者票 300 元
2. 否則如果 `age < 18` → 兒童票 250 元
3. 否則（18-64 歲）→ 成人票 500 元

## 實際範例

```
age = 20
if age >= 65:
    price = 300
elif age < 18:
    price = 250
else:
    price = 500
print(price)
```

**執行過程：**
1. 檢查：`20 >= 65` → `False`，繼續
2. 檢查：`20 < 18` → `False`，繼續
3. 執行 else：`price = 500`
4. 印出：`500`

**如果 age = 10：**
1. 檢查：`10 >= 65` → `False`
2. 檢查：`10 < 18` → `True`，執行 `price = 250`
3. 印出：`250`

**如果 age = 70：**
1. 檢查：`70 >= 65` → `True`，執行 `price = 300`
2. 印出：`300`

**記住：** 
- 使用 `if-elif-else` 處理多個條件
- 先檢查最明確的條件
- 每個條件只會執行一個區塊
- 根據年齡判斷票價

## 實際應用場景

這種分段計費的邏輯在實際生活中很常見：
- 電影院票價（兒童、成人、長者）
- 遊樂園門票
- 交通票價

使用 `input()` 可以讓程式更實用，可以根據不同使用者的年齡計算不同的票價。
""",
        "exercise": "請寫一個程式，使用 `int(input())` 接收使用者的年齡，然後根據以下規則計算門票價格並印出：\n- 65 歲以上：300 元\n- 18 歲以下：250 元\n- 其他：500 元\n\n**提示：** 當程式執行時，您可以在輸入框中輸入一個年齡數字（例如：10）來測試程式。",
        "hint": "使用 `int(input())` 接收輸入，然後用 if-elif-else 結構判斷。注意要先檢查 65 歲以上的情況。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "250\n",
            "test_inputs": ["10"]
        }
    },
    {
        "id": "HW2_2",
        "title": "停車費計算",
        "explanation": """
## 為什麼需要分段計費？

停車費通常是根據停車時間來計算的，這是分段計費的實際應用。

**實際應用：**
- 停車場收費
- 分級計費系統
- 累進計費

**為什麼需要分段？**
因為不同時段有不同的費率，需要分別計算。

## 計費規則

**假設：**
- 前 2 小時：每小時 30 元
- 超過 2 小時的部分：每小時 50 元

**為什麼要分兩段？**
因為前 2 小時和超過的部分費率不同，需要分別計算。

## 計算邏輯

**為什麼用 if-else？**
因為有兩種情況：2 小時以內和超過 2 小時。

**語法：**
```
if hours <= 2:
    cost = hours * 30
else:
    cost = 2 * 30 + (hours - 2) * 50
```

**執行邏輯：**
1. 如果 `hours <= 2`：
   - 全部時間都用 30 元/小時計算
   - `cost = hours * 30`
2. 如果 `hours > 2`：
   - 前 2 小時：`2 * 30 = 60` 元
   - 超過的部分：`(hours - 2) * 50` 元
   - 總計：`cost = 2 * 30 + (hours - 2) * 50`

**為什麼 `(hours - 2)`？**
因為前 2 小時已經用 30 元/小時計算了，超過的部分是 `hours - 2` 小時。

## 實際範例

### 停車 3 小時

```
hours = 3
if hours <= 2:
    cost = hours * 30
else:
    cost = 2 * 30 + (hours - 2) * 50
print(cost)
```

**執行過程：**
1. 檢查：`3 <= 2` → `False`，執行 else
2. 計算：
   - 前 2 小時：`2 * 30 = 60` 元
   - 超過的部分：`(3 - 2) * 50 = 1 * 50 = 50` 元
   - 總計：`cost = 60 + 50 = 110` 元
3. 印出：`110`

### 停車 4 小時

```
hours = 4
if hours <= 2:
    cost = hours * 30
else:
    cost = 2 * 30 + (hours - 2) * 50
```

**執行過程：**
1. 檢查：`4 <= 2` → `False`，執行 else
2. 計算：
   - 前 2 小時：`2 * 30 = 60` 元
   - 超過的部分：`(4 - 2) * 50 = 2 * 50 = 100` 元
   - 總計：`cost = 60 + 100 = 160` 元

**結果：** `160`

### 停車 1 小時

使用 `input()` 可以讓程式更實用，可以根據不同的停車時間計算費用。

```
hours = 1
if hours <= 2:
    cost = 1 * 30 = 30
```

**結果：** `30`

**記住：** 
- 使用 `if-else` 處理分段計費
- 前 2 小時用一種費率
- 超過的部分用另一種費率
- 總費用 = 前段費用 + 超過部分費用
""",
        "exercise": "請寫一個程式，使用 `int(input())` 接收停車時間（小時），然後根據以下規則計算停車費並印出：\n- 前 2 小時：每小時 30 元\n- 超過 2 小時的部分：每小時 50 元\n\n**提示：** 當程式執行時，您可以在輸入框中輸入一個數字（例如：4）來測試程式。",
        "hint": "使用 `int(input())` 接收輸入，前 2 小時是 2*30，超過的部分是 (hours-2)*50，總共是兩者相加。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "160\n",
            "test_inputs": ["4"]
        }
    },
    
    # ========== 第三章：迴圈 ==========
    {
        "id": "EX3-1",
        "title": "For 迴圈：range()",
        "explanation": """
## 為什麼需要迴圈？

當我們需要重複執行某些程式碼時，如果一行一行寫會很麻煩。

**沒有迴圈：**
```
print(0)
print(1)
print(2)
print(3)
print(4)
```
要印 100 個數字就要寫 100 行！

**使用迴圈：**
```
for i in range(5):
    print(i)
```
只需要 2 行就能完成！

## 什麼是 for 迴圈？

**迴圈（Loop）** 可以讓程式碼重複執行多次。

**基本語法：**
```
for 變數 in 範圍:
    要重複執行的程式碼
```

## 為什麼需要 `in` 關鍵字？

`in` 在 Python 中表示「在...裡面」或「屬於...」。

**語法解釋：**
- `for` → 表示「對於每一個」
- `變數` → 每次迴圈時，這個變數會取得不同的值
- `in` → 表示「在...裡面」
- `範圍` → 要遍歷的資料集合

**整體意思：** 「對於範圍裡的每一個值，把它存到變數裡，然後執行下面的程式碼」

## 什麼是 range()？

`range()` 是一個函式，可以產生一個數字序列。

**為什麼需要 range()？**
因為 `for` 迴圈需要一個「範圍」來遍歷，`range()` 可以幫我們產生這個範圍。

## range() 的三種用法

### 1. range(結束值)
```
range(5)
```
**產生：** 0, 1, 2, 3, 4（從 0 開始，到 5 之前）

**為什麼從 0 開始？**
這是程式設計的慣例，因為陣列索引從 0 開始。這樣設計可以讓索引和計數一致。

**為什麼到 5 之前？**
這是「左閉右開」的設計：`range(5)` 包含 0 但不包含 5。這樣 `range(5)` 剛好有 5 個數字（0-4）。

### 2. range(開始值, 結束值)
```
range(1, 5)
```
**產生：** 1, 2, 3, 4（從 1 開始，到 5 之前）

**為什麼要指定開始值？**
有時候我們不想從 0 開始，例如要印出 1 到 10。

### 3. range(開始值, 結束值, 步長)
```
range(1, 10, 2)
```
**產生：** 1, 3, 5, 7, 9（從 1 開始，每次加 2，到 10 之前）

**什麼是步長？**
步長就是每次增加的數值。`range(1, 10, 2)` 表示：1, 1+2=3, 3+2=5, 5+2=7, 7+2=9（下一個是 11，超過 10，所以停止）

**為什麼需要步長？**
可以讓我們跳過某些數字，例如只要奇數或偶數。

## 實際範例

```
for i in range(5):
    print(i)
```

**執行過程：**
1. 第一次：`i = 0`，執行 `print(0)` → 印出 0
2. 第二次：`i = 1`，執行 `print(1)` → 印出 1
3. 第三次：`i = 2`，執行 `print(2)` → 印出 2
4. 第四次：`i = 3`，執行 `print(3)` → 印出 3
5. 第五次：`i = 4`，執行 `print(4)` → 印出 4
6. 沒有更多值了，迴圈結束

**結果：**
```
0
1
2
3
4
```

## 為什麼需要縮排？

迴圈內的程式碼也需要縮排，告訴 Python「這些程式碼是要重複執行的」。

**錯誤寫法：**
```
for i in range(5):
print(i)    # 錯誤！沒有縮排
```

**正確寫法：**
```
for i in range(5):
    print(i)    # 正確！有縮排（四個空格）
```

**記住：** 縮排是 Python 語法的重要部分，不能省略！
""",
        "exercise": "請使用 `for` 迴圈和 `range(5)` 來印出數字 0 到 4（每個數字一行）。\n\n**重要：** 此題目要求使用 `for` 迴圈，不能使用多個 `print()` 語句硬編碼。",
        "hint": "使用 `for i in range(5):` 然後在迴圈內 `print(i)`。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "0\n1\n2\n3\n4\n",
            "code_requirements": {
                "requires_loop": True,
                "loop_type": "for",
                "forbids_hardcode": True
            }
        }
    },
    {
        "id": "EX3-2",
        "title": "求年營業額（4季）",
        "explanation": """
## 為什麼需要累加？

我們可以使用迴圈來處理多筆資料，例如計算總和。

**沒有迴圈的問題：**
```
total = 100 + 150 + 120 + 180
```
如果有很多筆資料，這樣寫會很長很麻煩！

**使用迴圈：**
```
quarters = [100, 150, 120, 180]
total = 0
for q in quarters:
    total = total + q
```
簡潔又容易擴展！

## 累加模式

**為什麼 `total` 要從 0 開始？**
因為我們要「累加」，0 是加法的單位元素（任何數加 0 還是原數）。

**累加的過程：**
1. 初始：`total = 0`
2. 第一次：`total = 0 + 100 = 100`
3. 第二次：`total = 100 + 150 = 250`
4. 第三次：`total = 250 + 120 = 370`
5. 第四次：`total = 370 + 180 = 550`

**為什麼 `total = total + q`？**
這看起來很奇怪，但意思是「把 total 的舊值加上 q，然後存回 total」。

**類比：** 就像您的存錢筒，每次投錢進去，總金額就會增加。

## 實際範例

計算四季的總營業額：
```
quarters = [100, 150, 120, 180]
total = 0
for q in quarters:
    total = total + q
print(total)
```

**執行過程：**
1. 建立列表 `quarters = [100, 150, 120, 180]`
2. 初始化 `total = 0`
3. 迴圈開始：
   - 第一次：`q = 100`，`total = 0 + 100 = 100`
   - 第二次：`q = 150`，`total = 100 + 150 = 250`
   - 第三次：`q = 120`，`total = 250 + 120 = 370`
   - 第四次：`q = 180`，`total = 370 + 180 = 550`
4. 迴圈結束，印出 `total = 550`

**記住：** 累加時，初始值很重要！如果是乘法，初始值應該是 1（乘法的單位元素）。
""",
        "exercise": "有四季的營業額：`Q1 = 100`, `Q2 = 150`, `Q3 = 120`, `Q4 = 180`。\n請使用迴圈計算總營業額並印出。",
        "hint": "可以將四季的營業額放在一個列表中，然後用迴圈累加。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "550\n"
        }
    },
    {
        "id": "EX3-3",
        "title": "列印 * 三角形",
        "explanation": """
## 為什麼需要巢狀迴圈？

我們可以使用**巢狀迴圈**（迴圈裡面還有迴圈）來印出圖形。

**什麼是巢狀迴圈？**
就像俄羅斯娃娃一樣，一個迴圈裡面還有另一個迴圈。

**為什麼需要巢狀迴圈？**
因為圖形有「行」和「列」兩個維度：
- 外層迴圈控制「行數」
- 內層迴圈控制「每行的列數」

## print() 的 end 參數

**為什麼需要 `end=""`？**
`print()` 預設會在輸出後換行，但我們想要在同一行印多個星號。

**語法：**
```
print(要印的內容, end="結尾字元")
```

**為什麼用 `end=""`？**
`end=""` 表示「結尾是空字串」，也就是「不換行」。這樣多個 `print()` 就會印在同一行。

**最後的 `print()` 做什麼？**
用來換行，讓下一行的星號從新的一行開始。

## 實際範例

印出一個 3 行的三角形：
```
for i in range(1, 4):
    for j in range(i):
        print("*", end="")
    print()
```

**執行過程：**
1. 外層迴圈：`i = 1`
   - 內層迴圈：`j = 0`（range(1) 產生 0）
     - 印出 `*`（不換行）
   - 換行 → 第一行：`*`
2. 外層迴圈：`i = 2`
   - 內層迴圈：`j = 0, 1`（range(2) 產生 0, 1）
     - 印出 `*`（不換行）
     - 印出 `*`（不換行）
   - 換行 → 第二行：`**`
3. 外層迴圈：`i = 3`
   - 內層迴圈：`j = 0, 1, 2`（range(3) 產生 0, 1, 2）
     - 印出三個 `*`（不換行）
   - 換行 → 第三行：`***`

**結果：**
```
*
**
***
```

**為什麼內層用 `range(i)`？**
因為第 i 行需要 i 個星號，所以內層迴圈要執行 i 次。

**記住：** 巢狀迴圈需要多層縮排，內層迴圈的程式碼要比外層多縮排一層！
""",
        "exercise": "請使用巢狀迴圈印出一個 4 行的星號三角形（第一行 1 個星號，第二行 2 個，依此類推）。",
        "hint": "外層迴圈控制行數，內層迴圈控制每行的星號數量。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "*\n**\n***\n****\n"
        }
    },
    {
        "id": "EX3-4",
        "title": "列印第 n 個英文字母",
        "explanation": """
## 什麼是 ASCII 碼？

**ASCII（American Standard Code for Information Interchange）** 是一種編碼系統，將字元對應到數字。

**為什麼需要 ASCII 碼？**
電腦只能處理數字，所以需要將字元轉換成數字來儲存和處理。

**常見的 ASCII 碼：**
- 大寫字母 A-Z：65-90
- 小寫字母 a-z：97-122
- 數字 0-9：48-57

## chr() 和 ord() 函式

Python 提供了兩個函式來處理字元和 ASCII 碼：

### ord() - 字元轉數字
```
ord('A')  # 回傳 65
```
**作用：** 將字元轉換為對應的 ASCII 碼（數字）

**為什麼叫 ord？**
ord 是 "ordinal"（序數）的縮寫，表示字元的順序編號。

### chr() - 數字轉字元
```
chr(65)  # 回傳 'A'
```
**作用：** 將 ASCII 碼（數字）轉換為對應的字元

**為什麼叫 chr？**
chr 是 "character"（字元）的縮寫。

## 如何計算第 n 個字母？

**規律：**
- A 是第 1 個，ASCII 碼是 65
- B 是第 2 個，ASCII 碼是 66
- C 是第 3 個，ASCII 碼是 67
- ...

**公式：** 第 n 個字母的 ASCII 碼 = 65 + (n - 1)

**為什麼是 n - 1？**
因為 A 是第 1 個，但它的 ASCII 碼是 65，所以需要減 1。

**簡化：** 第 n 個字母 = `chr(64 + n)` 或 `chr(65 + n - 1)`

## 實際範例

要印出第 3 個大寫字母（C）：
```
print(chr(65 + 2))  # 65 是 A，加 2 就是 C
```

**計算過程：**
1. A 是第 1 個，ASCII 碼是 65
2. 第 3 個 = 65 + (3 - 1) = 65 + 2 = 67
3. `chr(67)` = 'C'

**記住：** 
- `ord()` 是字元 → 數字
- `chr()` 是數字 → 字元
- 大寫字母從 65 開始，小寫字母從 97 開始
""",
        "exercise": "請印出第 5 個大寫英文字母（E）。",
        "hint": "A 是第 1 個（ASCII 65），E 是第 5 個，所以是 65 + 4。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "E\n"
        }
    },
    {
        "id": "EX4-1",
        "title": "While 迴圈",
        "explanation": """
## for 迴圈 vs while 迴圈

除了 `for` 迴圈，Python 還提供 `while` 迴圈。

**什麼時候用 for？**
當您知道要執行幾次時，用 `for`。

**什麼時候用 while？**
當您不知道要執行幾次，只知道「條件成立就繼續」時，用 `while`。

**生活中的類比：**
- `for` = 「做 5 次」（知道次數）
- `while` = 「做到完成為止」（不知道次數，只知道條件）

## while 迴圈的語法

```
while 條件:
    重複執行的程式碼
```

**執行流程：**
1. 檢查條件
2. 如果條件是 `True` → 執行程式碼，然後回到步驟 1
3. 如果條件是 `False` → 跳出迴圈

**為什麼需要冒號和縮排？**
跟 `if` 和 `for` 一樣，`while` 後面需要冒號，區塊內的程式碼需要縮排。

## 實際範例

```
count = 0
while count < 5:
    print(count)
    count = count + 1
```

**執行過程：**
1. `count = 0`，檢查：`0 < 5` → `True` → 印出 0，`count = 1`
2. 檢查：`1 < 5` → `True` → 印出 1，`count = 2`
3. 檢查：`2 < 5` → `True` → 印出 2，`count = 3`
4. 檢查：`3 < 5` → `True` → 印出 3，`count = 4`
5. 檢查：`4 < 5` → `True` → 印出 4，`count = 5`
6. 檢查：`5 < 5` → `False` → 跳出迴圈

**結果：** 印出 0 到 4

## 無限迴圈的危險

**什麼是無限迴圈？**
如果條件永遠是 `True`，迴圈就會永遠執行下去，程式會卡住！

**錯誤範例：**
```
count = 0
while count < 5:
    print(count)
    # 忘記 count = count + 1！
```
`count` 永遠是 0，條件永遠是 `True`，迴圈永遠不會結束！

**如何避免？**
確保在迴圈內有程式碼會改變條件，讓條件最終變成 `False`。

**記住：** 使用 `while` 時，一定要確保條件最終會變成 `False`，否則會形成無限迴圈！
""",
        "exercise": "請使用 `while` 迴圈印出數字 1 到 5（每個數字一行）。",
        "hint": "設定一個變數從 1 開始，在迴圈內印出並遞增，直到大於 5。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "1\n2\n3\n4\n5\n"
        }
    },
    {
        "id": "EX4-2",
        "title": "While, Random, Continue, Break",
        "explanation": """
## 控制迴圈的執行

在迴圈中，我們可以使用兩個關鍵字來控制執行流程：

### break - 跳出迴圈

**作用：** 立即跳出迴圈，不管條件是否還成立。

**為什麼需要 break？**
有時候我們需要在迴圈中間就停止，不需要等到條件變成 `False`。

**語法：**
```
while 條件:
    if 某個情況:
        break  # 立即跳出迴圈
```

**類比：** 就像您在做作業時，如果完成了，就停止，不需要等到時間到。

### continue - 跳過本次迴圈

**作用：** 跳過本次迴圈的剩餘程式碼，繼續下一次迴圈。

**為什麼需要 continue？**
有時候我們想要「跳過某些情況，但繼續迴圈」。

**語法：**
```
while 條件:
    if 某個情況:
        continue  # 跳過本次，繼續下一次
    # 其他程式碼
```

**類比：** 就像您在做作業時，如果遇到不會的題目，先跳過，繼續做下一題。

## random 模組

**什麼是模組？**
模組（Module）是 Python 提供的功能庫，需要先 `import` 才能使用。

**為什麼需要 import？**
Python 為了節省記憶體，不會自動載入所有功能。只有當您需要使用時，才載入。

**random 模組：**
```
import random
random.randint(1, 10)  # 產生 1 到 10 之間的隨機整數
```

**為什麼叫 randint？**
- `rand` = random（隨機）
- `int` = integer（整數）
- `randint` = 隨機整數

**語法：** `random.randint(最小值, 最大值)`
- 包含最小值和最大值
- 例如 `random.randint(1, 10)` 可能產生 1, 2, 3, ..., 10

## while True 迴圈

**什麼是 `while True`？**
`True` 永遠是 `True`，所以這是一個「無限迴圈」。

**為什麼要用無限迴圈？**
當我們不知道要執行幾次，只知道「某個條件滿足時就停止」時，可以用 `while True` 配合 `break`。

**模式：**
```
while True:
    # 做一些事情
    if 停止條件:
        break  # 滿足條件就跳出
```

## 實際範例

```
import random
while True:
    num = random.randint(1, 10)
    print(num)
    if num == 7:
        break
```

**執行過程：**
1. 進入無限迴圈
2. 產生隨機數（例如 3），印出 3
3. 檢查：`3 == 7` → `False`，繼續迴圈
4. 產生隨機數（例如 8），印出 8
5. 檢查：`8 == 7` → `False`，繼續迴圈
6. 產生隨機數（例如 7），印出 7
7. 檢查：`7 == 7` → `True`，執行 `break`，跳出迴圈

**記住：** 
- `break` 是跳出迴圈
- `continue` 是跳過本次，繼續下一次
- `while True` 需要配合 `break` 使用，否則會無限迴圈！
""",
        "exercise": "請寫一個程式，使用 `while True` 迴圈，每次產生一個 1 到 10 的隨機數並印出。如果產生的數字是 5，就跳出迴圈。",
        "hint": "記得 `import random`，使用 `random.randint(1, 10)` 產生隨機數，用 `if num == 5: break` 跳出。",
        "validator": {
            "type": "stdout_contains",
            "expected_output": "5"
        }
    },
    {
        "id": "PT3-1",
        "title": "求 N 的階乘",
        "explanation": """
## 什麼是階乘？

階乘（factorial）是一個重要的數學概念。n 的階乘記作 n!，定義為：
```
n! = n × (n-1) × (n-2) × ... × 2 × 1
```

**為什麼需要階乘？**
階乘在數學、統計、組合數學中都有應用，例如：
- 排列組合的計算
- 機率計算
- 遞迴問題

**特殊情況：**
- 0! = 1（數學定義）
- 1! = 1

## 計算階乘的方法

### 方法 1：使用迴圈（迭代）

**為什麼用迴圈？**
因為階乘是「連續相乘」，可以用迴圈來累乘。

**累乘模式：**
類似累加，但初始值是 1（乘法的單位元素），每次乘以新的數。

**語法：**
```
result = 1
for i in range(1, n + 1):
    result = result * i
```

**為什麼初始值是 1？**
因為 1 是乘法的單位元素（任何數乘以 1 還是原數）。

**為什麼 range(1, n + 1)？**
因為要從 1 乘到 n，所以範圍是 1 到 n（包含 n）。

## 實際範例

計算 5!：
```
n = 5
result = 1
for i in range(1, n + 1):
    result = result * i
print(result)
```

**執行過程：**
1. 初始：`result = 1`
2. 第一次：`i = 1`，`result = 1 × 1 = 1`
3. 第二次：`i = 2`，`result = 1 × 2 = 2`
4. 第三次：`i = 3`，`result = 2 × 3 = 6`
5. 第四次：`i = 4`，`result = 6 × 4 = 24`
6. 第五次：`i = 5`，`result = 24 × 5 = 120`

**結果：** 120

**驗證：** 5! = 5 × 4 × 3 × 2 × 1 = 120 ✓

## 累乘 vs 累加

**累加模式：**
```
total = 0        # 初始值是 0（加法的單位元素）
total = total + i
```

**累乘模式：**
```
result = 1       # 初始值是 1（乘法的單位元素）
result = result * i
```

**記住：** 
- 階乘是連續相乘
- 累乘初始值是 1（不是 0！）
- 範圍是 1 到 n（包含 n）
""",
        "exercise": "請計算 6 的階乘（6!）並印出結果。",
        "hint": "使用 for 迴圈從 1 到 6，將每個數字相乘。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "720\n"
        }
    },
    {
        "id": "PT3-2",
        "title": "成績統計：找出最高分及最高分人數",
        "explanation": """
## 為什麼需要統計功能？

我們可以使用列表來處理多筆成績，找出最高分和有多少人得到最高分。

**實際應用：**
- 找出班級最高分
- 統計有多少人得到滿分
- 分析成績分布

## 找出最高分：max() 函式

**什麼是 max()？**
`max()` 是 Python 的內建函式，可以找出列表中的最大值。

**語法：**
```
max(列表)
```

**為什麼需要 max()？**
雖然可以用迴圈自己找，但 `max()` 更簡潔、更快速。

**執行方式：**
Python 會遍歷整個列表，找出最大的數值。

## 計算出現次數：count() 方法

**什麼是 count()？**
`count()` 是列表的方法，可以計算某個元素出現的次數。

**語法：**
```
列表名稱.count(要計算的元素)
```

**為什麼需要 count()？**
找出最高分後，我們想知道「有多少人得到這個分數」。

## 實際範例

```
scores = [85, 90, 90, 75, 90]
max_score = max(scores)      # 找出最高分
count = scores.count(max_score)  # 計算最高分出現次數
print(max_score)
print(count)
```

**執行過程：**
1. `max(scores)` → 遍歷列表，找出最大值 90
2. `scores.count(90)` → 計算 90 出現的次數：
   - 索引 1：90 ✓
   - 索引 2：90 ✓
   - 索引 4：90 ✓
   - 總共 3 次
3. 印出最高分：90
4. 印出人數：3

**結果：**
```
90
3
```

**記住：** 
- `max()` 找出最大值
- `count()` 計算出現次數
- 先找最高分，再計算次數
""",
        "exercise": "有一個成績列表 `scores = [85, 90, 90, 75, 90, 88]`。請找出最高分和得到最高分的人數，並分別印出（先最高分，後人數）。",
        "hint": "使用 `max()` 找最高分，使用 `count()` 計算次數。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "90\n3\n"
        }
    },
    {
        "id": "PT3-3",
        "title": "列印數字三角形",
        "explanation": """
## 為什麼需要印數字三角形？

我們可以使用巢狀迴圈來印出數字圖形，這是練習巢狀迴圈的好方法。

**實際應用：**
- 練習巢狀迴圈
- 理解迴圈變數的關係
- 圖形輸出練習

## 數字三角形的規律

**觀察規律：**
- 第 1 行：1
- 第 2 行：12
- 第 3 行：123
- 第 4 行：1234

**規律：** 第 i 行印出從 1 到 i 的數字

## 使用巢狀迴圈

**外層迴圈：** 控制行數
```
for i in range(1, 4):  # 從 1 到 3（3 行）
```

**為什麼從 1 開始？**
因為第 1 行要印出 1，第 2 行要印出 1-2，所以行號從 1 開始。

**內層迴圈：** 控制每行的數字
```
for j in range(1, i + 1):  # 從 1 到 i
    print(j, end="")
```

**為什麼 `range(1, i + 1)`？**
- 第 1 行（i=1）：`range(1, 2)` → 1
- 第 2 行（i=2）：`range(1, 3)` → 1, 2
- 第 3 行（i=3）：`range(1, 4)` → 1, 2, 3

**為什麼 `end=""`？**
讓數字印在同一行，不換行。

**最後的 `print()`：**
用來換行，讓下一行的數字從新的一行開始。

## 實際範例

```
for i in range(1, 4):
    for j in range(1, i + 1):
        print(j, end="")
    print()
```

**執行過程：**
1. 外層迴圈：`i = 1`
   - 內層迴圈：`j = 1`（range(1, 2)）
     - 印出 `1`（不換行）
   - 換行 → 第一行：`1`
2. 外層迴圈：`i = 2`
   - 內層迴圈：`j = 1, 2`（range(1, 3)）
     - 印出 `1`（不換行）
     - 印出 `2`（不換行）
   - 換行 → 第二行：`12`
3. 外層迴圈：`i = 3`
   - 內層迴圈：`j = 1, 2, 3`（range(1, 4)）
     - 印出 `1`, `2`, `3`（不換行）
   - 換行 → 第三行：`123`

**結果：**
```
1
12
123
```

**記住：** 
- 外層迴圈控制行數
- 內層迴圈控制每行的數字
- 使用 `end=""` 讓數字不換行
- 最後用 `print()` 換行
""",
        "exercise": "請使用巢狀迴圈印出一個 4 行的數字三角形（第一行 1，第二行 12，第三行 123，第四行 1234）。",
        "hint": "外層迴圈控制行數，內層迴圈印出該行的數字。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "1\n12\n123\n1234\n"
        }
    },
    {
        "id": "PT4-1",
        "title": "成績計算：班級人數 & 班級平均成績",
        "explanation": """
## 為什麼需要計算人數和平均？

我們可以使用迴圈來處理多筆成績，計算總和和平均。

**實際應用：**
- 計算班級人數
- 計算平均成績
- 統計分析

## 累加模式：總分和計數

**為什麼需要兩個累加器？**
- `total`：累加總分
- `count`：累加人數

**為什麼初始值都是 0？**
- `total = 0`：加法的單位元素
- `count = 0`：計數從 0 開始

## 計算過程

**語法：**
```
total = 0
count = 0
for score in scores:
    total = total + score  # 累加總分
    count = count + 1      # 累加人數
average = total / count    # 計算平均
```

**為什麼在迴圈內累加？**
因為要遍歷每個成績，逐個累加。

**為什麼 `count = count + 1`？**
每次處理一個成績，人數就加 1。

## 實際範例

```
scores = [85, 90, 75, 88, 92]
total = 0
count = 0
for score in scores:
    total = total + score
    count = count + 1
average = total / count
print(count)
print(average)
```

**執行過程：**
1. 初始：`total = 0`, `count = 0`
2. 第一次：`score = 85`
   - `total = 0 + 85 = 85`
   - `count = 0 + 1 = 1`
3. 第二次：`score = 90`
   - `total = 85 + 90 = 175`
   - `count = 1 + 1 = 2`
4. 第三次：`score = 75`
   - `total = 175 + 75 = 250`
   - `count = 2 + 1 = 3`
5. 第四次：`score = 88`
   - `total = 250 + 88 = 338`
   - `count = 3 + 1 = 4`
6. 第五次：`score = 92`
   - `total = 338 + 92 = 430`
   - `count = 4 + 1 = 5`
7. 計算平均：`average = 430 / 5 = 86.0`
8. 印出：`5`（人數）
9. 印出：`86.0`（平均）

**結果：**
```
5
86.0
```

## 簡化方法

**也可以使用內建函式：**
```
scores = [85, 90, 75, 88, 92]
count = len(scores)      # 計算人數
total = sum(scores)      # 計算總分
average = total / count  # 計算平均
```

**兩種方法效果相同！**

**記住：** 
- 累加總分：`total = total + score`
- 累加人數：`count = count + 1`
- 平均 = 總分 ÷ 人數
- 也可以使用 `len()` 和 `sum()` 簡化
""",
        "exercise": "有一個成績列表 `scores = [85, 90, 75, 88, 92]`。請計算班級人數和平均成績，並分別印出（先人數，後平均）。",
        "hint": "使用迴圈累加總分和計數，然後計算平均。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "5\n86.0\n"
        }
    },
    {
        "id": "PT4-2",
        "title": "連續擲骰子直到出現1",
        "explanation": """
## 為什麼需要條件停止的迴圈？

我們可以使用 `while` 迴圈配合 `random` 來模擬擲骰子，直到出現特定結果。

**實際應用：**
- 模擬遊戲
- 隨機實驗
- 條件滿足時停止

## while True 配合 break

**為什麼用 `while True`？**
因為我們不知道要擲幾次，只知道「出現 1 就停止」。

**模式：**
```
while True:
    # 執行操作
    if 停止條件:
        break  # 跳出迴圈
```

**為什麼需要 break？**
因為 `while True` 是無限迴圈，必須用 `break` 來停止。

## random 模組

**為什麼需要 import？**
`random` 是 Python 的模組，需要先匯入才能使用。

**語法：**
```
import random
random.randint(1, 6)  # 產生 1 到 6 之間的隨機整數
```

**為什麼叫 randint？**
- `rand` = random（隨機）
- `int` = integer（整數）
- `randint` = 隨機整數

**語法：** `random.randint(最小值, 最大值)`
- 包含最小值和最大值
- 例如 `random.randint(1, 6)` 可能產生 1, 2, 3, 4, 5, 6

## 計數器

**為什麼需要計數器？**
有時候我們想知道「執行了幾次」。

**語法：**
```
count = 0
while True:
    count = count + 1  # 每次加 1
    # ...
```

**為什麼初始值是 0？**
因為計數從 0 開始，第一次執行後變成 1。

## 實際範例

```
import random
count = 0
while True:
    dice = random.randint(1, 6)
    count = count + 1
    print(dice)
    if dice == 1:
        break
print("總共擲了", count, "次")
```

**執行過程：**
1. 匯入 `random` 模組
2. 初始化 `count = 0`
3. 進入無限迴圈：
   - 第一次：`dice = 3`（假設），`count = 1`，印出 3，繼續
   - 第二次：`dice = 5`（假設），`count = 2`，印出 5，繼續
   - 第三次：`dice = 1`，`count = 3`，印出 1，執行 `break`，跳出迴圈
4. 印出：`總共擲了 3 次`

**結果（範例）：**
```
3
5
1
總共擲了 3 次
```

**注意：** 每次執行的結果可能不同，因為是隨機的！

**記住：** 
- `while True` 需要配合 `break` 使用
- `random.randint(1, 6)` 產生 1-6 的隨機數
- 使用計數器追蹤執行次數
- 條件滿足時用 `break` 跳出
""",
        "exercise": "請寫一個程式，連續擲一顆骰子（1-6），每次印出結果，直到出現 1 為止。然後印出「結束」。",
        "hint": "使用 `while True` 和 `random.randint(1, 6)`，當出現 1 時用 `break` 跳出。",
        "validator": {
            "type": "stdout_ends_with",
            "expected_output": "結束\n"
        }
    },
    {
        "id": "PT4-3",
        "title": "連續擲3顆骰子直到總和>=10",
        "explanation": """
## 為什麼需要多個隨機數？

我們可以同時擲多顆骰子，計算總和，然後根據條件決定是否繼續。

**實際應用：**
- 模擬多顆骰子遊戲
- 計算多個隨機數的總和
- 條件判斷停止

## 產生多個隨機數

**為什麼需要多個變數？**
因為每顆骰子都是獨立的，需要分別產生。

**語法：**
```
dice1 = random.randint(1, 6)
dice2 = random.randint(1, 6)
dice3 = random.randint(1, 6)
```

**為什麼每個都要呼叫一次？**
因為每次呼叫 `random.randint()` 都會產生新的隨機數。

## 計算總和

**語法：**
```
total = dice1 + dice2 + dice3
```

**為什麼要計算總和？**
因為我們要根據總和來決定是否停止。

**總和的範圍：**
- 最小值：1 + 1 + 1 = 3
- 最大值：6 + 6 + 6 = 18

## 條件判斷

**為什麼用 `>=`？**
`>=` 表示「大於或等於」，當總和達到 10 或以上時就停止。

**語法：**
```
if total >= 10:
    break
```

**為什麼用 break？**
因為要跳出 `while True` 迴圈。

## 實際範例

```
import random
while True:
    dice1 = random.randint(1, 6)
    dice2 = random.randint(1, 6)
    dice3 = random.randint(1, 6)
    total = dice1 + dice2 + dice3
    print(total)
    if total >= 10:
        break
```

**執行過程：**
1. 匯入 `random` 模組
2. 進入無限迴圈：
   - 第一次：
     - `dice1 = 2`, `dice2 = 3`, `dice3 = 1`（假設）
     - `total = 2 + 3 + 1 = 6`
     - 印出 6
     - `6 >= 10` → `False`，繼續
   - 第二次：
     - `dice1 = 4`, `dice2 = 2`, `dice3 = 3`（假設）
     - `total = 4 + 2 + 3 = 9`
     - 印出 9
     - `9 >= 10` → `False`，繼續
   - 第三次：
     - `dice1 = 3`, `dice2 = 4`, `dice3 = 3`（假設）
     - `total = 3 + 4 + 3 = 10`
     - 印出 10
     - `10 >= 10` → `True`，執行 `break`，跳出迴圈

**結果（範例）：**
```
6
9
10
```

**注意：** 每次執行的結果可能不同，因為是隨機的！

**記住：** 
- 多個隨機數需要多次呼叫 `random.randint()`
- 計算總和：`total = dice1 + dice2 + dice3`
- 使用 `>=` 判斷是否達到條件
- 條件滿足時用 `break` 跳出
""",
        "exercise": "請寫一個程式，每次擲 3 顆骰子，計算總和並印出，直到總和 >= 10 為止。",
        "hint": "在迴圈內產生三個隨機數，計算總和，如果 >= 10 就跳出。",
        "validator": {
            "type": "stdout_contains",
            "expected_output": "10"
        }
    },
    {
        "id": "HW3-1",
        "title": "列印出1+2+...+N之運算式",
        "explanation": """
## 為什麼需要建立運算式字串？

我們可以使用迴圈來建立字串，印出運算式，這是字串處理的常見應用。

**實際應用：**
- 顯示運算式
- 格式化輸出
- 字串拼接

**為什麼不用直接印出？**
因為我們需要將多個數字用 `+` 連接成一個字串。

## 方法 1：使用字串拼接

**為什麼需要判斷第一個？**
因為第一個數字前面不需要 `+`。

**語法：**
```
result = ""
for i in range(1, n + 1):
    if i == 1:
        result = str(i)
    else:
        result = result + "+" + str(i)
```

**執行邏輯：**
1. 第一個數字：直接加入（不加 `+`）
2. 後續數字：先加 `+`，再加數字

**為什麼用 str()？**
因為要將數字轉換成字串才能拼接。

## 方法 2：使用列表和 join()（推薦）

**為什麼用列表？**
因為可以先收集所有數字，再用 `join()` 連接。

**語法：**
```
numbers = []
for i in range(1, n + 1):
    numbers.append(str(i))
print("+".join(numbers))
```

**執行邏輯：**
1. 建立空列表
2. 將每個數字轉成字串並加入列表
3. 使用 `join()` 用 `+` 連接

**為什麼用 join()？**
因為 `join()` 可以一次連接所有元素，比逐個拼接更簡潔。

## 實際範例

### 方法 1：字串拼接

```
n = 5
result = ""
for i in range(1, n + 1):
    if i == 1:
        result = str(1)
    else:
        result = result + "+" + str(i)
print(result)
```

**執行過程：**
1. `i = 1`：`result = "1"`
2. `i = 2`：`result = "1" + "+" + "2" = "1+2"`
3. `i = 3`：`result = "1+2" + "+" + "3" = "1+2+3"`
4. `i = 4`：`result = "1+2+3" + "+" + "4" = "1+2+3+4"`
5. `i = 5`：`result = "1+2+3+4" + "+" + "5" = "1+2+3+4+5"`

**結果：** `1+2+3+4+5`

### 方法 2：列表和 join()（更簡潔）

```
n = 5
numbers = []
for i in range(1, n + 1):
    numbers.append(str(i))
print("+".join(numbers))
```

**執行過程：**
1. 迴圈建立：`numbers = ["1", "2", "3", "4", "5"]`
2. `"+".join(["1", "2", "3", "4", "5"])` → `"1+2+3+4+5"`

**結果：** `1+2+3+4+5`

**記住：** 
- 使用 `str()` 將數字轉成字串
- 第一個數字前面不需要 `+`
- 使用列表和 `join()` 更簡潔
- `join()` 是字串的方法，用分隔符號連接列表
""",
        "exercise": "請印出 1+2+3+4+5+6 這個運算式。",
        "hint": "使用迴圈建立字串，用 + 連接數字。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "1+2+3+4+5+6\n"
        }
    },
    {
        "id": "HW3-2",
        "title": "列印九九乘法表",
        "explanation": """
## 為什麼需要巢狀迴圈？

我們可以使用巢狀迴圈來印出九九乘法表，這是巢狀迴圈的經典應用。

**實際應用：**
- 數學練習
- 表格輸出
- 二維資料處理

**為什麼需要兩個迴圈？**
因為乘法表有「行」和「列」兩個維度，需要兩個迴圈。

## 基本結構

**為什麼用 range(1, 10)？**
因為乘法表是從 1 到 9，`range(1, 10)` 產生 1 到 9。

**語法：**
```
for i in range(1, 10):
    for j in range(1, 10):
        print(i, "*", j, "=", i * j, end="  ")
    print()
```

**執行邏輯：**
1. 外層迴圈：`i` 從 1 到 9（控制被乘數）
2. 內層迴圈：`j` 從 1 到 9（控制乘數）
3. 印出：`i * j = 結果`（不換行）
4. 內層迴圈結束後換行

**為什麼用 end="  "？**
因為要讓同一行的多個結果印在一起，用空格分隔。

**為什麼最後有 print()？**
因為要換行，讓下一行的結果從新的一行開始。

## 控制每行輸出數量

**為什麼需要控制？**
因為有時候我們想要每行只印幾個，讓輸出更整齊。

**策略：**
使用計數器追蹤已印出的數量，每印出指定數量就換行。

**語法：**
```
count = 0
for i in range(1, 10):
    for j in range(1, 10):
        print(i, "*", j, "=", i * j, end="  ")
        count = count + 1
        if count % 3 == 0:
            print()
```

**為什麼用 `count % 3 == 0`？**
因為 `%` 是取餘數，`count % 3 == 0` 表示 `count` 是 3 的倍數（每 3 個換行）。

## 實際範例

### 印出 2 的乘法表，每行 3 個

```
i = 2
count = 0
for j in range(1, 10):
    print(i, "*", j, "=", i * j, end="  ")
    count = count + 1
    if count % 3 == 0:
        print()
```

**執行過程：**
1. `j = 1`：印出 `2 * 1 = 2  `，`count = 1`
2. `j = 2`：印出 `2 * 2 = 4  `，`count = 2`
3. `j = 3`：印出 `2 * 3 = 6  `，`count = 3`，`3 % 3 == 0` → 換行
4. `j = 4`：印出 `2 * 4 = 8  `，`count = 4`
5. `j = 5`：印出 `2 * 5 = 10  `，`count = 5`
6. `j = 6`：印出 `2 * 6 = 12  `，`count = 6`，`6 % 3 == 0` → 換行
7. ...依此類推

**結果：**
```
2 * 1 = 2  2 * 2 = 4  2 * 3 = 6  
2 * 4 = 8  2 * 5 = 10  2 * 6 = 12  
2 * 7 = 14  2 * 8 = 16  2 * 9 = 18  
```

**記住：** 
- 使用巢狀迴圈處理二維資料
- 外層迴圈控制行，內層迴圈控制列
- 使用 `end="  "` 讓結果不換行
- 使用計數器和 `%` 控制每行輸出數量
""",
        "exercise": "請印出 2 的乘法表（2*1=2, 2*2=4, ..., 2*9=18），每行印 3 個，用空格分隔。",
        "hint": "使用 for 迴圈從 1 到 9，每 3 個換行。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "2*1=2  2*2=4  2*3=6  \n2*4=8  2*5=10  2*6=12  \n2*7=14  2*8=16  2*9=18  \n"
        }
    },
    {
        "id": "HW3-3",
        "title": "列印字母三角形",
        "explanation": """
## 為什麼需要 chr() 和巢狀迴圈？

我們可以使用 `chr()` 和迴圈來印出字母三角形，這是結合 ASCII 碼和巢狀迴圈的應用。

**實際應用：**
- 圖形輸出
- 字母模式
- 練習巢狀迴圈

**為什麼需要 chr()？**
因為我們要用數字產生字母，`chr()` 可以將 ASCII 碼轉換成字元。

## chr() 函式

**什麼是 chr()？**
`chr()` 是 Python 的內建函式，將 ASCII 碼（數字）轉換成對應的字元。

**語法：**
```
chr(ASCII碼)
```

**為什麼叫 chr？**
`chr` 是 "character"（字元）的縮寫。

**常見的 ASCII 碼：**
- 65：'A'
- 66：'B'
- 67：'C'
- ...
- 90：'Z'

**為什麼從 65 開始？**
因為大寫字母 A 的 ASCII 碼是 65。

## 巢狀迴圈結構

**為什麼需要兩個迴圈？**
因為三角形有「行」和「每行的字母數」兩個維度。

**語法：**
```
for i in range(行數):
    for j in range(i + 1):
        print(chr(65 + j), end="")
    print()
```

**執行邏輯：**
1. 外層迴圈：`i` 從 0 到（行數-1），控制行數
2. 內層迴圈：`j` 從 0 到 `i`，控制每行的字母數
3. 印出：`chr(65 + j)`（不換行）
4. 內層迴圈結束後換行

**為什麼 `range(i + 1)`？**
因為第 `i` 行（從 0 開始）需要 `i + 1` 個字母。

**為什麼 `65 + j`？**
因為 `j` 從 0 開始，`65 + 0 = 65`（A），`65 + 1 = 66`（B），依此類推。

## 實際範例

### 印出 4 行的字母三角形

```
for i in range(4):
    for j in range(i + 1):
        print(chr(65 + j), end="")
    print()
```

**執行過程：**
1. 外層：`i = 0`
   - 內層：`j = 0`（range(1)）
     - 印出：`chr(65 + 0) = 'A'`（不換行）
   - 換行 → 第一行：`A`
2. 外層：`i = 1`
   - 內層：`j = 0, 1`（range(2)）
     - 印出：`'A'`, `'B'`（不換行）
   - 換行 → 第二行：`AB`
3. 外層：`i = 2`
   - 內層：`j = 0, 1, 2`（range(3)）
     - 印出：`'A'`, `'B'`, `'C'`（不換行）
   - 換行 → 第三行：`ABC`
4. 外層：`i = 3`
   - 內層：`j = 0, 1, 2, 3`（range(4)）
     - 印出：`'A'`, `'B'`, `'C'`, `'D'`（不換行）
   - 換行 → 第四行：`ABCD`

**結果：**
```
A
AB
ABC
ABCD
```

**記住：** 
- 使用 `chr()` 將 ASCII 碼轉換成字元
- 大寫字母 A 的 ASCII 碼是 65
- 使用巢狀迴圈控制行和列
- 使用 `end=""` 讓字母不換行
- 最後用 `print()` 換行
""",
        "exercise": "請印出一個 4 行的字母三角形，第一行 A，第二行 AB，第三行 ABC，第四行 ABCD。",
        "hint": "使用巢狀迴圈，外層控制行數，內層印出字母。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "A\nAB\nABC\nABCD\n"
        }
    },
    {
        "id": "HW3-4",
        "title": "列印大小寫英文字母",
        "explanation": """
## 為什麼需要 chr() 和迴圈？

我們可以使用 `chr()` 和迴圈來印出所有英文字母，這是 ASCII 碼和迴圈的應用。

**實際應用：**
- 字母生成
- 字元處理
- 練習迴圈

**為什麼不用手動寫？**
因為有 26 個字母，用迴圈更簡潔。

## ASCII 碼範圍

**大寫字母：**
- A-Z 的 ASCII 碼是 65-90
- 共 26 個字母

**小寫字母：**
- a-z 的 ASCII 碼是 97-122
- 共 26 個字母

**為什麼大寫和小寫的 ASCII 碼不同？**
因為在 ASCII 碼中，大寫和小寫是不同的字元，有不同的編碼。

**為什麼大寫從 65 開始？**
因為 ASCII 碼中，65 對應 'A'，66 對應 'B'，依此類推。

**為什麼小寫從 97 開始？**
因為 ASCII 碼中，97 對應 'a'，98 對應 'b'，依此類推。

## 使用迴圈印出

**為什麼用 range(26)？**
因為有 26 個字母，`range(26)` 產生 0 到 25。

**語法：**
```
for i in range(26):
    print(chr(65 + i), end="")  # 大寫
print()
for i in range(26):
    print(chr(97 + i), end="")  # 小寫
print()
```

**執行邏輯：**
1. 第一個迴圈：`i` 從 0 到 25
   - `chr(65 + i)` → 從 'A' 到 'Z'
   - 用 `end=""` 讓字母不換行
2. 換行
3. 第二個迴圈：`i` 從 0 到 25
   - `chr(97 + i)` → 從 'a' 到 'z'
   - 用 `end=""` 讓字母不換行
4. 換行

## 實際範例

```
for i in range(26):
    print(chr(65 + i), end="")
print()
for i in range(26):
    print(chr(97 + i), end="")
print()
```

**執行過程（大寫）：**
1. `i = 0`：`chr(65 + 0) = chr(65) = 'A'`
2. `i = 1`：`chr(65 + 1) = chr(66) = 'B'`
3. `i = 2`：`chr(65 + 2) = chr(67) = 'C'`
4. ...依此類推到 'Z'
5. 換行

**執行過程（小寫）：**
1. `i = 0`：`chr(97 + 0) = chr(97) = 'a'`
2. `i = 1`：`chr(97 + 1) = chr(98) = 'b'`
3. `i = 2`：`chr(97 + 2) = chr(99) = 'c'`
4. ...依此類推到 'z'
5. 換行

**結果：**
```
ABCDEFGHIJKLMNOPQRSTUVWXYZ
abcdefghijklmnopqrstuvwxyz
```

**記住：** 
- 大寫字母 A-Z：ASCII 碼 65-90
- 小寫字母 a-z：ASCII 碼 97-122
- 使用 `chr()` 將 ASCII 碼轉換成字元
- 使用 `range(26)` 產生 26 個字母
- 使用 `end=""` 讓字母不換行
""",
        "exercise": "請分別印出所有大寫字母（A-Z）和所有小寫字母（a-z），各一行。",
        "hint": "使用兩個迴圈，一個從 65 到 90，一個從 97 到 122。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "ABCDEFGHIJKLMNOPQRSTUVWXYZ\nabcdefghijklmnopqrstuvwxyz\n"
        }
    },
    {
        "id": "HW4-1",
        "title": "帳密檢查&成績計算",
        "explanation": """
## 為什麼需要結合多個功能？

結合條件判斷和迴圈，我們可以建立一個簡單的登入系統，這是實際應用的範例。

**實際應用：**
- 系統登入
- 功能保護
- 多步驟流程

**為什麼需要先登入？**
因為成績計算可能是敏感功能，需要先驗證身份。

## 登入檢查

**為什麼需要兩個條件？**
因為帳號和密碼都要正確才能登入。

**語法：**
```
if input_user == username and input_pass == password:
    print("登入成功")
    # 執行後續功能
else:
    print("登入失敗")
```

**執行邏輯：**
1. 檢查帳號和密碼
2. 如果正確 → 登入成功，執行後續功能
3. 如果不正確 → 登入失敗，不執行後續功能

## 成績計算

**為什麼在登入成功後才計算？**
因為只有登入成功才能使用成績計算功能。

**語法：**
```
score1 = 85
score2 = 90
average = (score1 + score2) / 2
print("平均成績：", average)
```

**執行邏輯：**
1. 取得兩個成績
2. 計算平均：`(score1 + score2) / 2`
3. 印出結果

**為什麼用括號？**
因為要先計算 `score1 + score2`，再除以 2。

## 實際範例

```
username = "admin"
password = "1234"
input_user = "admin"
input_pass = "1234"

if input_user == username and input_pass == password:
    print("登入成功")
    score1 = 85
    score2 = 90
    average = (score1 + score2) / 2
    print("平均成績：", average)
else:
    print("登入失敗")
```

**執行過程：**
1. 檢查：`"admin" == "admin"` → `True`
2. 檢查：`"1234" == "1234"` → `True`
3. `True and True` → `True`
4. 執行 if 區塊：
   - 印出：`登入成功`
   - 計算：`average = (85 + 90) / 2 = 87.5`
   - 印出：`平均成績： 87.5`

**結果：**
```
登入成功
平均成績： 87.5
```

**如果登入失敗：**
```
input_pass = "wrong"
if "admin" == "admin" and "wrong" == "1234":  # True and False → False
    # 不執行
else:
    print("登入失敗")
```

**結果：** `登入失敗`

**記住：** 
- 使用 `and` 檢查兩個條件
- 登入成功後才執行後續功能
- 平均 = 總分 ÷ 科目數
- 使用括號確保計算順序正確
""",
        "exercise": "系統帳號是 'student'，密碼是 'pass123'。\n輸入的帳號是 user = 'student'，密碼是 pwd = 'pass123'。\n如果登入成功，請計算兩科成績 math=85 和 english=75 的平均並印出「平均：」和平均分數。\n如果登入失敗，印出「登入失敗」。",
        "hint": "先檢查帳密，成功後計算平均。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "平均： 80.0\n"
        }
    },
    {
        "id": "HW4-2",
        "title": "猜幸運數字(1~9)最多三次機會",
        "explanation": """
## 為什麼需要限制嘗試次數？

我們可以使用迴圈來限制嘗試次數，這是遊戲和互動程式的常見模式。

**實際應用：**
- 猜數字遊戲
- 限制嘗試次數
- 互動式程式

**為什麼需要限制？**
因為無限嘗試會讓遊戲失去挑戰性，限制次數增加趣味性。

## 計數器模式

**為什麼需要計數器？**
因為我們要追蹤「已經嘗試了幾次」。

**語法：**
```
attempts = 0
max_attempts = 3
```

**為什麼初始值是 0？**
因為計數從 0 開始，第一次嘗試後變成 1。

## 迴圈條件

**為什麼用 `attempts < max_attempts`？**
因為我們要限制在最多 3 次，所以當 `attempts < 3` 時繼續嘗試。

**語法：**
```
while attempts < max_attempts:
    # 猜數字
    attempts = attempts + 1
```

**為什麼在迴圈內加 1？**
因為每次嘗試後，次數就加 1。

## 猜數字邏輯

**為什麼需要三個條件？**
因為有三種情況：猜對、太小、太大。

**語法：**
```
if guess == lucky_number:
    print("猜對了！")
    break
elif guess < lucky_number:
    print("太小了")
else:
    print("太大了")
```

**執行邏輯：**
1. 如果猜對 → 印出「猜對了」，用 `break` 跳出
2. 如果太小 → 印出「太小了」，繼續
3. 如果太大 → 印出「太大了」，繼續

**為什麼用 break？**
因為猜對後不需要繼續嘗試，直接跳出迴圈。

## 實際範例

```
lucky_number = 7
max_attempts = 3
attempts = 0

while attempts < max_attempts:
    guess = 5  # 假設輸入
    attempts = attempts + 1
    
    if guess == lucky_number:
        print("猜對了！")
        break
    elif guess < lucky_number:
        print("太小了")
    else:
        print("太大了")
```

**執行過程（假設都猜錯）：**
1. 第一次：`guess = 5`，`attempts = 1`
   - `5 < 7` → 印出「太小了」
2. 第二次：`guess = 8`，`attempts = 2`
   - `8 > 7` → 印出「太大了」
3. 第三次：`guess = 6`，`attempts = 3`
   - `6 < 7` → 印出「太小了」
4. 迴圈結束（`attempts < 3` → `False`）

**如果第二次猜對：**
1. 第一次：`guess = 5`，印出「太小了」
2. 第二次：`guess = 7`，`attempts = 2`
   - `7 == 7` → 印出「猜對了！」，執行 `break`，跳出迴圈

**記住：** 
- 使用計數器追蹤嘗試次數
- 使用 `while attempts < max_attempts` 限制次數
- 使用 `if-elif-else` 判斷猜測結果
- 猜對後用 `break` 跳出
- 提供提示（太小/太大）幫助使用者
""",
        "exercise": "幸運數字是 `lucky = 5`。請寫一個程式，最多猜 3 次。\n如果猜的數字 `guess = 3` 小於幸運數字，印出「太小」；如果大於，印出「太大」；如果等於，印出「猜對了」並結束。\n（假設第一次猜 3，第二次猜 7，第三次猜 5）",
        "hint": "使用迴圈控制次數，用 if-elif 判斷大小。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "太小\n太大\n猜對了\n"
        }
    },
    {
        "id": "HW4-3",
        "title": "整數位數分析",
        "explanation": """
## 為什麼需要分析整數位數？

我們可以使用迴圈和除法來分析一個整數的每一位數字，這是數字處理的常見需求。

**實際應用：**
- 數字驗證
- 位數統計
- 數字處理

**為什麼需要迴圈？**
因為我們不知道數字有幾位，需要用迴圈逐位處理。

## 取得每一位數字

**為什麼用 % 10？**
因為 `num % 10` 可以取得個位數（除以 10 的餘數）。

**語法：**
```
digit = num % 10
```

**為什麼用 // 10？**
因為 `num // 10` 可以去掉個位數（整數除法）。

**語法：**
```
num = num // 10
```

**執行邏輯：**
1. 取得個位數：`num % 10`
2. 去掉個位數：`num // 10`
3. 重複直到 `num` 變成 0

## 儲存數字

**為什麼用列表？**
因為我們要收集每一位數字，列表可以儲存多個值。

**語法：**
```
digits = []
while num > 0:
    digit = num % 10
    digits.append(digit)
    num = num // 10
```

**為什麼要 reverse()？**
因為我們是從個位數開始取得，列表的順序是反的（例如 [4, 3, 2, 1]），需要反轉成正確順序（[1, 2, 3, 4]）。

## 計算位數

**為什麼用 len()？**
因為列表的長度就是位數。

**語法：**
```
位數 = len(digits)
```

## 實際範例

### 分析 1234

```
num = 1234
digits = []
while num > 0:
    digit = num % 10
    digits.append(digit)
    num = num // 10
digits.reverse()
print("位數：", len(digits))
```

**執行過程：**
1. 第一次：`num = 1234`
   - `digit = 1234 % 10 = 4`
   - `digits = [4]`
   - `num = 1234 // 10 = 123`
2. 第二次：`num = 123`
   - `digit = 123 % 10 = 3`
   - `digits = [4, 3]`
   - `num = 123 // 10 = 12`
3. 第三次：`num = 12`
   - `digit = 12 % 10 = 2`
   - `digits = [4, 3, 2]`
   - `num = 12 // 10 = 1`
4. 第四次：`num = 1`
   - `digit = 1 % 10 = 1`
   - `digits = [4, 3, 2, 1]`
   - `num = 1 // 10 = 0`
5. 迴圈結束（`num = 0`）
6. `digits.reverse()` → `[1, 2, 3, 4]`
7. `len([1, 2, 3, 4]) = 4`

**結果：** `位數： 4`

### 簡化方法：只計算位數

如果只需要位數，不需要儲存每一位：

```
num = 5678
count = 0
while num > 0:
    count = count + 1
    num = num // 10
print("位數：", count)
```

**執行過程：**
1. `num = 5678`，`count = 0`
2. 第一次：`count = 1`，`num = 567`
3. 第二次：`count = 2`，`num = 56`
4. 第三次：`count = 3`，`num = 5`
5. 第四次：`count = 4`，`num = 0`
6. 迴圈結束

**結果：** `位數： 4`

**記住：** 
- 使用 `% 10` 取得個位數
- 使用 `// 10` 去掉個位數
- 使用 `while num > 0` 迴圈處理
- 使用 `len()` 計算位數
- 如果需要正確順序，使用 `reverse()`

## 使用 input() 接收數字

使用 `input()` 可以讓程式更實用，可以計算任意數字的位數：

```
number = int(input())
```

這樣使用者可以輸入任何數字，程式都能計算出位數。
""",
        "exercise": "請寫一個程式，使用 `int(input())` 接收一個數字，然後計算它的位數並印出「位數：」和位數值。\n\n**提示：** 當程式執行時，您可以在輸入框中輸入一個數字（例如：5678）來測試程式。",
        "hint": "使用 `int(input())` 接收輸入，然後使用迴圈除以 10，計算需要幾次才能變成 0。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "位數： 4\n",
            "test_inputs": ["5678"]
        }
    },
    {
        "id": "HW4-4",
        "title": "判斷【遞增數】",
        "explanation": """
## 什麼是遞增數？

遞增數是指每一位數字都比前一位大的數字，例如 1234、5678 等。

**實際應用：**
- 數字驗證
- 模式識別
- 數學問題

**為什麼需要檢查？**
因為我們需要判斷一個數字是否符合遞增的規則。

## 取得每一位數字

**為什麼需要先取得所有位數？**
因為我們要比較相鄰的位數，需要先取得所有位數。

**語法：**
```
num = 1234
digits = []
while num > 0:
    digits.append(num % 10)
    num = num // 10
digits.reverse()
```

**執行邏輯：**
1. 使用 `% 10` 取得個位數
2. 使用 `// 10` 去掉個位數
3. 重複直到 `num` 變成 0
4. 反轉列表得到正確順序

**為什麼要 reverse()？**
因為我們是從個位數開始取得，需要反轉成正確順序。

## 檢查遞增

**為什麼用迴圈檢查？**
因為我們要比較每一對相鄰的位數。

**語法：**
```
is_increasing = True
for i in range(len(digits) - 1):
    if digits[i] >= digits[i+1]:
        is_increasing = False
        break
```

**執行邏輯：**
1. 假設是遞增數（`is_increasing = True`）
2. 遍歷每一對相鄰位數（`i` 和 `i+1`）
3. 如果發現 `digits[i] >= digits[i+1]` → 不是遞增數，設為 `False`，跳出
4. 如果所有相鄰位數都符合 → 是遞增數

**為什麼 `range(len(digits) - 1)`？**
因為我們要比較 `i` 和 `i+1`，最後一個索引是 `len(digits) - 1`，所以 `i` 最大是 `len(digits) - 2`。

**為什麼用 >=？**
因為「遞增」表示「嚴格遞增」，前一位必須**小於**後一位，如果 `>=` 就不是遞增。

## 實際範例

### 檢查 1234

```
num = 1234
digits = []
while num > 0:
    digits.append(num % 10)
    num = num // 10
digits.reverse()  # [1, 2, 3, 4]

is_increasing = True
for i in range(len(digits) - 1):  # range(3) → i = 0, 1, 2
    if digits[i] >= digits[i+1]:
        is_increasing = False
        break

if is_increasing:
    print("是遞增數")
else:
    print("不是遞增數")
```

**執行過程：**
1. 取得位數：`digits = [1, 2, 3, 4]`
2. 檢查：
   - `i = 0`：`digits[0] = 1`, `digits[1] = 2` → `1 < 2` ✓
   - `i = 1`：`digits[1] = 2`, `digits[2] = 3` → `2 < 3` ✓
   - `i = 2`：`digits[2] = 3`, `digits[3] = 4` → `3 < 4` ✓
3. 所有檢查都通過 → `is_increasing = True`
4. 印出：`是遞增數`

### 檢查 1231

```
digits = [1, 2, 3, 1]
is_increasing = True
for i in range(3):
    if digits[i] >= digits[i+1]:
        is_increasing = False
        break
```

**執行過程：**
1. `i = 0`：`1 < 2` ✓
2. `i = 1`：`2 < 3` ✓
3. `i = 2`：`3 >= 1` → `True`，設 `is_increasing = False`，`break`
4. 印出：`不是遞增數`

**記住：** 
- 先取得所有位數
- 使用迴圈比較相鄰位數
- 使用 `>=` 判斷是否違反遞增規則
- 一旦發現違反就跳出（`break`）
- 所有位數都符合才是遞增數

## 使用 input() 接收數字

使用 `input()` 可以讓程式更實用，可以判斷任意數字是否為遞增數：

```
num = int(input())
```

這樣使用者可以輸入任何數字，程式都能判斷是否為遞增數。
""",
        "exercise": "請寫一個程式，使用 `int(input())` 接收一個數字，然後判斷它是否為遞增數（每一位都比前一位大）。如果是，印出「是遞增數」，否則印出「不是遞增數」。\n\n**提示：** 當程式執行時，您可以在輸入框中輸入一個數字（例如：1234）來測試程式。",
        "hint": "使用 `int(input())` 接收輸入，將數字分解成各位數，然後檢查是否每一位都比前一位大。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "是遞增數\n",
            "test_inputs": ["1234"]
        }
    },
    
    # ========== 第四章：列表 (List) ==========
    {
        "id": "EX5-1",
        "title": "List-新增元素",
        "explanation": """
## 為什麼需要列表？

到目前為止，我們學的變數一次只能存一個值。但如果我們要儲存很多個值呢？

**沒有列表的問題：**
```
score1 = 85
score2 = 90
score3 = 75
score4 = 88
```
要處理 100 個成績就要建立 100 個變數，太麻煩了！

**使用列表：**
```
scores = [85, 90, 75, 88]
```
一個變數就能存很多個值！

## 什麼是列表？

**列表（List）** 是 Python 中最重要的資料結構之一，可以儲存**多個元素**，就像一個可以放很多東西的容器。

**生活中的類比：**
- 變數 = 一個盒子，只能放一個東西
- 列表 = 一個大盒子，裡面可以放很多個小盒子

## 為什麼用方括號 `[]`？

**方括號的作用：**
- `[]` 告訴 Python：「這是一個列表」
- 列表中的元素用**逗號 `,`** 分隔

**為什麼用逗號分隔？**
逗號讓 Python 知道「這是不同的元素」，就像您寫購物清單時，每個項目之間用逗號分開一樣。

## 建立列表

### 空列表
```
my_list = []
```
**為什麼需要空列表？**
有時候我們一開始不知道要放什麼，可以先建立空列表，之後再慢慢加入元素。

### 有初始值的列表
```
my_list = [1, 2, 3]
```
**語法說明：**
- `[` → 列表開始
- `1, 2, 3` → 三個元素，用逗號分隔
- `]` → 列表結束

## 新增元素：append() 方法

**什麼是方法（Method）？**
方法是「屬於某個物件的函式」。`append()` 是列表的專屬方法。

**語法：**
```
列表名稱.append(要新增的元素)
```

**為什麼用點號 `.`？**
點號 `.` 表示「屬於」或「的」。`my_list.append(4)` 意思是「my_list 的 append 方法」。

**為什麼叫 append？**
`append` 是「附加」的意思，表示在列表的**末尾**新增元素。

## 實際範例

```
my_list = [1, 2, 3]
my_list.append(4)
print(my_list)
```

**執行過程：**
1. 建立列表 `[1, 2, 3]`
2. 使用 `append(4)` 在末尾新增 4
3. 列表變成 `[1, 2, 3, 4]`
4. 印出列表

**結果：** `[1, 2, 3, 4]`

**為什麼 append 後列表會改變？**
因為列表是「可變的」（mutable），可以直接修改內容。這跟數字、字串不同（它們是不可變的）。

## 常見問題

**Q: 為什麼 append 後面有括號？**
A: 因為 `append` 是一個方法（函式），需要括號來呼叫它，括號裡放要新增的元素。

**Q: 為什麼不能寫 `my_list = append(4)`？**
A: 因為 `append` 是列表的方法，必須用 `列表名稱.append()` 的方式呼叫，不能單獨使用。
""",
        "exercise": "請建立一個空列表 `numbers = []`，然後依序新增數字 10、20、30，最後印出列表。",
        "hint": "使用 `append()` 方法來新增元素。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "[10, 20, 30]\n"
        }
    },
    {
        "id": "EX5-2",
        "title": "List-設定初值，新增元素",
        "explanation": """
## 為什麼需要設定初值？

我們可以在建立列表時就設定初始值，然後再新增元素。

**為什麼不直接用空列表？**
有時候我們已經知道一些初始資料，可以先設定，之後再動態新增。

**兩種方式：**
1. 空列表 + 逐步新增
2. 有初值的列表 + 繼續新增

## 建立有初值的列表

**語法：**
```
列表名稱 = [元素1, 元素2, ...]
```

**為什麼用方括號？**
方括號 `[]` 告訴 Python 這是一個列表。

**為什麼用逗號分隔？**
逗號讓 Python 知道這是不同的元素。

## 新增元素：append() 方法

**語法：**
```
列表名稱.append(要新增的元素)
```

**為什麼叫 append？**
`append` 是「附加」的意思，表示在列表的**末尾**新增元素。

**為什麼在末尾？**
因為這樣可以保持元素的順序，新元素總是加在最後。

## 實際範例

```
fruits = ["apple", "banana"]
fruits.append("orange")
print(fruits)  # 會印出 ['apple', 'banana', 'orange']
```

**執行過程：**
1. 建立列表 `["apple", "banana"]`
2. 使用 `append("orange")` 在末尾新增元素
3. 列表變成 `['apple', 'banana', 'orange']`
4. 印出列表

**結果：** `['apple', 'banana', 'orange']`

**記住：** 
- 可以在建立列表時設定初值
- `append()` 在列表末尾新增元素
- 列表可以動態增長
""",
        "exercise": "請建立一個列表 colors = ['red', 'blue']，然後新增 'green'，最後印出列表。",
        "hint": "使用 `append()` 方法。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "['red', 'blue', 'green']\n"
        }
    },
    {
        "id": "EX5-3",
        "title": "List-不同資料型態",
        "explanation": """
## Python 列表的靈活性

Python 的列表可以儲存**不同類型的資料**，包括數字、字串、甚至其他列表。

**為什麼可以混合不同類型？**
這是 Python 列表的優勢，讓它非常靈活，可以儲存各種資料。

**其他語言的限制：**
- 有些語言（如 C、Java）的陣列只能儲存同一類型的資料
- Python 的列表沒有這個限制

## 可以儲存的資料類型

**基本類型：**
- 整數（int）：`1, 2, 3`
- 浮點數（float）：`3.14, 2.5`
- 字串（str）：`"hello", 'world'`
- 布林值（bool）：`True, False`

**複合類型：**
- 列表：`[1, 2, 3]`
- 字典：`{"key": "value"}`
- 元組：`(1, 2, 3)`

## 實際範例

```
mixed = [1, "hello", 3.14, True]
print(mixed)
```

**執行過程：**
1. 建立列表，包含：
   - 整數：`1`
   - 字串：`"hello"`
   - 浮點數：`3.14`
   - 布林值：`True`
2. 印出列表

**結果：** `[1, 'hello', 3.14, True]`

**注意：** 雖然可以混合類型，但通常建議在同一個列表中儲存相同類型的資料，這樣更容易處理。

## 嵌套列表

**列表中可以包含其他列表：**
```
nested = [[1, 2], [3, 4], [5, 6]]
```

這就是「二維陣列」或「列表的列表」。

**記住：** 
- Python 列表可以儲存不同類型的資料
- 列表可以包含其他列表（嵌套）
- 雖然靈活，但建議保持一致性
""",
        "exercise": "請建立一個列表 data = [10, 'python', 3.14]，然後印出列表。",
        "hint": "直接建立包含不同類型的列表。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "[10, 'python', 3.14]\n"
        }
    },
    {
        "id": "EX5-4",
        "title": "List-Indexing",
        "explanation": """
## 什麼是索引？

我們可以使用**索引（index）**來存取列表中的元素。

**為什麼需要索引？**
就像書的頁碼一樣，索引讓我們可以「直接跳到某個位置」來存取元素，而不需要從頭開始找。

## 為什麼索引從 0 開始？

**重要概念：** 列表的索引從 **0** 開始，不是從 1 開始！

**為什麼？**
這是程式設計的慣例，因為：
1. 計算機科學中，0 是第一個數字
2. 讓索引和「距離第一個元素的距離」一致
3. 讓某些計算更簡單

**類比：**
- 列表 = 一排房子
- 索引 = 門牌號碼
- 第一間房子的門牌是 0 號，不是 1 號

## 正索引和負索引

### 正索引（從前面開始）

```
fruits = ["apple", "banana", "orange"]
索引：      0         1         2
```

- `fruits[0]` → 第一個元素 "apple"
- `fruits[1]` → 第二個元素 "banana"
- `fruits[2]` → 第三個元素 "orange"

**為什麼第一個是 0？**
因為 0 表示「距離第一個元素的距離是 0」，也就是第一個元素本身。

### 負索引（從後面開始）

**為什麼需要負索引？**
有時候我們想從後面開始數，例如「最後一個」、「倒數第二個」。

- `fruits[-1]` → 最後一個元素 "orange"
- `fruits[-2]` → 倒數第二個元素 "banana"
- `fruits[-3]` → 倒數第三個元素 "apple"

**為什麼負索引從 -1 開始？**
因為 -1 表示「距離最後一個元素的距離是 0」，也就是最後一個元素本身。

## 修改元素

**列表是可變的！**
我們可以直接修改列表中的元素。

**語法：**
```
列表名稱[索引] = 新值
```

**為什麼可以修改？**
因為列表是「可變的」（mutable），可以直接改變內容。這跟字串不同（字串是不可變的）。

## 實際範例

```
fruits = ["apple", "banana", "orange"]
print(fruits[0])    # 印出 "apple"（第一個元素）
print(fruits[1])    # 印出 "banana"（第二個元素）
print(fruits[-1])   # 印出 "orange"（最後一個元素）

fruits[1] = "grape"  # 將第二個元素改為 "grape"
print(fruits)        # 印出 ["apple", "grape", "orange"]
```

**執行過程：**
1. 建立列表 `["apple", "banana", "orange"]`
2. 印出索引 0 的元素：`"apple"`
3. 印出索引 1 的元素：`"banana"`
4. 印出索引 -1 的元素：`"orange"`
5. 修改索引 1 的元素為 `"grape"`
6. 列表變成 `["apple", "grape", "orange"]`

## 常見錯誤

❌ **索引超出範圍：**
```
fruits = ["apple", "banana"]
print(fruits[2])  # 錯誤！只有索引 0 和 1
```

✅ **正確：**
```
fruits = ["apple", "banana"]
print(fruits[0])  # 第一個
print(fruits[1])  # 第二個
print(fruits[-1]) # 最後一個
```

**記住：** 
- 索引從 0 開始
- 正索引從前面數，負索引從後面數
- 索引不能超出範圍（0 到 len-1 或 -1 到 -len）
""",
        "exercise": "有一個列表 items = ['a', 'b', 'c', 'd']。請印出第一個元素和最後一個元素（分兩行）。",
        "hint": "使用索引 0 和 -1。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "a\nd\n"
        }
    },
    {
        "id": "EX5-5",
        "title": "List-配合For-Else & count()",
        "explanation": """
## for-else 的特殊語法

`for-else` 是 Python 的特殊語法，很多人不知道這個功能！

**基本語法：**
```
for 變數 in 範圍:
    # 迴圈內容
    if 某個條件:
        break
else:
    # else 區塊
```

**執行規則：**
- 如果迴圈**正常結束**（沒有 break）→ 會執行 `else` 區塊
- 如果迴圈被 `break` 中斷 → **不會**執行 `else` 區塊

**為什麼需要 for-else？**
有時候我們想要知道「迴圈是否正常完成」，例如「是否找到了目標」。

**生活中的類比：**
- 正常結束 = 找遍了所有地方都沒找到 → 執行 else（例如「沒找到」）
- break = 找到了就停止 → 不執行 else

**注意：** 這跟 `if-else` 的 `else` 不同！`for-else` 的 `else` 是「迴圈正常結束時執行」。

## count() 方法

**作用：** 計算列表中某個元素出現的次數

**語法：**
```
列表名稱.count(要計算的元素)
```

**為什麼需要 count()？**
有時候我們需要統計某個元素在列表中出現幾次，例如「有多少人得到滿分」。

**執行方式：**
Python 會遍歷整個列表，計算指定元素出現的次數。

## 實際範例

```
numbers = [1, 2, 3, 2, 4, 2]
count = numbers.count(2)
print(count)  # 會印出 3
```

**執行過程：**
1. Python 遍歷列表 `[1, 2, 3, 2, 4, 2]`
2. 計算數字 2 出現的次數：
   - 索引 1：2 ✓
   - 索引 3：2 ✓
   - 索引 5：2 ✓
3. 總共出現 3 次
4. 印出 3

**記住：** 
- `for-else` 的 `else` 只在迴圈正常結束時執行
- `count()` 會計算整個列表中指定元素的出現次數
""",
        "exercise": "有一個列表 `numbers = [1, 2, 3, 2, 4, 2, 5]`。請計算數字 2 出現的次數並印出。",
        "hint": "使用 `count()` 方法。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "3\n"
        }
    },
    {
        "id": "EX5-6",
        "title": "List-複製(Deep Copy)",
        "explanation": """
## 為什麼需要深複製？

在 Python 中，列表的賦值只是建立一個新的參考，而不是複製內容。深複製可以建立一個完全獨立的新列表。

**實際應用：**
- 避免意外修改原列表
- 建立獨立的副本
- 資料保護

**為什麼不用賦值？**
因為賦值只是建立參考，修改新列表會影響原列表。

## 淺複製 vs 深複製

### 淺複製（Shallow Copy）

**什麼是淺複製？**
只複製第一層，如果列表中有嵌套列表，嵌套列表仍然是參考。

**語法：**
```
new_list = original[:]  # 或 list(original)
```

**問題：**
如果列表中有嵌套列表，修改嵌套列表會影響原列表。

### 深複製（Deep Copy）

**什麼是深複製？**
完全複製所有層級，建立完全獨立的新列表。

**語法：**
```
import copy
new_list = copy.deepcopy(original)
```

**為什麼叫 deep？**
因為它會「深入」所有層級，複製所有嵌套的物件。

## copy 模組

**為什麼需要 import？**
`copy` 是 Python 的模組，需要先匯入才能使用。

**語法：**
```
import copy
```

**為什麼叫 copy？**
`copy` 是「複製」的意思，這個模組提供複製功能。

## deepcopy() 函式

**什麼是 deepcopy()？**
`deepcopy()` 是 `copy` 模組的函式，用來建立深複製。

**語法：**
```
copy.deepcopy(要複製的物件)
```

**為什麼叫 deepcopy？**
因為它會「深入」所有層級進行複製。

## 實際範例

### 簡單列表（一層）

```
import copy
original = [1, 2, 3]
new_list = copy.deepcopy(original)
new_list[0] = 99
print(original)  # [1, 2, 3]
print(new_list)  # [99, 2, 3]
```

**結果：**
```
[1, 2, 3]
[99, 2, 3]
```

### 嵌套列表（多層）

```
import copy
original = [1, 2, [3, 4]]
new_list = copy.deepcopy(original)
new_list[2][0] = 99
print(original)  # [1, 2, [3, 4]]
print(new_list)  # [1, 2, [99, 4]]
```

**執行過程：**
1. `original = [1, 2, [3, 4]]`
2. `new_list = copy.deepcopy(original)` → 建立完全獨立的副本
3. `new_list[2][0] = 99` → 只修改新列表
4. `original` 不變：`[1, 2, [3, 4]]`
5. `new_list` 改變：`[1, 2, [99, 4]]`

**如果使用淺複製：**
```
original = [1, 2, [3, 4]]
new_list = original[:]  # 淺複製
new_list[2][0] = 99
print(original)  # [1, 2, [99, 4]]（也被修改了！）
```

**記住：** 
- 賦值只是建立參考
- 淺複製只複製第一層
- 深複製複製所有層級
- 使用 `copy.deepcopy()` 建立深複製
- 深複製建立完全獨立的副本
""",
        "exercise": "有一個列表 `original = [1, 2, 3]`。請使用深複製建立一個新列表 `new_list`，然後修改 `new_list[0] = 99`，最後分別印出兩個列表（先 original，後 new_list）。",
        "hint": "使用 `copy.deepcopy()` 或 `list()` 函式。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "[1, 2, 3]\n[99, 2, 3]\n"
        }
    },
    {
        "id": "EX5-7",
        "title": "List-複製(Shallow Copy)",
        "explanation": """
## 淺複製 vs 深複製

**淺複製（Shallow Copy）** 只複製**第一層**，如果列表中有嵌套列表，嵌套的部分仍然共享參考。

**為什麼叫「淺」？**
因為它只複製「表面」一層，不會深入嵌套結構。

## 淺複製的方法

### 方法 1：使用切片 `[:]`

```
original = [1, 2, 3]
new_list = original[:]
```

**為什麼 `[:]` 可以複製？**
切片 `[:]` 表示「從頭到尾」，會建立一個新的列表。

### 方法 2：使用 list() 函式

```
new_list = list(original)
```

**為什麼 list() 可以複製？**
`list()` 函式會將輸入轉換為新列表。

### 方法 3：使用 copy() 方法

```
new_list = original.copy()
```

**為什麼列表有 copy() 方法？**
這是列表的內建方法，專門用來複製列表。

## 淺複製的限制

**對於簡單列表（沒有嵌套）：**
淺複製和深複製效果相同，都可以建立獨立複本。

**對於嵌套列表：**
淺複製只複製第一層，嵌套列表仍然共享參考。

**問題範例：**
```
original = [1, 2, [3, 4]]
new_list = original[:]  # 淺複製
new_list[2][0] = 99
print(original)  # [1, 2, [99, 4]] ← 原列表也被改變了！
```

**為什麼會這樣？**
因為淺複製只複製了外層列表，內層的 `[3, 4]` 仍然是共享的。

## 實際範例

```
original = [10, 20, 30]
new_list = original[:]  # 使用切片複製
new_list[0] = 99
print(original)  # [10, 20, 30]（原列表不變）
print(new_list)  # [99, 20, 30]（新列表改變）
```

**執行過程：**
1. 建立原始列表 `[10, 20, 30]`
2. 使用切片 `[:]` 建立新列表
3. 修改新列表的第一個元素
4. 原列表保持不變（因為是簡單列表，淺複製就夠了）

**記住：** 
- 淺複製適合簡單列表（沒有嵌套）
- 有嵌套列表時，需要深複製才能完全獨立
- 三種方法效果相同：`[:]`、`list()`、`copy()`
""",
        "exercise": "有一個列表 `original = [10, 20, 30]`。請使用切片 `[:]` 建立一個新列表 `new_list`，然後修改 `new_list[0] = 99`，最後分別印出兩個列表（先 original，後 new_list）。",
        "hint": "使用 `new_list = original[:]` 來複製。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "[10, 20, 30]\n[99, 20, 30]\n"
        }
    },
    {
        "id": "PT5-1",
        "title": "成績統計：輸入多筆成績(-1 for exit)",
        "explanation": """
## 為什麼需要終止條件？

我們可以使用迴圈來持續輸入資料，但需要一個「終止條件」來停止迴圈。

**為什麼用 -1 作為終止條件？**
因為 -1 是「不可能的分數」（成績不會是負數），所以可以用來表示「結束輸入」。

**其他常見的終止值：**
- `-1`（表示結束）
- `0`（如果 0 不是有效值）
- 空字串 `""`（如果允許空輸入）

## while True 配合 break

**為什麼用 `while True`？**
因為我們不知道要輸入幾筆資料，只知道「輸入 -1 就停止」。

**模式：**
```
while True:
    # 輸入資料
    if 終止條件:
        break  # 跳出迴圈
    # 處理資料
```

**為什麼需要 break？**
因為 `while True` 是無限迴圈，必須用 `break` 來停止。

## 實際範例

```
scores = []
while True:
    score = int(input("請輸入成績（-1 結束）："))
    if score == -1:
        break
    scores.append(score)
print("共", len(scores), "筆成績")
print("平均：", sum(scores) / len(scores))
```

**執行過程：**
1. 建立空列表 `scores = []`
2. 進入無限迴圈
3. 輸入成績（例如 85）
4. 檢查：85 != -1，繼續
5. 將 85 加入列表
6. 繼續迴圈...
7. 輸入 -1
8. 檢查：-1 == -1，執行 `break`，跳出迴圈
9. 計算並印出統計

## 過濾終止值

**為什麼需要過濾？**
因為終止值（-1）不應該參與計算。

**方法：**
- 在加入列表前檢查，如果是終止值就不加入
- 或者在計算前過濾掉終止值

**記住：** 
- `while True` 需要配合 `break` 使用
- 終止值不應該參與計算
- 記得過濾掉終止值
""",
        "exercise": "請建立一個列表 `scores = [85, 90, 75, 88, -1]`，然後計算除了 -1 之外的所有成績的平均，並印出「平均：」和平均分數。",
        "hint": "過濾掉 -1，然後計算平均。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "平均： 84.5\n"
        }
    },
    {
        "id": "PT5-2",
        "title": "輸入日期，印出該月英文縮寫及天數",
        "explanation": """
## 為什麼用列表儲存月份資訊？

我們可以使用列表來儲存月份資訊，這樣可以方便地根據月份編號來查詢。

**為什麼需要兩個列表？**
因為我們需要儲存兩種資訊：
- 月份的英文縮寫
- 每個月的天數

**為什麼不用字典？**
列表適合「有序的、用數字索引」的資料，月份正好符合這個特性。

## 索引的轉換

**重要：** 列表索引從 0 開始，但月份編號從 1 開始！

**轉換公式：**
- 列表索引 = 月份編號 - 1
- 例如：3 月 → 索引 2（第 3 個元素）

**為什麼要減 1？**
因為：
- 1 月是第 1 個，但列表索引是 0
- 2 月是第 2 個，但列表索引是 1
- 3 月是第 3 個，但列表索引是 2
- ...

## 實際範例

```
months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

month = 3  # 3月
print(months[month - 1])  # 印出 "Mar"
print(days[month - 1])    # 印出 31
```

**執行過程：**
1. `month = 3`（3 月）
2. `month - 1 = 2`（轉換為索引）
3. `months[2]` → "Mar"（第 3 個元素）
4. `days[2]` → 31（第 3 個元素）

**記住：** 使用列表索引時，記得將月份編號減 1！
""",
        "exercise": "有一個月份列表 months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n和天數列表 days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]。\n如果 month = 5，請印出該月的英文縮寫和天數（分兩行）。",
        "hint": "注意索引從 0 開始，所以月份要減 1。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "May\n31\n"
        }
    },
    {
        "id": "PT5-3",
        "title": "輸入日期，印出今年剩幾天",
        "explanation": """
## 為什麼需要計算剩餘天數？

我們可以計算從某個日期到年底還剩多少天。

**實際應用：**
- 計算距離年底還有幾天
- 計算專案剩餘時間
- 計算優惠期限

## 計算策略

**思路：**
1. 計算當月剩餘天數
2. 計算後續完整月份的天數
3. 兩者相加

## 計算當月剩餘天數

**公式：**
```
當月剩餘天數 = 當月總天數 - 當前日期 + 1
```

**為什麼要 +1？**
因為要包含今天，例如 10 月 15 日，15 日這天也要算進去。

**為什麼用 `month - 1`？**
因為列表索引從 0 開始，但月份從 1 開始。

**範例：**
```
month = 10  # 10月
day = 15    # 15日
days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

remaining_in_month = days_in_month[month - 1] - day + 1
# days_in_month[9] = 31（10月的天數）
# 31 - 15 + 1 = 17（10月還剩17天，包含15日）
```

## 計算後續月份的天數

**為什麼用切片？**
`days_in_month[month:]` 表示從第 month 個月開始到最後的所有月份。

**範例：**
```
month = 10
days_in_month[10:]  # 從索引 10 開始（11月、12月）
# [31, 30]  # 11月31天，12月30天（簡化版，實際12月是31天）
```

**使用 sum() 計算總和：**
```
remaining_months = sum(days_in_month[month:])
```

## 簡化計算

**注意：** 原公式中有重複計算，可以簡化為：
```
total = (days_in_month[month - 1] - day + 1) + sum(days_in_month[month:])
```

**執行過程（10月15日）：**
1. 當月剩餘：`31 - 15 + 1 = 17`（10月剩17天）
2. 後續月份：`sum([31, 30]) = 61`（11月+12月）
3. 總計：`17 + 61 = 78` 天

**記住：** 
- 當月剩餘 = 當月總天數 - 當前日期 + 1
- 後續月份用切片 `[month:]`
- 記得索引轉換（month - 1）
""",
        "exercise": "假設今天是 10 月 15 日（`month = 10`, `day = 15`）。\n月份天數列表：`days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]`。\n請計算到年底（12月31日）還剩多少天並印出。",
        "hint": "計算當月剩餘天數 + 後續月份天數。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "78\n"
        }
    },
    {
        "id": "HW5-1",
        "title": "成績計算",
        "explanation": """
## 為什麼需要統計功能？

我們可以使用列表來儲存多筆成績，然後進行各種統計計算。

**實際應用：**
- 計算總分和平均
- 找出最高分和最低分
- 分析成績分布

## Python 的內建統計函式

Python 提供了許多內建函式來處理列表，讓我們不需要自己寫迴圈。

### sum() - 計算總和

**作用：** 計算列表中所有數字的總和

**語法：**
```
sum(列表)
```

**為什麼需要 sum()？**
雖然可以用迴圈累加，但 `sum()` 更簡潔、更快速。

### len() - 計算長度

**作用：** 計算列表中有多少個元素

**語法：**
```
len(列表)
```

**為什麼需要 len()？**
計算平均時需要知道「有幾個數字」。

### max() - 找出最大值

**作用：** 找出列表中的最大值

**語法：**
```
max(列表)
```

### min() - 找出最小值

**作用：** 找出列表中的最小值

**語法：**
```
min(列表)
```

## 計算平均

**公式：** 平均 = 總分 ÷ 人數

**為什麼要分兩步？**
1. 先計算總分：`total = sum(scores)`
2. 再計算平均：`average = total / len(scores)`

**為什麼不直接寫 `sum(scores) / len(scores)`？**
可以！但分開寫更清楚，也方便除錯。

## 實際範例

```
scores = [85, 90, 75, 88, 92]
total = sum(scores)           # 總分
average = total / len(scores) # 平均
max_score = max(scores)       # 最高分
min_score = min(scores)       # 最低分

print("總分：", total)
print("平均：", average)
print("最高分：", max_score)
print("最低分：", min_score)
```

**執行過程：**
1. `sum(scores)` → 85 + 90 + 75 + 88 + 92 = 430
2. `len(scores)` → 5（有 5 個成績）
3. `average = 430 / 5 = 86.0`
4. `max(scores)` → 92（最大值）
5. `min(scores)` → 75（最小值）

**結果：**
```
總分： 430
平均： 86.0
最高分： 92
最低分： 75
```

**記住：** 
- `sum()` 計算總和
- `len()` 計算長度
- `max()` 找出最大值
- `min()` 找出最小值
- 平均 = 總分 ÷ 人數
""",
        "exercise": "有一個成績列表 `scores = [85, 90, 75, 88, 92]`。請計算並印出總分、平均分、最高分和最低分（分四行，格式：總分：xxx、平均：xxx、最高分：xxx、最低分：xxx）。",
        "hint": "使用 `sum()`, `len()`, `max()`, `min()` 函式。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "總分： 430\n平均： 86.0\n最高分： 92\n最低分： 75\n"
        }
    },
    {
        "id": "HW5-2",
        "title": "輸入兩日期，印出相距幾天",
        "explanation": """
## 為什麼需要計算日期差？

計算兩個日期之間的天數是常見的需求，例如計算工作天數、活動持續時間等。

**實際應用：**
- 計算工作天數
- 活動持續時間
- 日期間隔計算

**為什麼要簡化為同一年？**
跨年計算較複雜，先學會同一年內的計算，再擴展到跨年。

## 策略：計算從年初到日期的天數

**為什麼用這個策略？**
因為如果我們知道「從年初到第一個日期的天數」和「從年初到第二個日期的天數」，相減就是兩個日期之間的天數。

**步驟：**
1. 計算從年初到第一個日期的天數
2. 計算從年初到第二個日期的天數
3. 相減取絕對值

## 月份天數列表

**為什麼需要這個列表？**
因為每個月的天數不同，需要知道每個月有幾天。

**語法：**
```
days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
```

**對應關係：**
- 索引 0：1月（31天）
- 索引 1：2月（28天）
- 索引 2：3月（31天）
- ...
- 索引 11：12月（31天）

## 計算從年初到日期的天數

**為什麼用切片 `[:month1-1]`？**
因為我們要計算「從1月到（month1-1）月」的總天數。

**語法：**
```
days1 = sum(days_in_month[:month1-1]) + day1
```

**執行邏輯：**
1. `days_in_month[:month1-1]` → 取得從1月到（month1-1）月的天數列表
2. `sum(...)` → 計算這些月份的總天數
3. `+ day1` → 加上當月的天數

**範例：** 3月15日
- `month1 = 3`，`day1 = 15`
- `days_in_month[:3-1]` = `days_in_month[:2]` = `[31, 28]`（1月和2月）
- `sum([31, 28]) = 59`（1月和2月的總天數）
- `59 + 15 = 74`（從年初到3月15日的天數）

## 計算兩個日期的差

**為什麼用 abs()？**
`abs()` 是絕對值函式，確保結果是正數（不管哪個日期在前）。

**語法：**
```
abs(days2 - days1)
```

**為什麼需要絕對值？**
因為如果第二個日期在第一個日期之前，差值是負數，但我們要的是「相差幾天」（正數）。

## 實際範例

```
month1 = 3
day1 = 15
month2 = 5
day2 = 20

days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

# 計算從年初到第一個日期的天數
days1 = sum(days[:month1-1]) + day1
# days[:2] = [31, 28]
# sum([31, 28]) = 59
# days1 = 59 + 15 = 74

# 計算從年初到第二個日期的天數
days2 = sum(days[:month2-1]) + day2
# days[:4] = [31, 28, 31, 30]
# sum([31, 28, 31, 30]) = 120
# days2 = 120 + 20 = 140

# 計算差值
result = abs(days2 - days1)
# abs(140 - 74) = 66
print(result)
```

**執行過程：**
1. 第一個日期（3月15日）：
   - `days[:2] = [31, 28]`
   - `sum([31, 28]) = 59`
   - `days1 = 59 + 15 = 74`
2. 第二個日期（5月20日）：
   - `days[:4] = [31, 28, 31, 30]`
   - `sum([31, 28, 31, 30]) = 120`
   - `days2 = 120 + 20 = 140`
3. 差值：`abs(140 - 74) = 66`

**結果：** `66`

**記住：** 
- 用列表儲存每個月的天數
- 計算從年初到每個日期的天數
- 相減取絕對值得到日期差
- 使用切片 `[:month-1]` 取得前面的月份
""",
        "exercise": "假設 `month1 = 3, day1 = 15` 和 `month2 = 5, day2 = 20`（同一年）。\n月份天數：`days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]`。\n請計算兩個日期之間相差多少天並印出。",
        "hint": "計算從年初到每個日期的天數，然後相減取絕對值。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "66\n"
        }
    },
    {
        "id": "HW5-3",
        "title": "連續擲骰子直到所有數字都出現",
        "explanation": """
## 為什麼用集合追蹤？

我們可以使用集合（set）來追蹤已經出現過的數字，因為集合會自動去重，而且可以快速檢查元素是否存在。

**實際應用：**
- 收集遊戲
- 追蹤完成項目
- 確保所有選項都出現過

**為什麼不用列表？**
- 列表需要手動檢查是否重複
- 集合自動去重，而且 `in` 檢查更快

## 使用集合追蹤

**為什麼用空集合？**
因為我們要從零開始追蹤，空集合表示「還沒有任何數字出現過」。

**語法：**
```
seen = set()
```

**為什麼叫 seen？**
`seen` 是「已見過」的意思，表示已經出現過的數字。

## 迴圈條件

**為什麼用 `len(seen) < 6`？**
因為骰子有 6 個數字（1-6），當集合大小等於 6 時，表示所有數字都出現過了。

**語法：**
```
while len(seen) < 6:
    # 擲骰子
    # 加入集合
```

**為什麼用 while？**
因為我們不知道要擲幾次，只知道「所有數字都出現過就停止」。

## 擲骰子和追蹤

**為什麼每次都要 add()？**
因為我們要追蹤「這個數字已經出現過」，即使重複出現也沒關係（集合會自動去重）。

**語法：**
```
dice = random.randint(1, 6)
seen.add(dice)
```

**為什麼用 add()？**
`add()` 是集合的方法，用來新增元素。如果元素已存在，不會出錯，也不會重複新增。

## 計數器

**為什麼需要計數器？**
因為我們想知道「總共擲了幾次」。

**語法：**
```
count = 0
while len(seen) < 6:
    count = count + 1
    # ...
```

**為什麼在迴圈內加 1？**
因為每次擲骰子，次數就加 1。

## 實際範例

```
import random
seen = set()
count = 0

while len(seen) < 6:
    dice = random.randint(1, 6)
    count = count + 1
    seen.add(dice)
    print(dice)

print("完成")
```

**執行過程（範例）：**
1. 第一次：`dice = 3`，`seen = {3}`，`count = 1`，印出 3
2. 第二次：`dice = 1`，`seen = {3, 1}`，`count = 2`，印出 1
3. 第三次：`dice = 3`（重複），`seen = {3, 1}`（不變），`count = 3`，印出 3
4. 第四次：`dice = 5`，`seen = {3, 1, 5}`，`count = 4`，印出 5
5. 第五次：`dice = 2`，`seen = {3, 1, 5, 2}`，`count = 5`，印出 2
6. 第六次：`dice = 4`，`seen = {3, 1, 5, 2, 4}`，`count = 6`，印出 4
7. 第七次：`dice = 6`，`seen = {3, 1, 5, 2, 4, 6}`，`count = 7`，印出 6
8. 檢查：`len(seen) = 6`，條件 `6 < 6` → `False`，跳出迴圈
9. 印出：`完成`

**結果（範例）：**
```
3
1
3
5
2
4
6
完成
```

**注意：** 每次執行的結果可能不同，因為是隨機的！

**記住：** 
- 用集合追蹤已出現的數字
- 使用 `len(seen) < 6` 作為迴圈條件
- 使用 `add()` 新增數字到集合
- 集合自動去重，不需要手動檢查
""",
        "exercise": "請寫一個程式，使用集合來追蹤已出現的骰子數字（1-6），每次擲骰子並印出結果，直到所有 6 個數字都出現過為止。然後印出「完成」。\n（提示：可以使用列表 `results = [1, 2, 3, 4, 5, 6]` 來模擬）",
        "hint": "使用集合來追蹤已出現的數字，當集合大小等於 6 時停止。",
        "validator": {
            "type": "stdout_contains",
            "expected_output": "完成"
        }
    },
    
    # ========== 第五章：二維陣列 ==========
    {
        "id": "EX6-1",
        "title": "二維陣列 及 For loop",
        "explanation": """
## 什麼是二維陣列？

二維陣列就是「列表的列表」，可以用來表示表格或矩陣。

**為什麼需要二維陣列？**
一維列表只能儲存「一行」資料，但很多資料是「表格」形式的，例如：
- 成績表（多個學生 × 多個科目）
- 棋盤（多行 × 多列）
- 圖片（多行 × 多列的像素）

**生活中的類比：**
- 一維列表 = 一排房子（只有一條街）
- 二維陣列 = 一個社區（有多條街，每條街有多間房子）

## 建立二維陣列

**語法：**
```
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
```

**結構說明：**
- 外層列表有 3 個元素（3 行）
- 每個元素本身也是一個列表（每行有 3 個元素，3 列）
- 整體是 3×3 的矩陣

**視覺化：**
```
matrix = [
    [1, 2, 3],  # 第 0 行
    [4, 5, 6],  # 第 1 行
    [7, 8, 9]   # 第 2 行
]
```

## 存取元素

**為什麼需要兩個索引？**
因為二維陣列有「行」和「列」兩個維度。

**語法：**
```
matrix[行索引][列索引]
```

**範例：**
```
print(matrix[0][0])  # 印出 1（第 0 行第 0 列）
print(matrix[1][2])  # 印出 6（第 1 行第 2 列）
```

**索引說明：**
- `matrix[0]` → 取得第 0 行（是一個列表 `[1, 2, 3]`）
- `matrix[0][0]` → 取得第 0 行的第 0 列（是數字 `1`）

## 使用巢狀迴圈遍歷

**為什麼需要巢狀迴圈？**
因為需要遍歷「行」和「列」兩個維度。

**語法：**
```
for row in matrix:
    for element in row:
        print(element, end=" ")
    print()
```

**執行過程：**
1. 外層迴圈：遍歷每一行
   - 第一次：`row = [1, 2, 3]`
     - 內層迴圈：遍歷這一行的每個元素
       - 印出 1, 2, 3（不換行）
     - 換行
2. 外層迴圈：第二次
   - `row = [4, 5, 6]`
     - 印出 4, 5, 6，換行
3. ...依此類推

**結果：**
```
1 2 3 
4 5 6 
7 8 9 
```

**記住：** 
- 二維陣列 = 列表的列表
- 存取需要兩個索引：`[行][列]`
- 遍歷需要巢狀迴圈
""",
        "exercise": "有一個二維陣列 `matrix = [[1, 2], [3, 4]]`。請使用巢狀迴圈印出所有元素，每行印完後換行。",
        "hint": "使用兩個 for 迴圈，外層遍歷行，內層遍歷列。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "1 2 \n3 4 \n"
        }
    },
    {
        "id": "EX6-2",
        "title": "陣列元素更改 及 For loop",
        "explanation": """
## 為什麼需要修改二維陣列？

我們可以修改二維陣列中的元素，就像修改一維列表一樣。

**實際應用：**
- 更新遊戲棋盤
- 修改成績表
- 調整圖像像素

## 直接修改單個元素

**語法：**
```
二維陣列[行索引][列索引] = 新值
```

**為什麼需要兩個索引？**
因為二維陣列有「行」和「列」兩個維度。

**範例：**
```
matrix = [[1, 2, 3], [4, 5, 6]]
matrix[0][1] = 99  # 將第 0 行第 1 列改為 99
print(matrix)  # 會印出 [[1, 99, 3], [4, 5, 6]]
```

**執行過程：**
1. `matrix[0]` → 取得第 0 行 `[1, 2, 3]`
2. `matrix[0][1]` → 取得第 0 行的第 1 列元素 `2`
3. `matrix[0][1] = 99` → 將該元素改為 `99`
4. 列表變成 `[[1, 99, 3], [4, 5, 6]]`

## 使用迴圈批量修改

**為什麼需要迴圈？**
當我們要修改所有元素時，用迴圈比逐個修改更方便。

**語法：**
```
for i in range(len(matrix)):
    for j in range(len(matrix[i])):
        matrix[i][j] = 新值
```

**為什麼用 `len(matrix)`？**
`len(matrix)` 是行的數量，外層迴圈遍歷每一行。

**為什麼用 `len(matrix[i])`？**
`len(matrix[i])` 是第 i 行的列數，內層迴圈遍歷該行的每一列。

**範例：每個元素乘以 2**
```
for i in range(len(matrix)):
    for j in range(len(matrix[i])):
        matrix[i][j] = matrix[i][j] * 2
```

**執行過程：**
1. 外層迴圈：`i = 0`
   - 內層迴圈：`j = 0, 1, 2`
     - `matrix[0][0] = 1 * 2 = 2`
     - `matrix[0][1] = 2 * 2 = 4`
     - `matrix[0][2] = 3 * 2 = 6`
2. 外層迴圈：`i = 1`
   - 內層迴圈：`j = 0, 1, 2`
     - `matrix[1][0] = 4 * 2 = 8`
     - `matrix[1][1] = 5 * 2 = 10`
     - `matrix[1][2] = 6 * 2 = 12`
3. 結果：`[[2, 4, 6], [8, 10, 12]]`

**記住：** 
- 修改元素：`matrix[行][列] = 新值`
- 批量修改：使用巢狀迴圈
- 外層迴圈控制行，內層迴圈控制列
""",
        "exercise": "有一個二維陣列 `matrix = [[1, 2], [3, 4]]`。請將 `matrix[1][0]` 改為 99，然後印出整個陣列。",
        "hint": "直接使用索引賦值，然後用 print 印出。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "[[1, 2], [99, 4]]\n"
        }
    },
    {
        "id": "EX6-3",
        "title": "二維陣列初值設定",
        "explanation": """
## 為什麼需要建立二維陣列？

我們可以用不同的方式建立二維陣列，每種方法適用於不同的情況。

**為什麼需要多種方法？**
- 小陣列：可以直接指定
- 大陣列：需要用迴圈或列表生成式
- 動態大小：需要用迴圈

## 方法 1：直接指定

**適用情況：** 陣列很小，元素已知

**語法：**
```
matrix = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
```

**優點：** 簡單直觀
**缺點：** 如果陣列很大，寫起來很麻煩

**為什麼用嵌套列表？**
外層列表的每個元素都是一個列表（一行）。

## 方法 2：使用列表生成式

**適用情況：** 需要建立規則的陣列（例如全部是 0）

**語法：**
```
matrix = [[0 for j in range(3)] for i in range(3)]
```

**為什麼叫列表生成式？**
因為它「生成」一個列表，而不是逐個建立。

**執行邏輯：**
- 外層：`for i in range(3)` → 建立 3 行
- 內層：`for j in range(3)` → 每行建立 3 個 0

**為什麼用兩個迴圈？**
因為需要建立「行」和「列」兩個維度。

**優點：** 簡潔，適合規則陣列
**缺點：** 語法較複雜

## 方法 3：使用迴圈

**適用情況：** 需要動態建立，或邏輯較複雜

**語法：**
```
matrix = []
for i in range(3):
    row = [0] * 3
    matrix.append(row)
```

**執行邏輯：**
1. 建立空列表 `matrix = []`
2. 迴圈 3 次（建立 3 行）：
   - `row = [0] * 3` → 建立一行，包含 3 個 0
   - `matrix.append(row)` → 將這行加入陣列

**為什麼 `[0] * 3`？**
`[0] * 3` 會建立 `[0, 0, 0]`，這是建立相同元素列表的簡潔方式。

**優點：** 邏輯清楚，容易理解
**缺點：** 程式碼較長

## 實際範例

建立 2×3 的陣列（2 行 3 列）：

**方法 1：**
```
matrix = [[0, 0, 0], [0, 0, 0]]
```

**方法 2：**
```
matrix = [[0 for j in range(3)] for i in range(2)]
```

**方法 3：**
```
matrix = []
for i in range(2):
    row = [0] * 3
    matrix.append(row)
```

**結果：** `[[0, 0, 0], [0, 0, 0]]`

**記住：** 
- 小陣列：直接指定
- 規則陣列：列表生成式
- 複雜邏輯：使用迴圈
- 所有方法效果相同
""",
        "exercise": "請建立一個 2x3 的二維陣列（2 行 3 列），所有元素都是 0，然後印出。",
        "hint": "使用 `[[0] * 3 for i in range(2)]` 或類似方法。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "[[0, 0, 0], [0, 0, 0]]\n"
        }
    },
    {
        "id": "Ex6-4",
        "title": "新增二維陣列，新增一個Row",
        "explanation": """
## 為什麼需要新增行？

我們可以在二維陣列中新增一行，讓陣列動態增長。

**實際應用：**
- 新增學生資料到成績表
- 新增記錄到資料庫
- 動態擴展陣列大小

## 新增行的方法

**語法：**
```
二維陣列.append(新行)
```

**為什麼用 append()？**
因為二維陣列本質上是「列表的列表」，`append()` 可以在列表末尾新增元素（這裡的元素是一行）。

**注意：** 新行的長度（列數）應該與現有行相同，否則會造成不規則陣列。

## 實際範例

```
matrix = [[1, 2], [3, 4]]
new_row = [5, 6]
matrix.append(new_row)
print(matrix)  # 會印出 [[1, 2], [3, 4], [5, 6]]
```

**執行過程：**
1. 建立二維陣列 `[[1, 2], [3, 4]]`（2 行 2 列）
2. 建立新行 `[5, 6]`
3. 使用 `append()` 將新行加入陣列末尾
4. 陣列變成 `[[1, 2], [3, 4], [5, 6]]`（3 行 2 列）
5. 印出陣列

**結果：** `[[1, 2], [3, 4], [5, 6]]`

**視覺化：**
```
原本：    新增後：
[1, 2]    [1, 2]
[3, 4]    [3, 4]
          [5, 6]  ← 新增的行
```

## 也可以直接新增

**不需要先建立變數：**
```
matrix = [[1, 2], [3, 4]]
matrix.append([5, 6])  # 直接新增列表
```

**兩種方式效果相同！**

**記住：** 
- 使用 `append()` 新增行
- 新行是一個列表
- 新行會加在陣列的末尾
""",
        "exercise": "有一個二維陣列 `matrix = [[1, 2], [3, 4]]`。請新增一行 `[5, 6]`，然後印出整個陣列。",
        "hint": "使用 `append()` 方法新增一行。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "[[1, 2], [3, 4], [5, 6]]\n"
        }
    },
    {
        "id": "EX6-5",
        "title": "All Zero二維平面(5*5)，連續輸入多筆座標",
        "explanation": """
## 為什麼需要初始化二維陣列？

我們可以建立一個 5x5 的二維陣列，然後根據輸入的座標來修改元素。

**實際應用：**
- 建立遊戲棋盤
- 初始化圖像像素
- 建立資料表格

## 建立全零陣列

**為什麼用列表生成式？**
因為要建立規則的陣列（全部是 0），列表生成式最簡潔。

**語法：**
```
matrix = [[0 for j in range(5)] for i in range(5)]
```

**執行邏輯：**
- 外層：`for i in range(5)` → 建立 5 行
- 內層：`for j in range(5)` → 每行建立 5 個 0

**結果：** 5×5 的陣列，所有元素都是 0

**視覺化：**
```
[
    [0, 0, 0, 0, 0],  # 第 0 行
    [0, 0, 0, 0, 0],  # 第 1 行
    [0, 0, 0, 0, 0],  # 第 2 行
    [0, 0, 0, 0, 0],  # 第 3 行
    [0, 0, 0, 0, 0]   # 第 4 行
]
```

## 根據座標修改元素

**為什麼需要座標？**
座標告訴我們要修改哪個位置。

**座標格式：** `(行, 列)`

**語法：**
```
matrix[行][列] = 新值
```

**範例：**
```
# 將座標 (2, 3) 改為 1
matrix[2][3] = 1

# 將座標 (0, 0) 改為 1
matrix[0][0] = 1
```

**執行過程：**
1. `matrix[2][3] = 1`：
   - `matrix[2]` → 取得第 2 行
   - `matrix[2][3]` → 取得第 2 行的第 3 列
   - 將該元素改為 1
2. `matrix[0][0] = 1`：
   - 將第 0 行第 0 列改為 1

**修改後的陣列：**
```
[
    [1, 0, 0, 0, 0],  # 第 0 行（(0,0) 改為 1）
    [0, 0, 0, 0, 0],  # 第 1 行
    [0, 0, 0, 1, 0],  # 第 2 行（(2,3) 改為 1）
    [0, 0, 0, 0, 0],  # 第 3 行
    [0, 0, 0, 0, 0]   # 第 4 行
]
```

## 實際範例

```
matrix = [[0 for j in range(5)] for i in range(5)]
matrix[1][2] = 1  # 座標 (1, 2)
matrix[3][4] = 1  # 座標 (3, 4)
print(matrix)
```

**記住：** 
- 使用列表生成式建立規則陣列
- 座標格式：`(行, 列)`
- 使用 `matrix[行][列] = 值` 修改元素
""",
        "exercise": "請建立一個 5x5 的二維陣列，所有元素初始為 0。然後將座標 (1, 2) 和 (3, 4) 改為 1，最後印出整個陣列。",
        "hint": "先建立 5x5 陣列，然後修改指定座標的元素。",
        "validator": {
            "type": "stdout_contains",
            "expected_output": "1"
        }
    },
    {
        "id": "PT6-1",
        "title": "調整成績(float)",
        "explanation": """
## 為什麼用二維陣列儲存成績？

我們可以使用二維陣列來儲存多個學生的多科成績。

**實際應用：**
- 儲存班級成績表
- 管理多科成績
- 進行成績調整

**結構說明：**
- 外層列表：每個元素代表一個學生
- 內層列表：每個元素代表該學生的一科成績

## 理解索引

**範例：**
```
scores = [[85.5, 90.0], [75.5, 80.0], [92.0, 88.5]]
```

**索引說明：**
- `scores[0]` → 第一個學生的成績 `[85.5, 90.0]`
- `scores[0][0]` → 第一個學生的第一科成績 `85.5`
- `scores[1][1]` → 第二個學生的第二科成績 `80.0`

**視覺化：**
```
scores = [
    [85.5, 90.0],  # 學生 0：科目 0=85.5, 科目 1=90.0
    [75.5, 80.0],  # 學生 1：科目 0=75.5, 科目 1=80.0
    [92.0, 88.5]   # 學生 2：科目 0=92.0, 科目 1=88.5
]
```

## 批量調整成績

**為什麼需要巢狀迴圈？**
因為要遍歷所有學生和所有科目。

**語法：**
```
for i in range(len(scores)):        # 遍歷每個學生
    for j in range(len(scores[i])): # 遍歷該學生的每科
        scores[i][j] = scores[i][j] * 1.1  # 調整成績
```

**為什麼用 `len(scores)`？**
`len(scores)` 是學生的數量（行數）。

**為什麼用 `len(scores[i])`？**
`len(scores[i])` 是第 i 個學生的科目數量（列數）。

## 四捨五入：round() 函式

**為什麼需要 round()？**
因為成績調整後可能變成小數，需要四捨五入到整數。

**語法：**
```
round(數字)
```

**為什麼叫 round？**
`round` 是「四捨五入」的意思。

**範例：**
- `round(85.0 * 1.1)` = `round(93.5)` = `94`
- `round(75.0 * 1.1)` = `round(82.5)` = `83`

## 實際範例

```
scores = [[85.0, 90.0], [75.0, 80.0]]
for i in range(len(scores)):
    for j in range(len(scores[i])):
        scores[i][j] = round(scores[i][j] * 1.1)
print(scores)
```

**執行過程：**
1. 外層迴圈：`i = 0`（第一個學生）
   - 內層迴圈：`j = 0`（第一科）
     - `scores[0][0] = round(85.0 * 1.1) = round(93.5) = 94`
   - 內層迴圈：`j = 1`（第二科）
     - `scores[0][1] = round(90.0 * 1.1) = round(99.0) = 99`
2. 外層迴圈：`i = 1`（第二個學生）
   - 內層迴圈：`j = 0`（第一科）
     - `scores[1][0] = round(75.0 * 1.1) = round(82.5) = 83`
   - 內層迴圈：`j = 1`（第二科）
     - `scores[1][1] = round(80.0 * 1.1) = round(88.0) = 88`

**結果：** `[[94, 99], [83, 88]]`

**記住：** 
- 二維陣列：外層是學生，內層是科目
- 使用巢狀迴圈遍歷所有元素
- `round()` 四捨五入到整數
""",
        "exercise": "有一個成績陣列 `scores = [[85.0, 90.0], [75.0, 80.0]]`。請將所有成績乘以 1.1（四捨五入到整數），然後印出調整後的陣列。",
        "hint": "使用巢狀迴圈，每個成績乘以 1.1 後用 `round()` 四捨五入。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "[[94, 99], [83, 88]]\n"
        }
    },
    {
        "id": "PT6-2",
        "title": "輸入n筆成績(ENG,MATH)，印出成績表",
        "explanation": """
## 為什麼需要成績表？

我們可以使用二維陣列來儲存多個學生的多科成績，然後計算平均並以表格形式呈現。

**實際應用：**
- 班級成績管理
- 多科成績統計
- 成績報表生成

## 資料結構

**語法：**
```
scores = [[85, 90], [75, 80], [92, 88]]
```

**結構說明：**
- 外層列表：每個元素是一個學生
- 內層列表：`[英文, 數學]`（該學生的兩科成績）

**視覺化：**
```
scores = [
    [85, 90],  # 學生 0：英文 85，數學 90
    [75, 80],  # 學生 1：英文 75，數學 80
    [92, 88]   # 學生 2：英文 92，數學 88
]
```

## 印出標題

**為什麼需要標題？**
標題讓表格更清楚，知道每一欄代表什麼。

**語法：**
```
print("ENG MATH AVG")
```

**為什麼用空格分隔？**
因為要對齊各欄，讓表格更整齊。

## 遍歷學生

**為什麼用 enumerate()？**
`enumerate()` 可以同時取得索引和元素，但這裡我們只需要元素。

**簡化方法（不使用 enumerate）：**
```
for student in scores:
    eng = student[0]
    math = student[1]
    avg = (eng + math) / 2
    print(eng, "  ", math, "  ", avg)
```

**為什麼用索引 [0] 和 [1]？**
- `student[0]` → 第一科（英文）
- `student[1]` → 第二科（數學）

## 計算平均

**為什麼用 (eng + math) / 2？**
因為平均 = 總分 ÷ 科目數，這裡有 2 科。

**語法：**
```
avg = (eng + math) / 2
```

**為什麼用括號？**
因為要先計算 `eng + math`，再除以 2。

## 實際範例

```
scores = [[85, 90], [75, 80], [92, 88]]
print("ENG MATH AVG")

for student in scores:
    eng = student[0]
    math = student[1]
    avg = (eng + math) / 2
    print(eng, "  ", math, "  ", avg)
```

**執行過程：**
1. 印出標題：`ENG MATH AVG`
2. 第一次：`student = [85, 90]`
   - `eng = 85`，`math = 90`
   - `avg = (85 + 90) / 2 = 87.5`
   - 印出：`85 90 87.5`
3. 第二次：`student = [75, 80]`
   - `eng = 75`，`math = 80`
   - `avg = (75 + 80) / 2 = 77.5`
   - 印出：`75 80 77.5`
4. 第三次：`student = [92, 88]`
   - `eng = 92`，`math = 88`
   - `avg = (92 + 88) / 2 = 90.0`
   - 印出：`92 88 90.0`

**結果：**
```
ENG MATH AVG
85 90 87.5
75 80 77.5
92 88 90.0
```

**記住：** 
- 用二維陣列儲存多個學生的多科成績
- 使用索引存取各科成績
- 平均 = 總分 ÷ 科目數
- 印出標題讓表格更清楚
""",
        "exercise": "有一個成績陣列 `scores = [[85, 90], [75, 80], [92, 88]]`。\n請印出標題「ENG MATH AVG」，然後對每個學生印出英文、數學和平均成績（格式：85 90 87.5）。",
        "hint": "使用迴圈遍歷每個學生，計算平均並印出。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "ENG MATH AVG\n85 90 87.5\n75 80 77.5\n92 88 90.0\n"
        }
    },
    {
        "id": "PT6-3",
        "title": "All Zero二維平面(5*5):找出All Zero Row及All Zero Column",
        "explanation": """
## 為什麼需要找出全零行和全零列？

我們可以檢查二維陣列中哪些行（row）或列（column）全部是 0。

**實際應用：**
- 資料清理
- 矩陣分析
- 找出空行或空列

## 檢查行（Row）

**為什麼要檢查行？**
因為我們想知道「哪一行全部是 0」。

**策略：**
遍歷該行的所有元素，檢查是否都是 0。

**簡化方法（不使用 all()）：**
```
def is_all_zero_row(matrix, row_index):
    for x in matrix[row_index]:
        if x != 0:
            return False
    return True
```

**執行邏輯：**
1. 遍歷該行的每個元素
2. 如果發現任何一個元素不是 0 → 回傳 `False`
3. 如果所有元素都是 0 → 回傳 `True`

## 檢查列（Column）

**為什麼要檢查列？**
因為我們想知道「哪一列全部是 0」。

**策略：**
遍歷該列的所有元素，檢查是否都是 0。

**簡化方法：**
```
def is_all_zero_col(matrix, col_index):
    for i in range(len(matrix)):
        if matrix[i][col_index] != 0:
            return False
    return True
```

**執行邏輯：**
1. 遍歷每一行（`i` 從 0 到 `len(matrix)-1`）
2. 檢查第 `i` 行的第 `col_index` 列元素
3. 如果發現任何一個元素不是 0 → 回傳 `False`
4. 如果所有元素都是 0 → 回傳 `True`

## 找出所有全零行

**為什麼需要找出所有？**
因為可能有多個全零行。

**語法：**
```
zero_rows = []
for i in range(len(matrix)):
    if is_all_zero_row(matrix, i):
        zero_rows.append(i)
```

**執行邏輯：**
1. 建立空列表儲存全零行的索引
2. 遍歷每一行
3. 如果該行全為 0，將索引加入列表

## 實際範例

```
matrix = [
    [0, 0, 0, 1, 0],  # 第 0 行：不是全零
    [0, 0, 0, 0, 0],  # 第 1 行：全零 ✓
    [1, 0, 0, 0, 0],  # 第 2 行：不是全零
    [0, 0, 0, 0, 0],  # 第 3 行：全零 ✓
    [0, 1, 0, 0, 0]   # 第 4 行：不是全零
]

zero_rows = []
for i in range(len(matrix)):
    is_zero = True
    for x in matrix[i]:
        if x != 0:
            is_zero = False
            break
    if is_zero:
        zero_rows.append(i)

print("全零行：", zero_rows)
```

**執行過程：**
1. 第 0 行：`[0, 0, 0, 1, 0]` → 有 1，不是全零
2. 第 1 行：`[0, 0, 0, 0, 0]` → 全部是 0，加入索引 1
3. 第 2 行：`[1, 0, 0, 0, 0]` → 有 1，不是全零
4. 第 3 行：`[0, 0, 0, 0, 0]` → 全部是 0，加入索引 3
5. 第 4 行：`[0, 1, 0, 0, 0]` → 有 1，不是全零

**結果：** `全零行： [1, 3]`

**記住：** 
- 檢查行：遍歷該行的所有元素
- 檢查列：遍歷該列的所有元素（需要遍歷每一行）
- 使用迴圈和條件判斷找出全零行/列
- 將符合條件的索引加入列表
""",
        "exercise": "有一個 5x5 陣列 `matrix = [[0, 0, 0, 1, 0], [0, 0, 0, 0, 0], [1, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 1, 0, 0, 0]]`。\n請找出所有全為 0 的行索引，並印出「全零行：」和索引列表。",
        "hint": "檢查每一行是否所有元素都是 0。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "全零行： [1, 3]\n"
        }
    },
    {
        "id": "HW6-1",
        "title": "輸入n筆成績，印出成績表，並印出各科平均及最高分",
        "explanation": """
## 為什麼需要計算各科統計？

我們可以計算每科的平均分和最高分，這是成績分析的重要功能。

**實際應用：**
- 班級成績分析
- 科目表現評估
- 教學改進參考

## 提取各科成績

**為什麼需要提取？**
因為我們要分別計算每科的統計，需要先將該科的所有成績收集起來。

**策略：**
從每個學生的成績中，提取同一科的成績。

**語法（不使用列表生成式）：**
```
eng_scores = []
for s in scores:
    eng_scores.append(s[0])
```

**執行邏輯：**
1. 遍歷每個學生的成績
2. 取得該學生的第一科成績（`s[0]`）
3. 加入列表

**為什麼用索引 [0]？**
因為第一科（英文）在索引 0 的位置。

## 計算平均和最高

**為什麼用 sum() 和 len()？**
因為成績列表可能有多個元素，用內建函式更方便。

**語法：**
```
eng_avg = sum(eng_scores) / len(eng_scores)
eng_max = max(eng_scores)
```

**執行邏輯：**
1. `sum(eng_scores)` → 計算總分
2. `len(eng_scores)` → 計算人數
3. 總分 ÷ 人數 = 平均
4. `max(eng_scores)` → 找出最高分

## 實際範例

```
scores = [[85, 90], [75, 80], [92, 88]]

# 計算第一科（英文）的平均和最高
eng_scores = []
for s in scores:
    eng_scores.append(s[0])

eng_avg = sum(eng_scores) / len(eng_scores)
eng_max = max(eng_scores)
print("英文平均：", eng_avg)
print("英文最高：", eng_max)

# 計算第二科（數學）的平均和最高
math_scores = []
for s in scores:
    math_scores.append(s[1])

math_avg = sum(math_scores) / len(math_scores)
math_max = max(math_scores)
print("數學平均：", math_avg)
print("數學最高：", math_max)
```

**執行過程：**
1. 提取英文成績：
   - `scores[0][0] = 85`
   - `scores[1][0] = 75`
   - `scores[2][0] = 92`
   - `eng_scores = [85, 75, 92]`
2. 計算英文統計：
   - `eng_avg = (85 + 75 + 92) / 3 = 84.0`
   - `eng_max = 92`
3. 提取數學成績：
   - `scores[0][1] = 90`
   - `scores[1][1] = 80`
   - `scores[2][1] = 88`
   - `math_scores = [90, 80, 88]`
4. 計算數學統計：
   - `math_avg = (90 + 80 + 88) / 3 = 86.0`
   - `math_max = 90`

**結果：**
```
英文平均： 84.0
英文最高： 92
數學平均： 86.0
數學最高： 90
```

**記住：** 
- 使用迴圈提取各科成績
- 使用 `sum()` 和 `len()` 計算平均
- 使用 `max()` 找出最高分
- 對每科分別計算統計
""",
        "exercise": "有一個成績陣列 `scores = [[85, 90], [75, 80], [92, 88]]`。\n請計算並印出：\n1. 英文科平均和最高分（格式：英文平均：84.0，英文最高：92）\n2. 數學科平均和最高分（格式：數學平均：86.0，數學最高：90）",
        "hint": "分別提取每科的成績，計算平均和最高。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "英文平均： 84.0\n英文最高： 92\n數學平均： 86.0\n數學最高： 90\n"
        }
    },
    {
        "id": "HW6-2",
        "title": "帳密檢查：最多三次機會",
        "explanation": """
## 為什麼需要限制嘗試次數？

我們可以使用迴圈來限制嘗試次數，這是安全機制的重要部分。

**實際應用：**
- 防止暴力破解
- 保護帳號安全
- 限制登入嘗試

## 計數器模式

**為什麼需要計數器？**
因為我們要追蹤「已經嘗試了幾次」。

**語法：**
```
attempts = 0
max_attempts = 3
```

**為什麼初始值是 0？**
因為計數從 0 開始，第一次嘗試後變成 1。

## 迴圈條件

**為什麼用 `attempts < max_attempts`？**
因為我們要限制在最多 3 次，所以當 `attempts < 3` 時繼續嘗試。

**語法：**
```
while attempts < max_attempts:
    # 嘗試登入
    attempts = attempts + 1
```

**為什麼在迴圈內加 1？**
因為每次嘗試後，次數就加 1。

## 登入檢查

**為什麼需要兩個條件？**
因為帳號和密碼都要正確才能登入。

**語法：**
```
if input_user == username and input_pass == password:
    print("登入成功")
    break
```

**為什麼用 break？**
因為登入成功後，不需要繼續嘗試，直接跳出迴圈。

## while-else 結構

**什麼是 while-else？**
`while-else` 是 Python 的特殊語法：
- 如果迴圈正常結束（沒有 break），會執行 else 區塊
- 如果迴圈被 break 中斷，不會執行 else 區塊

**為什麼需要 else？**
因為我們想知道「是否用完了所有機會都沒登入成功」。

**語法：**
```
while attempts < max_attempts:
    # ...
    if 登入成功:
        break
else:
    print("登入失敗")
```

## 實際範例

```
username = "admin"
password = "1234"
max_attempts = 3
attempts = 0

while attempts < max_attempts:
    input_user = "user"  # 假設輸入
    input_pass = "wrong"  # 假設輸入
    attempts = attempts + 1
    
    if input_user == username and input_pass == password:
        print("登入成功")
        break
    else:
        remaining = max_attempts - attempts
        print("帳號或密碼錯誤，還剩", remaining, "次機會")
else:
    print("登入失敗")
```

**執行過程（假設都失敗）：**
1. 第一次：`attempts = 1`，檢查失敗，印出「還剩 2 次機會」
2. 第二次：`attempts = 2`，檢查失敗，印出「還剩 1 次機會」
3. 第三次：`attempts = 3`，檢查失敗，印出「還剩 0 次機會」
4. 迴圈結束（`attempts < 3` → `False`）
5. 執行 else：印出「登入失敗」

**如果第三次成功：**
1. 第一次：失敗
2. 第二次：失敗
3. 第三次：成功，執行 `break`，跳出迴圈
4. 不執行 else（因為有 break）

**記住：** 
- 使用計數器追蹤嘗試次數
- 使用 `while attempts < max_attempts` 限制次數
- 登入成功用 `break` 跳出
- 使用 `while-else` 處理失敗情況
""",
        "exercise": "系統帳號是 'user'，密碼是 'pass'。\n請寫一個程式，最多嘗試 3 次。\n假設第一次輸入 ('user', 'wrong')，第二次輸入 ('wrong', 'pass')，第三次輸入 ('user', 'pass')。\n每次錯誤後印出「錯誤，剩餘 X 次」，成功後印出「登入成功」。",
        "hint": "使用 while 迴圈控制次數，用 if 檢查帳密。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "錯誤，剩餘 2 次\n錯誤，剩餘 1 次\n登入成功\n"
        }
    },
    {
        "id": "HW6-3",
        "title": "n×n棋盤，檢查是否成一條線(直線or橫線)",
        "explanation": """
## 為什麼需要檢查是否成一條線？

我們可以檢查棋盤上是否有完整的直線或橫線，這是棋類遊戲的常見需求。

**實際應用：**
- 井字遊戲（Tic-tac-toe）
- 五子棋
- 連線遊戲

## 檢查橫線（Row）

**為什麼要檢查橫線？**
因為橫線是「同一行的所有元素都相同」。

**策略：**
1. 取得該行的第一個元素
2. 如果第一個元素是 0（空），不是一條線
3. 檢查該行的所有元素是否都等於第一個元素

**簡化方法（不使用 all()）：**
```
def check_row(matrix, row_index):
    first = matrix[row_index][0]
    if first == 0:
        return False
    for x in matrix[row_index]:
        if x != first:
            return False
    return True
```

**執行邏輯：**
1. 取得第一個元素 `first`
2. 如果 `first == 0` → 回傳 `False`（空行不是一條線）
3. 遍歷該行的每個元素
4. 如果發現任何元素不等於 `first` → 回傳 `False`
5. 如果所有元素都等於 `first` → 回傳 `True`

## 檢查直線（Column）

**為什麼要檢查直線？**
因為直線是「同一列的所有元素都相同」。

**策略：**
1. 取得該列的第一個元素
2. 如果第一個元素是 0（空），不是一條線
3. 檢查該列的所有元素是否都等於第一個元素

**簡化方法：**
```
def check_col(matrix, col_index):
    first = matrix[0][col_index]
    if first == 0:
        return False
    for i in range(len(matrix)):
        if matrix[i][col_index] != first:
            return False
    return True
```

**執行邏輯：**
1. 取得第一個元素 `first`（第 0 行的該列元素）
2. 如果 `first == 0` → 回傳 `False`
3. 遍歷每一行（`i` 從 0 到 `len(matrix)-1`）
4. 檢查第 `i` 行的第 `col_index` 列元素
5. 如果發現任何元素不等於 `first` → 回傳 `False`
6. 如果所有元素都等於 `first` → 回傳 `True`

## 實際範例

```
board = [[1, 1, 1], [2, 2, 0], [0, 0, 0]]

# 檢查第一行（索引 0）
first = board[0][0]  # 1
if first == 0:
    result = False
else:
    is_line = True
    for x in board[0]:
        if x != first:
            is_line = False
            break
    result = is_line

if result:
    print("第一行成一條線")
else:
    print("第一行不成一條線")
```

**執行過程：**
1. `first = board[0][0] = 1`
2. `first != 0`，繼續檢查
3. 遍歷 `board[0] = [1, 1, 1]`：
   - `1 == 1` ✓
   - `1 == 1` ✓
   - `1 == 1` ✓
4. 所有元素都等於 1 → `True`
5. 印出：`第一行成一條線`

**如果第一行是 `[1, 2, 1]`：**
1. `first = 1`
2. 遍歷 `[1, 2, 1]`：
   - `1 == 1` ✓
   - `2 == 1` ✗ → `False`，跳出
3. 印出：`第一行不成一條線`

**記住：** 
- 檢查橫線：遍歷該行的所有元素
- 檢查直線：遍歷該列的所有元素（需要遍歷每一行）
- 第一個元素是 0 時，不是一條線
- 所有元素都相同且不為 0 時，才是一條線
""",
        "exercise": "有一個 3x3 棋盤 `board = [[1, 1, 1], [2, 2, 0], [0, 0, 0]]`。\n請檢查第一行是否成一條線（所有元素相同且不為 0），如果是，印出「第一行成一條線」，否則印出「第一行不成一條線」。",
        "hint": "檢查第一行的所有元素是否相同且不為 0。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "第一行成一條線\n"
        }
    },
    
    # ========== 第六章：字典 (Dictionary) ==========
    {
        "id": "EX8-0",
        "title": "upper()",
        "explanation": """
## 字串方法：upper()

字串的 `upper()` 方法可以將所有字母轉換為大寫。

**什麼是方法（Method）？**
方法是「屬於某個物件的函式」。`upper()` 是字串的專屬方法。

**語法：**
```
字串變數.upper()
```

**為什麼用點號 `.`？**
點號 `.` 表示「屬於」或「的」。`text.upper()` 意思是「text 這個字串的 upper 方法」。

## 實際範例

```
text = "Hello World"
print(text.upper())
```

**執行過程：**
1. `text` 是字串 "Hello World"
2. 呼叫 `text.upper()` → 轉換為大寫 "HELLO WORLD"
3. 印出結果

**結果：** `HELLO WORLD`

**為什麼需要 upper()？**
有時候我們需要統一格式，例如將使用者輸入轉換為大寫來比較，避免大小寫造成的問題。

---

## 字典（Dictionary）簡介

字典是 Python 中另一個重要的資料結構，使用**鍵值對（key-value pairs）**來儲存資料。

**為什麼叫「字典」？**
就像查字典一樣：
- 您要找「鍵」（key，例如「apple」這個單字）
- 找到對應的「值」（value，例如「蘋果」這個解釋）

**生活中的類比：**
- 列表 = 編號的盒子（用數字 0, 1, 2... 來找）
- 字典 = 有標籤的盒子（用有意義的名稱來找，例如「姓名」、「年齡」）

## 為什麼用大括號 `{}`？

**大括號的作用：**
- `{}` 告訴 Python：「這是一個字典」
- 字典中的每個項目是「鍵: 值」的格式，用逗號分隔

**為什麼用冒號 `:`？**
冒號 `:` 用來分隔「鍵」和「值」。`"name": "Alice"` 表示「鍵是 name，值是 Alice」。

## 建立字典

### 空字典
```
my_dict = {}
```

### 有初始值的字典
```
my_dict = {"name": "Alice", "age": 25}
```

**語法說明：**
- `{` → 字典開始
- `"name": "Alice"` → 第一個鍵值對（鍵是 "name"，值是 "Alice"）
- `,` → 分隔符號
- `"age": 25` → 第二個鍵值對（鍵是 "age"，值是 25）
- `}` → 字典結束

## 存取元素

**為什麼用方括號 `[]` 來存取？**
就像列表用索引來存取元素一樣，字典用「鍵」來存取「值」。

```
print(my_dict["name"])  # 印出 "Alice"
print(my_dict["age"])   # 印出 25
```

**語法：** `字典名稱["鍵"]`

**為什麼鍵要用引號？**
因為鍵通常是字串，需要用引號標記。如果鍵是數字，可以不用引號（但通常鍵都是字串）。
""",
        "exercise": "有一個字串 text = 'python'。請使用 upper() 方法將它轉換為大寫並印出。",
        "hint": "使用 `text.upper()`。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "PYTHON\n"
        }
    },
    {
        "id": "EX8-1",
        "title": "dict_keys, dict_values, dict_items",
        "explanation": """
## 為什麼需要這些方法？

字典提供了三個重要的方法來取得鍵、值和鍵值對。這些方法讓我們可以「批量處理」字典的內容。

**為什麼不能直接用字典？**
有時候我們只需要鍵、只需要值，或者需要同時處理鍵值對。這些方法讓我們可以分別取得。

## 三個重要方法

### keys() - 取得所有鍵

**作用：** 取得字典中所有的鍵（key）

**語法：**
```
字典名稱.keys()
```

**為什麼叫 keys？**
因為字典的「鍵」就是 key，這個方法回傳所有的鍵。

### values() - 取得所有值

**作用：** 取得字典中所有的值（value）

**語法：**
```
字典名稱.values()
```

**為什麼叫 values？**
因為字典的「值」就是 value，這個方法回傳所有的值。

### items() - 取得所有鍵值對

**作用：** 取得字典中所有的鍵值對（key-value pairs）

**語法：**
```
字典名稱.items()
```

**為什麼叫 items？**
因為每個「項目」（item）就是一個鍵值對。

## 視圖物件（View Object）

**這些方法回傳的是什麼？**
這些方法回傳的是「視圖物件」（View Object），不是列表。

**為什麼不是列表？**
因為視圖物件是「動態的」，如果字典改變，視圖也會跟著改變。這樣更有效率。

**如何轉換為列表？**
使用 `list()` 函式：
```
list(字典名稱.keys())
list(字典名稱.values())
list(字典名稱.items())
```

## 實際範例

```
my_dict = {"a": 1, "b": 2, "c": 3}

keys = my_dict.keys()      # 取得所有鍵
values = my_dict.values()  # 取得所有值
items = my_dict.items()    # 取得所有鍵值對

print(list(keys))    # ['a', 'b', 'c']
print(list(values))  # [1, 2, 3]
print(list(items))   # [('a', 1), ('b', 2), ('c', 3)]
```

**執行過程：**
1. `keys()` 回傳鍵的視圖物件，轉換為列表：`['a', 'b', 'c']`
2. `values()` 回傳值的視圖物件，轉換為列表：`[1, 2, 3]`
3. `items()` 回傳鍵值對的視圖物件，每個鍵值對是一個元組 `(鍵, 值)`

**為什麼 items() 回傳的是元組？**
因為元組可以同時儲存鍵和值，而且元組是不可變的，適合用來表示「一對」資料。

**記住：** 
- `keys()` → 所有鍵
- `values()` → 所有值
- `items()` → 所有鍵值對（元組）
- 需要轉換為列表時，使用 `list()`
""",
        "exercise": "有一個字典 data = {'x': 10, 'y': 20, 'z': 30}。請印出所有鍵的列表。",
        "hint": "使用 `keys()` 方法，然後轉換為列表。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "['x', 'y', 'z']\n"
        }
    },
    {
        "id": "EX8-2",
        "title": "Dictionary sorting function",
        "explanation": """
## 為什麼需要排序字典？

我們可以使用 `sorted()` 函式來排序字典，但字典本身是無序的，所以我們排序的是「鍵值對列表」。

**為什麼字典是無序的？**
在 Python 3.7 之前，字典確實是無序的。雖然 Python 3.7+ 保持了插入順序，但我們仍然需要排序功能來按特定規則排列。

## sorted() 函式

**什麼是 sorted()？**
`sorted()` 是 Python 的內建函式，可以對任何可迭代物件進行排序。

**語法：**
```
sorted(可迭代物件, key=排序依據)
```

**為什麼需要 key 參數？**
當我們要按「值」排序而不是按「鍵」排序時，需要告訴 Python「要比較哪個部分」。

## 按鍵排序

**為什麼要先轉換為 items()？**
因為 `sorted()` 需要可迭代物件，`items()` 回傳鍵值對列表。

**語法：**
```
sorted_dict = sorted(my_dict.items())
```

**執行方式：**
- `items()` 回傳 `[('鍵1', 值1), ('鍵2', 值2), ...]`
- `sorted()` 按第一個元素（鍵）排序

## 按值排序

**為什麼需要 key 參數？**
因為預設是按第一個元素（鍵）排序，我們要按第二個元素（值）排序。

**語法：**
```
sorted_dict = sorted(my_dict.items(), key=lambda x: x[1])
```

## 什麼是 lambda？

**lambda 是什麼？**
`lambda` 是一個**匿名函式**（沒有名稱的函式），用來寫簡單的函式。

**語法：**
```
lambda 參數: 回傳值
```

**為什麼叫 lambda？**
來自數學的 lambda 演算（λ-calculus），表示「匿名函式」。

**範例：**
```
lambda x: x[1]
```

**解釋：**
- `lambda` → 定義匿名函式
- `x` → 參數（一個鍵值對，例如 `('Alice', 85)`）
- `x[1]` → 回傳第二個元素（值，例如 `85`）

**等價的普通函式：**
```
def get_value(x):
    return x[1]
```

**為什麼用 lambda？**
因為這個函式很簡單，只用一次，不需要定義完整的函式。

## 實際範例

### 按鍵排序
```
my_dict = {"c": 3, "a": 1, "b": 2}
sorted_dict = sorted(my_dict.items())
print(sorted_dict)  # [('a', 1), ('b', 2), ('c', 3)]
```

### 按值排序
```
scores = {'Alice': 85, 'Bob': 90, 'Charlie': 75}
sorted_dict = sorted(scores.items(), key=lambda x: x[1])
print(sorted_dict)  # [('Charlie', 75), ('Alice', 85), ('Bob', 90)]
```

**執行過程（按值排序）：**
1. `scores.items()` → `[('Alice', 85), ('Bob', 90), ('Charlie', 75)]`
2. `lambda x: x[1]` 告訴 Python：比較每個鍵值對的第二個元素（值）
3. 比較值：75, 85, 90
4. 排序結果：`[('Charlie', 75), ('Alice', 85), ('Bob', 90)]`

**記住：** 
- `sorted()` 可以排序任何可迭代物件
- `key` 參數指定排序依據
- `lambda` 是匿名函式，適合簡單的函式
- `x[0]` 是鍵，`x[1]` 是值
""",
        "exercise": "有一個字典 scores = {'Alice': 85, 'Bob': 90, 'Charlie': 75}。請按值（分數）由低到高排序，並印出排序後的鍵值對列表。",
        "hint": "使用 `sorted()` 和 `key=lambda x: x[1]`。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "[('Charlie', 75), ('Alice', 85), ('Bob', 90)]\n"
        }
    },
    {
        "id": "EX8-3",
        "title": "Empty Dictionary, add new element",
        "explanation": """
## 為什麼需要空字典？

我們可以建立空字典，然後動態地新增元素。這在我們一開始不知道要儲存什麼資料時很有用。

**實際應用：**
- 使用者輸入的資料
- 動態建立的配置
- 逐步收集的資訊

## 建立空字典

**語法：**
```
my_dict = {}
```

**為什麼用 `{}`？**
空的大括號表示「空的字典」，就像空列表用 `[]` 一樣。

**注意：** `{}` 是空字典，不是空集合！空集合要用 `set()`。

## 新增元素的方法

### 方法 1：使用賦值運算子

**語法：**
```
字典名稱["鍵"] = 值
```

**為什麼用方括號？**
就像列表用索引來存取元素一樣，字典用「鍵」來存取「值」。

**範例：**
```
my_dict["key1"] = "value1"
my_dict["key2"] = "value2"
```

**如果鍵已存在會怎樣？**
會覆蓋舊的值！這是修改元素的方式。

**如果鍵不存在會怎樣？**
會新增一個新的鍵值對！

### 方法 2：使用 update() 方法

**語法：**
```
字典名稱.update({鍵: 值})
```

**為什麼需要 update()？**
`update()` 可以一次新增多個鍵值對，比逐個賦值更方便。

**範例：**
```
my_dict.update({"key3": "value3", "key4": "value4"})
```

**兩種方法的差異：**
- 賦值：一次只能新增一個
- `update()`：可以一次新增多個

## 實際範例

```
data = {}
data['name'] = 'Python'
data['version'] = 3
print(data)
```

**執行過程：**
1. 建立空字典 `{}`
2. 新增 `'name': 'Python'`
3. 新增 `'version': 3`
4. 字典變成 `{'name': 'Python', 'version': 3}`
5. 印出字典

**結果：** `{'name': 'Python', 'version': 3}`

**記住：** 
- 空字典用 `{}`
- 新增元素：`字典["鍵"] = 值`
- 可以一次新增多個：`update()`
""",
        "exercise": "請建立一個空字典 data = {}，然後新增兩個鍵值對：'name': 'Python' 和 'version': 3，最後印出字典。",
        "hint": "使用 data['name'] = 'Python' 的方式新增。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "{'name': 'Python', 'version': 3}\n"
        }
    },
    {
        "id": "EX8-4",
        "title": "startswith(), lower()",
        "explanation": """
## 字串方法：startswith()

字串的 `startswith()` 方法可以檢查字串是否以特定字串開頭。

**為什麼需要 startswith()？**
有時候我們需要檢查字串的開頭，例如：
- 檢查檔案名稱是否以特定副檔名開頭
- 檢查網址是否以 "http" 開頭
- 檢查郵件是否以特定前綴開頭

**語法：**
```
字串.startswith(要檢查的前綴)
```

**回傳值：**
- `True`：如果字串以指定前綴開頭
- `False`：如果字串不以指定前綴開頭

## 實際範例

```
text = "Hello World"
print(text.startswith("Hello"))  # True
print(text.startswith("World"))  # False
```

**執行過程：**
1. `text.startswith("Hello")`：
   - 檢查 "Hello World" 是否以 "Hello" 開頭
   - 是 → 回傳 `True`
2. `text.startswith("World")`：
   - 檢查 "Hello World" 是否以 "World" 開頭
   - 否 → 回傳 `False`

## 字串方法：lower()

`lower()` 方法可以將所有字母轉換為小寫。

**為什麼需要 lower()？**
有時候我們需要統一格式，例如：
- 將使用者輸入轉換為小寫來比較
- 統一資料格式
- 避免大小寫造成的問題

**語法：**
```
字串.lower()
```

**與 upper() 的對比：**
- `upper()` → 轉大寫
- `lower()` → 轉小寫

## 實際範例

```
text = "Hello World"
print(text.lower())  # "hello world"
```

**執行過程：**
1. `text.lower()` → 將所有字母轉為小寫
2. 回傳 "hello world"
3. 印出結果

**注意：** `lower()` 不會改變原字串，而是回傳新的字串（因為字串是不可變的）。

## 組合使用

**為什麼可以組合？**
因為方法可以「鏈式呼叫」，一個方法的結果可以立即呼叫另一個方法。

**範例：**
```
text = "Hello World"
if text.lower().startswith("hello"):
    print("以小寫 hello 開頭")
```

**執行過程：**
1. `text.lower()` → "hello world"
2. `"hello world".startswith("hello")` → `True`
3. 印出訊息

**記住：** 
- `startswith()` 檢查開頭
- `lower()` 轉小寫
- 字串方法不會改變原字串，而是回傳新字串
""",
        "exercise": "有一個字串 text = 'Python Programming'。請檢查它是否以 'Python' 開頭，如果是，印出「是」，否則印出「否」。",
        "hint": "使用 `startswith()` 方法。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "是\n"
        }
    },
    {
        "id": "PT8-1",
        "title": "帳密檢查：最多三次機會。使用字典(Dictionary)",
        "explanation": """
## 為什麼用字典儲存帳密？

我們可以使用字典來儲存多個帳號和密碼。

**為什麼不用列表？**
- 列表用數字索引，但帳號是字串
- 字典用「鍵」（帳號）來找「值」（密碼），更直觀

**實際應用：**
- 會員系統
- 使用者認證
- 帳號管理

## 字典的結構

**語法：**
```
accounts = {"帳號1": "密碼1", "帳號2": "密碼2", ...}
```

**範例：**
```
accounts = {"user1": "pass1", "user2": "pass2", "admin": "admin123"}
```

**結構說明：**
- 鍵（key）：帳號名稱
- 值（value）：對應的密碼

## 檢查登入

**為什麼需要兩個條件？**
1. 帳號必須存在
2. 密碼必須正確

**語法：**
```
if 帳號 in 字典 and 字典[帳號] == 密碼:
    print("登入成功")
else:
    print("帳號或密碼錯誤")
```

## in 運算子

**什麼是 in？**
`in` 運算子用來檢查「鍵是否存在於字典中」。

**語法：**
```
鍵 in 字典
```

**回傳值：**
- `True`：如果鍵存在
- `False`：如果鍵不存在

**為什麼先檢查 in？**
如果帳號不存在，直接存取 `accounts[帳號]` 會出錯！

## 邏輯運算子：and

**什麼是 and？**
`and` 表示「而且」，兩個條件都要成立。

**語法：**
```
條件1 and 條件2
```

**執行邏輯：**
- 如果條件1是 `False`，直接回傳 `False`（不檢查條件2）
- 如果條件1是 `True`，才檢查條件2

**為什麼用 and？**
因為登入需要「帳號存在」**而且**「密碼正確」。

## 實際範例

```
accounts = {"user1": "pass1", "user2": "pass2", "admin": "admin123"}

input_user = "user1"
input_pass = "pass1"

if input_user in accounts and accounts[input_user] == input_pass:
    print("登入成功")
else:
    print("帳號或密碼錯誤")
```

**執行過程：**
1. 檢查：`"user1" in accounts` → `True`（帳號存在）
2. 檢查：`accounts["user1"] == "pass1"` → `"pass1" == "pass1"` → `True`（密碼正確）
3. `True and True` → `True`
4. 印出：`登入成功`

**如果帳號不存在：**
```
input_user = "unknown"
if "unknown" in accounts and ...  # False，直接回傳 False
# 不會執行 accounts["unknown"]，避免錯誤
```

**如果密碼錯誤：**
```
input_user = "user1"
input_pass = "wrong"
if "user1" in accounts and accounts["user1"] == "wrong":
    # True and False → False
    print("帳號或密碼錯誤")
```

**記住：** 
- 用字典儲存帳號和密碼
- 先檢查 `in` 確認帳號存在
- 使用 `and` 檢查兩個條件
- 兩個條件都成立才登入成功
""",
        "exercise": "有一個帳號字典 accounts = {'alice': '1234', 'bob': '5678'}。\n輸入的帳號是 user = 'alice'，密碼是 pwd = '1234'。\n請檢查帳號是否存在且密碼正確，如果正確印出「登入成功」，否則印出「登入失敗」。",
        "hint": "使用 `in` 檢查鍵是否存在，然後比較值。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "登入成功\n"
        }
    },
    {
        "id": "PT8-2",
        "title": "MonthDays：輸入英文縮寫之月份，印出全名，並印出該月有幾天",
        "explanation": """
## 為什麼用字典對應月份？

我們可以使用字典來對應月份縮寫和全名，以及天數。

**為什麼不用列表？**
- 列表用數字索引，但月份縮寫是字串
- 字典用「鍵」（縮寫）來找「值」（全名或天數），更直觀

**實際應用：**
- 月份轉換
- 資料查詢
- 對應表

## 建立兩個字典

**為什麼需要兩個字典？**
因為我們需要儲存兩種資訊：
- 縮寫 → 全名
- 縮寫 → 天數

**語法：**
```
month_names = {"Jan": "January", "Feb": "February", "Mar": "March"}
month_days = {"Jan": 31, "Feb": 28, "Mar": 31}
```

**結構說明：**
- 兩個字典使用相同的鍵（月份縮寫）
- 不同的值（一個是全名，一個是天數）

## 查詢字典

**為什麼用縮寫作為鍵？**
因為縮寫是輸入，我們要用它來查詢對應的值。

**語法：**
```
字典名稱[鍵]
```

**範例：**
```
abbr = "Jan"
print(month_names[abbr])  # "January"
print(month_days[abbr])   # 31
```

**執行過程：**
1. `month_names["Jan"]` → 查詢鍵 "Jan" 對應的值 → "January"
2. `month_days["Jan"]` → 查詢鍵 "Jan" 對應的值 → 31

## 實際範例

```
month_names = {"Jan": "January", "Feb": "February", "Mar": "March"}
month_days = {"Jan": 31, "Feb": 28, "Mar": 31}

month = "Feb"
print(month_names[month])  # "February"
print(month_days[month])   # 28
```

**執行過程：**
1. `month = "Feb"`
2. `month_names["Feb"]` → "February"
3. `month_days["Feb"]` → 28
4. 印出：`February`
5. 印出：`28`

**結果：**
```
February
28
```

## 為什麼用字典而不是列表？

**列表的方式（較複雜）：**
```
months = ["Jan", "Feb", "Mar"]
names = ["January", "February", "March"]
days = [31, 28, 31]

# 需要先找到索引
index = months.index("Feb")
print(names[index])  # "February"
print(days[index])   # 28
```

**字典的方式（較簡單）：**
```
month_names = {"Feb": "February"}
month_days = {"Feb": 28}

print(month_names["Feb"])  # 直接查詢
print(month_days["Feb"])
```

**字典的優點：** 直接查詢，不需要找索引！

**記住：** 
- 用字典建立對應表
- 使用相同的鍵可以對應多個值
- 字典查詢比列表索引更直觀
""",
        "exercise": "有一個月份字典 months = {'Jan': 'January', 'Feb': 'February', 'Mar': 'March'}\n和天數字典 days = {'Jan': 31, 'Feb': 28, 'Mar': 31}。\n如果輸入 month = 'Feb'，請印出全名和天數（分兩行）。",
        "hint": "使用字典查詢對應的值。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "February\n28\n"
        }
    },
    {
        "id": "PT8-3",
        "title": "CarBrand：汽車購買調查",
        "explanation": """
## 為什麼用字典統計？

我們可以使用字典來統計資料，這是字典的常見應用。

**實際應用：**
- 統計出現次數
- 計算頻率
- 資料分析

**為什麼不用列表？**
- 列表需要知道索引，但品牌名稱是字串
- 字典用「鍵」（品牌）來儲存「值」（次數），更直觀

## 方法 1：使用 if-else

**邏輯：**
- 如果品牌已存在 → 次數加 1
- 如果品牌不存在 → 初始化為 1

**語法：**
```
count = {}
for brand in brands:
    if brand in count:
        count[brand] = count[brand] + 1  # 已存在，加 1
    else:
        count[brand] = 1  # 不存在，初始化為 1
```

**執行過程：**
1. 第一次遇到 "Toyota"：不存在 → `count["Toyota"] = 1`
2. 第二次遇到 "Toyota"：存在 → `count["Toyota"] = 1 + 1 = 2`
3. 第三次遇到 "Toyota"：存在 → `count["Toyota"] = 2 + 1 = 3`

## 方法 2：使用 get() 方法（推薦）

**什麼是 get()？**
`get()` 是字典的方法，可以安全地取得值，如果鍵不存在就回傳預設值。

**語法：**
```
字典名稱.get(鍵, 預設值)
```

**為什麼用 get()？**
- 如果鍵存在 → 回傳對應的值
- 如果鍵不存在 → 回傳預設值（不會出錯）

**語法：**
```
count[brand] = count.get(brand, 0) + 1
```

**執行邏輯：**
1. `count.get(brand, 0)` → 如果 brand 存在，回傳次數；否則回傳 0
2. `+ 1` → 次數加 1
3. `count[brand] = ...` → 儲存新的次數

**為什麼預設值是 0？**
因為如果品牌不存在，次數應該是 0，加 1 後變成 1。

## 實際範例

### 方法 1：if-else
```
brands = ["Toyota", "Honda", "Toyota", "BMW", "Honda", "Toyota"]
count = {}
for brand in brands:
    if brand in count:
        count[brand] = count[brand] + 1
    else:
        count[brand] = 1
print(count)  # {'Toyota': 3, 'Honda': 2, 'BMW': 1}
```

### 方法 2：get()（更簡潔）
```
brands = ["Toyota", "Honda", "Toyota", "BMW", "Honda", "Toyota"]
count = {}
for brand in brands:
    count[brand] = count.get(brand, 0) + 1
print(count)  # {'Toyota': 3, 'Honda': 2, 'BMW': 1}
```

**執行過程（方法 2）：**
1. "Toyota"：`count.get("Toyota", 0) = 0`，`count["Toyota"] = 0 + 1 = 1`
2. "Honda"：`count.get("Honda", 0) = 0`，`count["Honda"] = 0 + 1 = 1`
3. "Toyota"：`count.get("Toyota", 0) = 1`，`count["Toyota"] = 1 + 1 = 2`
4. "BMW"：`count.get("BMW", 0) = 0`，`count["BMW"] = 0 + 1 = 1`
5. "Honda"：`count.get("Honda", 0) = 1`，`count["Honda"] = 1 + 1 = 2`
6. "Toyota"：`count.get("Toyota", 0) = 2`，`count["Toyota"] = 2 + 1 = 3`

**結果：** `{'Toyota': 3, 'Honda': 2, 'BMW': 1}`

**記住：** 
- 用字典統計出現次數
- `get()` 方法更簡潔，推薦使用
- `get(鍵, 0)` 表示「如果不存在就當作 0」
""",
        "exercise": "有一個品牌列表 brands = ['Toyota', 'Honda', 'Toyota', 'BMW']。\n請統計每個品牌出現的次數，並印出統計字典。",
        "hint": "使用字典和迴圈來統計。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "{'Toyota': 2, 'Honda': 1, 'BMW': 1}\n"
        }
    },
    {
        "id": "HW8-1",
        "title": "帳密檢查(功能表)：會員註冊(ID不能重複)",
        "explanation": """
## 為什麼需要會員系統？

我們可以建立一個會員系統，使用字典來儲存帳號和密碼。

**實際應用：**
- 網站會員註冊
- 使用者管理
- 帳號驗證

## 註冊功能

**為什麼要檢查帳號是否存在？**
因為每個帳號必須是唯一的，不能重複註冊。

**邏輯：**
- 如果帳號已存在 → 不能註冊
- 如果帳號不存在 → 可以註冊

**語法：**
```
if 帳號 in 字典:
    print("帳號已存在")
else:
    字典[帳號] = 密碼
    print("註冊成功")
```

**為什麼用 in 檢查？**
`in` 可以安全地檢查鍵是否存在，不會出錯。

## 實際範例

### 註冊功能
```
members = {}
username = "newuser"
password = "newpass"

if username in members:
    print("帳號已存在")
else:
    members[username] = password
    print("註冊成功")
```

**執行過程：**
1. 檢查：`"newuser" in members` → `False`（帳號不存在）
2. 執行 else：`members["newuser"] = "newpass"`
3. 字典變成 `{"newuser": "newpass"}`
4. 印出：`註冊成功`

**如果帳號已存在：**
```
members = {"newuser": "newpass"}
username = "newuser"

if "newuser" in members:  # True
    print("帳號已存在")  # 不會註冊
```

## 登入功能

**邏輯：**
- 帳號必須存在
- 密碼必須正確

**語法：**
```
if 帳號 in 字典 and 字典[帳號] == 密碼:
    print("登入成功")
```

**為什麼用 and？**
因為兩個條件都要成立：帳號存在**而且**密碼正確。

## 實際範例

```
members = {"user1": "pass1"}
username = "user1"
password = "pass1"

if username in members and members[username] == password:
    print("登入成功")
```

**執行過程：**
1. 檢查：`"user1" in members` → `True`（帳號存在）
2. 檢查：`members["user1"] == "pass1"` → `"pass1" == "pass1"` → `True`（密碼正確）
3. `True and True` → `True`
4. 印出：`登入成功`

**記住：** 
- 註冊前要檢查帳號是否已存在
- 使用 `in` 檢查鍵是否存在
- 登入需要兩個條件：帳號存在**而且**密碼正確
""",
        "exercise": "有一個會員字典 members = {'user1': 'pass1'}。\n請檢查新帳號 new_user = 'user2' 是否已存在。如果不存在，將 new_user 和密碼 'pass2' 加入字典，並印出「註冊成功」。如果已存在，印出「帳號已存在」。",
        "hint": "使用 `in` 檢查鍵是否存在。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "註冊成功\n"
        }
    },
    {
        "id": "HW8-2",
        "title": "CarBrand：汽車購買調查",
        "explanation": """
## 為什麼需要找出最受歡迎的品牌？

我們可以進行更複雜的統計分析，找出出現次數最多的品牌。

**實際應用：**
- 市場調查
- 資料分析
- 找出熱門項目

## 步驟 1：統計出現次數

**為什麼要先統計？**
因為我們需要知道每個品牌出現幾次，才能找出最多的。

**語法：**
```
count = {}
for brand in brands:
    count[brand] = count.get(brand, 0) + 1
```

**結果範例：** `{'Toyota': 3, 'Honda': 2, 'BMW': 1}`

## 步驟 2：找出最大值

**為什麼用 values()？**
因為我們要比較的是「次數」（值），不是品牌名稱（鍵）。

**語法：**
```
max_count = max(count.values())
```

**執行過程：**
1. `count.values()` → `[3, 2, 1]`（所有次數）
2. `max([3, 2, 1])` → `3`（最大值）

## 步驟 3：找出對應的品牌

**為什麼需要這一步？**
因為我們知道最大值是 3，但不知道是哪個品牌。

**方法：使用列表生成式和 items()**

**語法：**
```
popular_brands = [b for b, c in count.items() if c == max_count]
```

**這是什麼？**
這是「列表生成式」（List Comprehension），用來建立列表。

**執行邏輯：**
1. `count.items()` → `[('Toyota', 3), ('Honda', 2), ('BMW', 1)]`
2. 對每個鍵值對 `(b, c)`：
   - `b` = 品牌名稱
   - `c` = 出現次數
3. `if c == max_count` → 如果次數等於最大值
4. `b` → 將品牌名稱加入列表

**為什麼可能有多個品牌？**
因為可能有多個品牌出現次數相同（都是最大值）。

## 簡化方法：直接找最大值對應的鍵

**如果只需要一個品牌（假設只有一個最大值）：**
```
max_count = max(count.values())
for brand, cnt in count.items():
    if cnt == max_count:
        print("最受歡迎：", brand)
        break
```

## 實際範例

```
brands = ["Toyota", "Honda", "Toyota", "BMW", "Honda", "Toyota"]
count = {}
for brand in brands:
    count[brand] = count.get(brand, 0) + 1

max_count = max(count.values())
for brand, cnt in count.items():
    if cnt == max_count:
        print("最受歡迎：", brand)
        break
```

**執行過程：**
1. 統計：`{'Toyota': 3, 'Honda': 2, 'BMW': 1}`
2. 最大值：`max([3, 2, 1]) = 3`
3. 遍歷字典：
   - `('Toyota', 3)`：`3 == 3` → `True`，印出 "最受歡迎： Toyota"，`break`
4. 結果：`最受歡迎： Toyota`

**記住：** 
- 先統計出現次數
- 使用 `max(count.values())` 找出最大值
- 遍歷字典找出對應的品牌
- 可能有多個品牌並列第一
""",
        "exercise": "有一個品牌列表 brands = ['Toyota', 'Honda', 'Toyota', 'BMW', 'Toyota']。\n請統計每個品牌出現的次數，找出出現次數最多的品牌並印出「最受歡迎：」和品牌名稱。",
        "hint": "統計後使用 `max()` 找出最大值。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "最受歡迎： Toyota\n"
        }
    },
    
    # ========== 第七章：集合和元組 ==========
    {
        "id": "EX9-0",
        "title": "tuple",
        "explanation": """
## 什麼是元組？

元組（Tuple）是 Python 中**不可變（immutable）**的序列，用圓括號表示。

**為什麼需要元組？**
列表是可變的，但有時候我們需要「不能修改」的資料結構，例如座標、RGB 顏色值等。

**列表 vs 元組：**
- 列表 `[1, 2, 3]` → 可以修改（可變）
- 元組 `(1, 2, 3)` → 不能修改（不可變）

## 建立元組

### 空元組
```
my_tuple = ()
```

### 有初始值的元組
```
my_tuple = (1, 2, 3)
```

**也可以不用括號：**
```
my_tuple = 1, 2, 3  # 逗號就足以建立元組
```

**為什麼可以不用括號？**
因為逗號 `,` 就足以告訴 Python 這是元組。但建議還是用括號，讓程式碼更清楚。

## 元組的特性

### 1. 不可變（Immutable）

**什麼是不可變？**
建立後不能修改，不能新增、刪除或改變元素。

**為什麼不能修改？**
```
my_tuple = (1, 2, 3)
my_tuple[0] = 99  # 錯誤！元組不能修改
```

**為什麼需要不可變？**
- 安全性：確保資料不會被意外修改
- 可作為字典的鍵（因為鍵必須不可變）
- 效能：不可變物件可以優化

### 2. 可以作為字典的鍵

**為什麼列表不能作為字典的鍵？**
因為列表是可變的，如果列表改變了，字典就無法正確找到對應的值。

**元組可以：**
```
coordinates = {(1, 2): "位置A", (3, 4): "位置B"}
```

### 3. 可以解包（Unpacking）

**什麼是解包？**
將元組中的值分別賦值給多個變數。

**語法：**
```
a, b, c = (1, 2, 3)
```

**為什麼需要解包？**
函數回傳多個值時，就是用元組，然後可以解包使用。

## 實際範例

```
data = (10, 20, 30)
print(data[0])  # 印出 10
```

**執行過程：**
1. 建立元組 `(10, 20, 30)`
2. 使用索引 `[0]` 存取第一個元素
3. 印出 10

**記住：** 
- 元組用圓括號 `()`
- 元組不可變，不能修改
- 可以作為字典的鍵
- 可以解包
""",
        "exercise": "請建立一個元組 `data = (10, 20, 30)`，然後印出第一個元素。",
        "hint": "使用索引 `[0]` 來存取第一個元素。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "10\n"
        }
    },
    {
        "id": "EX9-1",
        "title": "Subset",
        "explanation": """
## 什麼是集合？

集合（Set）是 Python 中**無序且不重複**的元素集合。

**為什麼需要集合？**
有時候我們需要：
- 去除重複元素
- 快速檢查元素是否存在
- 進行集合運算（交集、聯集等）

**集合的特性：**
- **無序**：元素沒有固定順序
- **不重複**：每個元素只能出現一次
- **可變**：可以新增、刪除元素

**生活中的類比：**
- 列表 = 有順序的購物清單（可以重複）
- 集合 = 不重複的標籤集合（沒有順序）

## 建立集合

### 空集合
```
my_set = set()
```

**為什麼不能用 `{}`？**
因為 `{}` 是空字典，不是空集合！空集合必須用 `set()`。

### 有初始值的集合
```
my_set = {1, 2, 3}
```

**為什麼用大括號 `{}`？**
集合和字典都用大括號，但集合沒有「鍵: 值」的格式，只有值。

## 子集（Subset）

**什麼是子集？**
如果集合 A 的所有元素都在集合 B 中，那麼 A 是 B 的子集。

**數學符號：** A ⊆ B（A 是 B 的子集）

**為什麼需要檢查子集？**
例如：檢查「所有及格的學生」是否都在「所有學生」中。

## 檢查子集的方法

### 方法 1：使用 issubset() 方法

```
set2.issubset(set1)
```

**語法：** `較小的集合.issubset(較大的集合)`

**為什麼叫 issubset？**
- `is` = 是
- `subset` = 子集
- `issubset` = 是子集

### 方法 2：使用 <= 運算子

```
set2 <= set1
```

**為什麼用 <=？**
因為子集的關係就像「小於等於」，所有元素都在另一個集合中。

**兩種方法效果相同！**

## 實際範例

```
set1 = {1, 2, 3, 4}
set2 = {2, 3}
print(set2.issubset(set1))  # True
print(set2 <= set1)         # True
```

**執行過程：**
1. `set1 = {1, 2, 3, 4}`（較大的集合）
2. `set2 = {2, 3}`（較小的集合）
3. 檢查：`set2` 的所有元素（2, 3）都在 `set1` 中
4. 結果：`True`（是子集）

**記住：** 
- 集合用大括號 `{}`，但空集合用 `set()`
- 集合無序且不重複
- 子集檢查：`A.issubset(B)` 或 `A <= B`
""",
        "exercise": "有兩個集合 `set1 = {1, 2, 3, 4}` 和 `set2 = {2, 3}`。請檢查 `set2` 是否是 `set1` 的子集，如果是，印出「是子集」，否則印出「不是子集」。",
        "hint": "使用 `issubset()` 方法或 `<=` 運算子。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "是子集\n"
        }
    },
    {
        "id": "EX9-2",
        "title": "Set (英數及格)",
        "explanation": """
## 為什麼用集合來處理及格名單？

我們可以使用集合來判斷學生是否同時通過英文和數學。

**為什麼不用列表？**
- 列表可以重複，但座號不會重複
- 列表需要迴圈來找交集，集合可以直接用運算子
- 集合的運算更直觀、更快速

## 集合的交集運算

**什麼是交集？**
交集（Intersection）是兩個集合中「共同」的元素。

**數學符號：** A ∩ B（A 和 B 的交集）

**生活中的類比：**
- 英文及格 = 集合 A
- 數學及格 = 集合 B
- 兩科都及格 = A 和 B 的交集

## 交集運算子：&

**語法：**
```
集合1 & 集合2
```

**為什麼用 `&`？**
`&` 是位元運算的 AND，在集合運算中表示「交集」（兩者都有）。

**等價方法：**
```
集合1.intersection(集合2)
```

**兩種方法效果相同！**

## 實際範例

```
english_pass = {1, 3, 5, 7}  # 英文及格的學生座號
math_pass = {2, 3, 5, 6}     # 數學及格的學生座號

both_pass = english_pass & math_pass  # 交集：兩科都及格
print(both_pass)  # {3, 5}
```

**執行過程：**
1. `english_pass = {1, 3, 5, 7}`（英文及格：座號 1, 3, 5, 7）
2. `math_pass = {2, 3, 5, 6}`（數學及格：座號 2, 3, 5, 6）
3. 計算交集：找出兩個集合都有的元素
   - 1：只在英文及格中 ✗
   - 2：只在數學及格中 ✗
   - 3：兩科都有 ✓
   - 5：兩科都有 ✓
   - 6：只在數學及格中 ✗
   - 7：只在英文及格中 ✗
4. 結果：`{3, 5}`（座號 3 和 5 的學生兩科都及格）

**視覺化：**
```
英文及格：{1, 3, 5, 7}
數學及格：{2, 3, 5, 6}
交集：    {3, 5}  ← 兩科都有的
```

**記住：** 
- 交集用 `&` 運算子
- 交集找出「兩個集合都有的元素」
- 也可以用 `intersection()` 方法
""",
        "exercise": "有兩個集合：`english_pass = {1, 3, 5, 7}` 和 `math_pass = {2, 3, 5, 6}`。\n請找出兩科都及格的學生座號（交集），並印出集合。",
        "hint": "使用 `&` 運算子或 `intersection()` 方法。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "{3, 5}\n"
        }
    },
    {
        "id": "EX9-3",
        "title": "Set Sorting",
        "explanation": """
## 為什麼集合是無序的？

集合本身是**無序的**，元素沒有固定順序。

**為什麼集合無序？**
這是集合的設計特性，讓集合運算更快速。Python 使用雜湊表（hash table）來實作集合，所以順序不固定。

**生活中的類比：**
- 列表 = 有編號的盒子（有順序）
- 集合 = 沒有編號的盒子（沒有順序）

## 為什麼需要排序？

有時候我們需要按順序顯示集合的元素，例如：
- 顯示排序後的結果
- 找出最小/最大值
- 按順序處理

## 如何排序集合？

**步驟：**
1. 將集合轉換為列表
2. 使用 `sorted()` 函式排序

**語法：**
```
sorted_list = sorted(集合)
```

**為什麼用 sorted()？**
`sorted()` 會回傳一個新的排序列表，不會改變原集合。

## 集合自動去重

**重要特性：** 集合會自動去除重複元素！

**為什麼？**
這是集合的定義：集合中的元素都是唯一的。

**範例：**
```
my_set = {3, 1, 4, 1, 5, 9, 2, 6}
print(my_set)  # {1, 2, 3, 4, 5, 6, 9}（重複的 1 被去除了）
```

## 實際範例

```
my_set = {3, 1, 4, 1, 5, 9, 2, 6}
sorted_list = sorted(my_set)  # 轉換為排序後的列表
print(sorted_list)  # [1, 2, 3, 4, 5, 6, 9]
```

**執行過程：**
1. 建立集合 `{3, 1, 4, 1, 5, 9, 2, 6}`
2. 自動去重：`{1, 2, 3, 4, 5, 6, 9}`（重複的 1 被去除）
3. 使用 `sorted()` 排序：`[1, 2, 3, 4, 5, 6, 9]`
4. 印出排序後的列表

**結果：** `[1, 2, 3, 4, 5, 6, 9]`

**注意：** 
- 集合會自動去重
- `sorted()` 回傳列表，不改變原集合
- 排序後的結果是列表，不是集合

**記住：** 
- 集合是無序的
- 集合會自動去重
- 使用 `sorted()` 可以排序集合並轉換為列表
""",
        "exercise": "有一個集合 `numbers = {5, 2, 8, 1, 9, 2}`。請將它轉換為排序後的列表並印出。",
        "hint": "使用 `sorted()` 函式。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "[1, 2, 5, 8, 9]\n"
        }
    },
    {
        "id": "EX9-4",
        "title": "Array of sets",
        "explanation": """
## 為什麼需要集合列表？

我們可以建立一個包含多個集合的列表，就像「列表的列表」一樣。

**實際應用：**
- 儲存多個群組的成員
- 管理多個標籤集合
- 處理多組資料

**生活中的類比：**
- 列表 = 一個大盒子
- 集合列表 = 大盒子裡有很多個小盒子（每個小盒子是一個集合）

## 建立集合列表

**語法：**
```
sets_list = [集合1, 集合2, 集合3, ...]
```

**為什麼用方括號？**
外層的 `[]` 表示這是一個列表。

**為什麼集合用大括號？**
每個集合用 `{}` 表示。

**範例：**
```
sets_list = [{1, 2, 3}, {4, 5, 6}, {7, 8, 9}]
```

**結構說明：**
- 外層：列表，有 3 個元素
- 每個元素：一個集合

## 存取集合

**語法：**
```
集合列表[索引]
```

**範例：**
```
sets_list = [{1, 2, 3}, {4, 5, 6}, {7, 8, 9}]
print(sets_list[0])  # {1, 2, 3}
```

**執行過程：**
1. `sets_list[0]` → 取得列表的第 0 個元素
2. 第 0 個元素是集合 `{1, 2, 3}`
3. 印出集合

## 遍歷集合列表

**為什麼需要遍歷？**
當我們要對每個集合進行操作時，需要用迴圈遍歷。

**語法：**
```
for 變數 in 集合列表:
    # 對每個集合進行操作
```

**範例：**
```
for s in sets_list:
    print(len(s))  # 印出每個集合的大小
```

**執行過程：**
1. 第一次：`s = {1, 2, 3}`，`len(s) = 3`，印出 3
2. 第二次：`s = {4, 5, 6}`，`len(s) = 3`，印出 3
3. 第三次：`s = {7, 8, 9}`，`len(s) = 3`，印出 3

## 實際範例

```
sets = [{1, 2}, {3, 4, 5}, {6}]
for s in sets:
    print(len(s))
```

**執行過程：**
1. 第一次：`s = {1, 2}`，`len(s) = 2`，印出 2
2. 第二次：`s = {3, 4, 5}`，`len(s) = 3`，印出 3
3. 第三次：`s = {6}`，`len(s) = 1`，印出 1

**結果：**
```
2
3
1
```

**記住：** 
- 集合列表 = 列表的每個元素都是集合
- 使用索引存取特定集合
- 使用迴圈遍歷所有集合
""",
        "exercise": "有一個集合列表 `sets = [{1, 2}, {3, 4, 5}, {6}]`。請印出每個集合的大小（元素個數），每個數字一行。",
        "hint": "使用迴圈和 `len()` 函式。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "2\n3\n1\n"
        }
    },
    {
        "id": "PT9-1",
        "title": "食玩(Candy Toy)蒐集:輸入贈品代碼",
        "explanation": """
## 為什麼用集合追蹤收集？

我們可以使用集合來追蹤已收集的贈品，因為集合會自動去重，而且可以快速檢查元素是否存在。

**實際應用：**
- 收集遊戲
- 追蹤已完成的任務
- 去重處理

**為什麼不用列表？**
- 列表需要手動檢查是否重複
- 集合自動去重，而且 `in` 檢查更快

## 檢查是否已收集

**為什麼用 in 檢查？**
`in` 可以快速檢查元素是否在集合中。

**語法：**
```
if 元素 in 集合:
    print("Duplicate")  # 重複
else:
    集合.add(元素)      # 新增
    print("New")        # 新的
```

**為什麼先檢查？**
因為集合會自動去重，但我們想知道「這是新的還是重複的」。

## add() 方法

**什麼是 add()？**
`add()` 是集合的方法，用來新增元素。

**語法：**
```
集合名稱.add(元素)
```

**為什麼叫 add？**
`add` 是「新增」的意思。

**注意：** 如果元素已存在，`add()` 不會出錯，但也不會新增（因為集合不重複）。

## 檢查收集進度

**為什麼用 len()？**
`len(集合)` 可以知道已經收集了多少個不同的贈品。

**語法：**
```
if len(collected) == 目標數量:
    print("Goal!")
    break
```

**為什麼用 break？**
因為已經達成目標，不需要繼續收集。

## 排序收集清單

**為什麼要排序？**
因為集合是無序的，排序後更容易閱讀。

**語法：**
```
sorted(集合)
```

**為什麼用 sorted()？**
`sorted()` 會回傳排序後的列表，不改變原集合。

## 實際範例

```
collected = set()
codes = ["A", "B", "A", "C", "B", "D", "E"]

for code in codes:
    if code in collected:
        print("Duplicate")
    else:
        collected.add(code)
        print("New")
    if len(collected) == 5:
        print("Goal!")
        break

print(sorted(collected))
```

**執行過程：**
1. 第一次：`code = "A"`，不在集合中 → 新增，印出 "New"，`collected = {"A"}`
2. 第二次：`code = "B"`，不在集合中 → 新增，印出 "New"，`collected = {"A", "B"}`
3. 第三次：`code = "A"`，已在集合中 → 印出 "Duplicate"，`collected = {"A", "B"}`
4. 第四次：`code = "C"`，不在集合中 → 新增，印出 "New"，`collected = {"A", "B", "C"}`
5. 第五次：`code = "B"`，已在集合中 → 印出 "Duplicate"
6. 第六次：`code = "D"`，不在集合中 → 新增，印出 "New"，`collected = {"A", "B", "C", "D"}`
7. 第七次：`code = "E"`，不在集合中 → 新增，印出 "New"，`collected = {"A", "B", "C", "D", "E"}`
8. 檢查：`len(collected) == 5` → `True`，印出 "Goal!"，`break`
9. 排序：`sorted(collected)` → `['A', 'B', 'C', 'D', 'E']`

**結果：**
```
New
New
Duplicate
New
Duplicate
New
New
Goal!
['A', 'B', 'C', 'D', 'E']
```

**記住：** 
- 用集合追蹤已收集的項目
- 使用 `in` 檢查是否已存在
- 使用 `add()` 新增元素
- 使用 `len()` 檢查進度
- 使用 `sorted()` 排序結果
""",
        "exercise": "請建立一個空集合 collected = set()，然後依序加入 'A', 'B', 'A', 'C'。\n每次加入時，如果是新的就印出「New」，如果是重複的就印出「Duplicate」。\n最後印出排序後的集合。",
        "hint": "使用 `in` 檢查是否已存在，使用 `add()` 新增。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "New\nNew\nDuplicate\nNew\n['A', 'B', 'C']\n"
        }
    },
    {
        "id": "PT9-2",
        "title": "員工程式語言專長登錄，判斷可否組成專案團隊",
        "explanation": """
## 為什麼用集合表示專長？

我們可以使用集合來表示每個員工的專長，然後檢查是否可以組成團隊。

**實際應用：**
- 專案團隊組成
- 技能匹配
- 人才搜尋

**為什麼用集合？**
- 專長可能有多個
- 集合可以快速檢查「是否包含某個技能」
- 集合運算可以找出「同時會多個技能的人」

## 字典的字典結構

**為什麼用字典？**
因為我們需要儲存「員工名稱 → 專長集合」的對應。

**語法：**
```
employee_skills = {
    "Alice": {"Python", "Java"},
    "Bob": {"Python", "C++"},
    "Charlie": {"Java", "JavaScript"}
}
```

**結構說明：**
- 外層字典：鍵是員工名稱，值是專長集合
- 內層集合：每個員工的專長列表

## 找出有特定專長的人

**為什麼需要這一步？**
因為我們要找出「會 Python 的人」和「會 Java 的人」，然後看是否有交集。

**簡化方法（不使用列表生成式）：**
```
python_people = set()
java_people = set()

for name, skills in employee_skills.items():
    if "Python" in skills:
        python_people.add(name)
    if "Java" in skills:
        java_people.add(name)
```

**執行邏輯：**
1. 遍歷每個員工和他們的專長
2. 如果專長包含 "Python"，將員工名稱加入 `python_people`
3. 如果專長包含 "Java"，將員工名稱加入 `java_people`

## 檢查交集

**為什麼檢查交集？**
因為交集表示「同時會 Python 和 Java 的人」。

**語法：**
```
if python_people & java_people:  # 交集不為空
    print("可以組成團隊")
```

**為什麼用 `&`？**
`&` 是集合的交集運算子，找出兩個集合都有的元素。

**為什麼檢查「不為空」？**
如果交集不為空，表示至少有一個人同時會 Python 和 Java。

## 實際範例

```
alice_skills = {'Python', 'Java'}
bob_skills = {'Python', 'C++'}

# 檢查是否有同時會 Python 和 Java 的員工
required_skills = {'Python', 'Java'}

# 檢查 Alice
if required_skills.issubset(alice_skills):
    print("可以組成團隊")
else:
    print("無法組成團隊")
```

**執行過程：**
1. `required_skills = {'Python', 'Java'}`（需要的技能）
2. 檢查 Alice：`required_skills.issubset(alice_skills)`
   - `{'Python', 'Java'}` 的所有元素都在 `{'Python', 'Java'}` 中
   - `True`
3. 印出：`可以組成團隊`

**簡化方法：**
```
alice_skills = {'Python', 'Java'}
required = {'Python', 'Java'}

if required.issubset(alice_skills):
    print("可以組成團隊")
```

**記住：** 
- 用字典儲存員工和專長
- 用集合表示專長列表
- 使用 `issubset()` 檢查是否包含所有需要的技能
- 使用交集找出同時會多個技能的人
""",
        "exercise": "有兩個員工專長集合：alice_skills = {'Python', 'Java'} 和 bob_skills = {'Python', 'C++'}。\n請檢查是否有同時會 Python 和 Java 的員工（檢查兩個集合的交集是否包含這兩個技能）。\n如果有，印出「可以組成團隊」，否則印出「無法組成團隊」。",
        "hint": "檢查交集是否同時包含 Python 和 Java。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "可以組成團隊\n"
        }
    },
    {
        "id": "HW9-1",
        "title": "班級成績統計",
        "explanation": """
## 為什麼需要複雜的資料結構？

我們可以結合列表和字典來進行複雜的成績統計。

**實際應用：**
- 班級成績管理
- 多科成績計算
- 學生資料處理

**為什麼用列表的字典？**
- 列表：儲存多個學生
- 字典：每個學生有多個屬性（姓名、成績）

## 資料結構

**語法：**
```
students = [
    {"name": "Alice", "scores": [85, 90, 88]},
    {"name": "Bob", "scores": [75, 80, 82]},
    {"name": "Charlie", "scores": [92, 88, 90]}
]
```

**結構說明：**
- 外層列表：每個元素是一個學生（字典）
- 內層字典：`"name"` 是姓名，`"scores"` 是成績列表
- 成績列表：該學生的各科成績

**視覺化：**
```
students = [
    {                    # 學生 0
        "name": "Alice",
        "scores": [85, 90, 88]  # 三科成績
    },
    {                    # 學生 1
        "name": "Bob",
        "scores": [75, 80, 82]
    },
    ...
]
```

## 存取資料

**為什麼用字典的鍵？**
因為字典用「鍵」來存取「值」，比索引更清楚。

**語法：**
```
student["name"]    # 取得姓名
student["scores"] # 取得成績列表
```

**為什麼用方括號？**
就像列表用索引一樣，字典用鍵來存取值。

## 計算平均

**為什麼用 sum() 和 len()？**
因為成績列表可能有多個元素，用內建函式更方便。

**語法：**
```
avg = sum(student["scores"]) / len(student["scores"])
```

**執行邏輯：**
1. `student["scores"]` → 取得成績列表
2. `sum(...)` → 計算總分
3. `len(...)` → 計算科目數
4. 總分 ÷ 科目數 = 平均

## 實際範例

```
students = [
    {"name": "Alice", "scores": [85, 90]},
    {"name": "Bob", "scores": [75, 80]}
]

for student in students:
    avg = sum(student["scores"]) / len(student["scores"])
    print(student["name"], "平均：", avg)
```

**執行過程：**
1. 第一次：`student = {"name": "Alice", "scores": [85, 90]}`
   - `sum([85, 90]) = 175`
   - `len([85, 90]) = 2`
   - `avg = 175 / 2 = 87.5`
   - 印出：`Alice 平均： 87.5`
2. 第二次：`student = {"name": "Bob", "scores": [75, 80]}`
   - `sum([75, 80]) = 155`
   - `len([75, 80]) = 2`
   - `avg = 155 / 2 = 77.5`
   - 印出：`Bob 平均： 77.5`

**結果：**
```
Alice 平均： 87.5
Bob 平均： 77.5
```

**記住：** 
- 列表的字典：列表儲存多個字典
- 使用 `student["name"]` 和 `student["scores"]` 存取資料
- 使用 `sum()` 和 `len()` 計算平均
""",
        "exercise": "有一個學生列表 students = [{'name': 'Alice', 'scores': [85, 90]}, {'name': 'Bob', 'scores': [75, 80]}]。\n請計算每個學生的平均成績並印出（格式：Alice 平均：87.5）。",
        "hint": "使用迴圈遍歷每個學生，計算平均。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "Alice 平均： 87.5\nBob 平均： 77.5\n"
        }
    },
    {
        "id": "HW9-2",
        "title": "電腦擇友",
        "explanation": """
## 為什麼用集合找共同興趣？

我們可以使用集合來找出共同興趣，這是集合的實際應用。

**實際應用：**
- 社交配對
- 興趣匹配
- 共同點分析

**為什麼用集合？**
- 集合的交集運算可以快速找出共同元素
- 集合自動去重，不會重複計算

## 計算交集

**什麼是交集？**
交集是兩個集合中「共同」的元素。

**語法：**
```
common = 集合1 & 集合2
```

**為什麼用 `&`？**
`&` 是集合的交集運算子，找出兩個集合都有的元素。

## 判斷標準

**為什麼用 `>= 2`？**
因為我們設定「共同興趣 >= 2 個」才適合做朋友。

**語法：**
```
if len(common) >= 2:
    print("適合做朋友")
else:
    print("不太適合")
```

**為什麼用 len()？**
`len(集合)` 可以知道集合中有多少個元素（共同興趣的數量）。

## 實際範例

```
person1_interests = {"reading", "music", "sports"}
person2_interests = {"music", "travel", "sports"}

common = person1_interests & person2_interests
if len(common) >= 2:
    print("適合做朋友")
else:
    print("不太適合")
```

**執行過程：**
1. 計算交集：`{"reading", "music", "sports"} & {"music", "travel", "sports"}`
   - "reading"：只在 person1 中 ✗
   - "music"：兩者都有 ✓
   - "sports"：兩者都有 ✓
   - "travel"：只在 person2 中 ✗
   - 交集：`{"music", "sports"}`
2. 計算數量：`len({"music", "sports"}) = 2`
3. 判斷：`2 >= 2` → `True`
4. 印出：`適合做朋友`

**結果：** `適合做朋友`

**如果共同興趣只有 1 個：**
```
person1 = {"reading", "music"}
person2 = {"music", "travel"}
common = {"music"}
len(common) = 1
1 >= 2 → False
印出：不太適合
```

**記住：** 
- 使用 `&` 計算交集
- 使用 `len()` 計算共同興趣數量
- 根據數量判斷是否適合
""",
        "exercise": "有兩個人的興趣集合：person1 = {'reading', 'music', 'sports'} 和 person2 = {'music', 'travel', 'sports'}。\n請找出共同興趣，如果共同興趣 >= 2 個，印出「適合做朋友」，否則印出「不太適合」。",
        "hint": "計算交集的大小。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "適合做朋友\n"
        }
    },
    
    # ========== 第八章：函數 (Function) ==========
    {
        "id": "EX10-0",
        "title": "function: default argument。判斷是否及格",
        "explanation": """
## 為什麼需要函數？

函數（Function）可以讓我們將程式碼組織成可重複使用的區塊。

**沒有函數的問題：**
每次要判斷是否及格，都要寫一次 `if-else`，程式碼會重複。

**使用函數：**
寫一次函數，之後就可以重複使用，而且程式碼更清楚！

## 定義函數

**語法：**
```
def 函數名稱(參數1, 參數2=預設值):
    # 函數內容
    return 結果
```

**為什麼用 def？**
`def` 是 "define"（定義）的縮寫，表示「定義一個函數」。

**為什麼需要 return？**
`return` 用來回傳結果，讓呼叫函數的地方可以取得結果。

## 預設參數（Default Argument）

**什麼是預設參數？**
預設參數是「有預設值」的參數，如果呼叫時沒有提供，就使用預設值。

**為什麼需要預設參數？**
因為有些參數有常用的值，設定預設值可以讓呼叫更方便。

**語法：**
```
def 函數名稱(參數1, 參數2=預設值):
```

**為什麼預設參數在後面？**
因為 Python 需要知道哪些參數有預設值，所以預設參數必須放在沒有預設值的參數後面。

## 實際範例

```
def check_pass(score, passing=60):
    if score >= passing:
        return "及格"
    else:
        return "不及格"
```

**參數說明：**
- `score`：學生成績（必須提供）
- `passing=60`：及格分數（預設 60，可以不提供）

## 呼叫函數

### 使用預設值

```
print(check_pass(70))
```

**執行過程：**
1. 呼叫 `check_pass(70)`
2. `score = 70`，`passing = 60`（使用預設值）
3. `70 >= 60` → `True`
4. 回傳 `"及格"`
5. 印出：`及格`

### 使用自訂值

```
print(check_pass(50, 70))
```

**執行過程：**
1. 呼叫 `check_pass(50, 70)`
2. `score = 50`，`passing = 70`（使用自訂值）
3. `50 >= 70` → `False`
4. 回傳 `"不及格"`
5. 印出：`不及格`

## 預設參數的優點

**為什麼用預設參數？**
1. **方便**：大多數情況用預設值，不需要每次都提供
2. **靈活**：特殊情況可以自訂值
3. **清楚**：函數定義就說明了預設行為

**記住：** 
- `def` 定義函數
- `return` 回傳結果
- 預設參數用 `參數=預設值`
- 預設參數必須在後面
- 呼叫時可以不提供預設參數
""",
        "exercise": "請定義一個函數 `check_pass(score, passing=60)`，如果 `score >= passing` 就回傳「及格」，否則回傳「不及格」。\n然後呼叫 `check_pass(70)` 並印出結果。",
        "hint": "使用 `def` 定義函數，使用 `return` 回傳值。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "及格\n"
        }
    },
    {
        "id": "EX10-1",
        "title": "function bigger()。印出一年四季的最大產量",
        "explanation": """
## 為什麼需要比較函數？

函數可以接受多個參數並進行比較。建立一個「比較兩個數」的函數，可以讓我們重複使用這個邏輯。

**沒有函數的問題：**
每次要比較兩個數，都要寫一次 `if-else`，程式碼會重複。

**使用函數：**
寫一次比較函數，之後就可以重複使用！

## 建立比較函數

### bigger() 函數

**作用：** 比較兩個數，回傳較大的數

**語法：**
```
def bigger(a, b):
    if a > b:
        return a
    else:
        return b
```

**執行邏輯：**
1. 如果 `a > b` → 回傳 `a`
2. 否則 → 回傳 `b`

**為什麼需要 else？**
因為如果 `a` 不大於 `b`，那麼 `b` 就是較大的（或相等，但我們回傳 `b`）。

## 組合函數

**為什麼可以組合函數？**
函數可以呼叫其他函數！這讓我們可以建立更複雜的功能。

### max_of_four() 函數

**作用：** 找出四個數中的最大值

**策略：**
1. 先比較前兩個數，找出較大的
2. 再比較後兩個數，找出較大的
3. 最後比較這兩個結果，找出最大的

**語法：**
```
def max_of_four(a, b, c, d):
    return bigger(bigger(a, b), bigger(c, d))
```

**執行過程：**
1. `bigger(a, b)` → 假設回傳 `a`（如果 a > b）
2. `bigger(c, d)` → 假設回傳 `d`（如果 d > c）
3. `bigger(結果1, 結果2)` → 比較 `a` 和 `d`，回傳較大的

**為什麼這樣可以找到最大值？**
因為我們先找出「前兩個的最大值」和「後兩個的最大值」，然後再找出「這兩個最大值的最大值」，就是四個數的最大值！

## 實際範例

```
def bigger(a, b):
    if a > b:
        return a
    else:
        return b

def max_of_four(a, b, c, d):
    return bigger(bigger(a, b), bigger(c, d))

q1, q2, q3, q4 = 100, 150, 120, 180
max_production = max_of_four(q1, q2, q3, q4)
print(max_production)
```

**執行過程：**
1. `bigger(100, 150)` → 回傳 150
2. `bigger(120, 180)` → 回傳 180
3. `bigger(150, 180)` → 回傳 180
4. 印出 180

**記住：** 函數可以呼叫其他函數，讓我們可以建立複雜的功能！
""",
        "exercise": "請定義一個函數 `bigger(a, b)`，回傳較大的數。\n然後定義 `max_four(a, b, c, d)`，使用 `bigger` 函數找出四個數中的最大值。\n最後呼叫 `max_four(10, 20, 15, 25)` 並印出結果。",
        "hint": "使用 `bigger` 函數來比較兩組數，然後再比較結果。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "25\n"
        }
    },
    {
        "id": "EX10-2",
        "title": "function improve [Ex9-2] (英數及格)",
        "explanation": """
## 為什麼要將程式碼改寫成函數？

我們可以將之前的程式碼改寫成函數，讓它更容易重複使用。

**沒有函數的問題：**
每次要找出兩科都及格的學生，都要寫一次 `english_pass & math_pass`，程式碼會重複。

**使用函數：**
寫一次函數，之後就可以重複使用，而且程式碼更清楚！

## 建立函數

**語法：**
```
def both_pass(english_pass, math_pass):
    return english_pass & math_pass
```

**函數名稱：** `both_pass`（兩科都及格）

**參數：**
- `english_pass`：英文及格的學生集合
- `math_pass`：數學及格的學生集合

**回傳值：** 兩個集合的交集（兩科都及格的學生）

**為什麼用 `&`？**
`&` 是集合的交集運算子，找出兩個集合都有的元素。

## 實際範例

```
def both_pass(english_pass, math_pass):
    return english_pass & math_pass

english_set = {1, 3, 5, 7}
math_set = {2, 3, 5, 6}
result = both_pass(english_set, math_set)
print(result)
```

**執行過程：**
1. 定義函數 `both_pass`
2. 建立兩個集合：
   - `english_set = {1, 3, 5, 7}`（英文及格）
   - `math_set = {2, 3, 5, 6}`（數學及格）
3. 呼叫函數：`both_pass(english_set, math_set)`
   - 計算交集：`{1, 3, 5, 7} & {2, 3, 5, 6} = {3, 5}`
   - 回傳 `{3, 5}`
4. 印出結果：`{3, 5}`

**結果：** `{3, 5}`（座號 3 和 5 的學生兩科都及格）

## 函數的優點

**為什麼要用函數？**
1. **重複使用**：一次定義，多次使用
2. **程式碼清晰**：函數名稱說明功能
3. **易於維護**：修改時只需改一處
4. **模組化**：將複雜問題分解

**記住：** 
- 將重複的程式碼改寫成函數
- 函數名稱要清楚說明功能
- 使用集合運算子 `&` 計算交集
""",
        "exercise": "請定義一個函數 `both_pass(eng_set, math_set)`，回傳兩個集合的交集（兩科都及格的學生）。\n然後呼叫 `both_pass({1, 3, 5}, {2, 3, 5})` 並印出結果。",
        "hint": "使用 `&` 運算子計算交集。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "{3, 5}\n"
        }
    },
    {
        "id": "EX10-3",
        "title": "計算長方形的面積及周長：function return (回傳多個值)",
        "explanation": """
## 為什麼需要回傳多個值？

有時候我們需要從函數取得多個結果，例如同時計算面積和周長。

**沒有多值回傳的問題：**
需要呼叫函數兩次，或者建立兩個不同的函數，程式碼會重複。

**使用多值回傳：**
一次呼叫就可以取得多個結果！

## Python 的多值回傳

**重要概念：** Python 函數可以回傳多個值（實際上是一個元組）。

**為什麼是元組？**
因為元組可以同時儲存多個值，而且順序固定，適合用來回傳「一組相關的結果」。

**語法：**
```
return 值1, 值2, 值3, ...
```

**實際上：** `return 值1, 值2` 等同於 `return (值1, 值2)`，Python 會自動包裝成元組。

## 解包（Unpacking）

**什麼是解包？**
解包就是將元組中的值分別賦值給多個變數。

**語法：**
```
變數1, 變數2 = 函數()
```

**為什麼需要解包？**
因為函數回傳的是一個元組，如果我們想要分別使用每個值，就需要解包。

**類比：** 就像您收到一個包裹（元組），裡面有兩個東西，您需要「拆開包裹」才能分別使用。

## 實際範例

```
def rectangle_info(width, height):
    area = width * height
    perimeter = 2 * (width + height)
    return area, perimeter

a, p = rectangle_info(5, 3)
print("面積：", a)
print("周長：", p)
```

**執行過程：**
1. 呼叫 `rectangle_info(5, 3)`
2. 計算：`area = 5 * 3 = 15`
3. 計算：`perimeter = 2 * (5 + 3) = 16`
4. 回傳：`(15, 16)`（元組）
5. 解包：`a = 15`, `p = 16`
6. 印出面積和周長

**如果不解包會怎樣？**
```
result = rectangle_info(5, 3)
print(result)  # 會印出 (15, 16)，是一個元組
```

**記住：** 
- 回傳多個值時，用逗號分隔
- 接收多個值時，用多個變數解包
- 順序很重要！第一個變數對應第一個回傳值
""",
        "exercise": "請定義一個函數 `rect_info(width, height)`，回傳面積和周長（按此順序）。\n然後呼叫 `rect_info(4, 6)`，將結果解包到 `area` 和 `perimeter`，並分別印出（先面積，後周長）。",
        "hint": "使用 `return area, perimeter` 回傳兩個值。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "24\n20\n"
        }
    },
    {
        "id": "EX10-4",
        "title": "function chr() & ord() & 字串相連",
        "explanation": """
## chr() 和 ord() 函式

`chr()` 和 `ord()` 是 Python 內建函數，用來處理字元和 ASCII 碼。

**為什麼需要這兩個函式？**
因為有時候我們需要在字元和數字之間轉換，例如生成字母序列。

### ord() - 字元轉數字

```
ord('A')  # 回傳 65
```

**作用：** 將字元轉換為對應的 ASCII 碼（數字）

**為什麼叫 ord？**
ord 是 "ordinal"（序數）的縮寫，表示字元的順序編號。

### chr() - 數字轉字元

```
chr(65)  # 回傳 'A'
```

**作用：** 將 ASCII 碼（數字）轉換為對應的字元

**為什麼叫 chr？**
chr 是 "character"（字元）的縮寫。

**配對使用：**
- `ord()` 和 `chr()` 是互逆的
- `chr(ord('A'))` = 'A'
- `ord(chr(65))` = 65

## 字串相連

**為什麼需要字串相連？**
有時候我們需要將多個字串組合成一個。

**語法：**
```
字串1 + 字串2
```

**為什麼用 `+`？**
在 Python 中，`+` 運算子可以連接字串，就像數學的加法一樣。

**注意：** 字串和數字不能直接相加！需要先轉換。

**範例：**
```
str1 = "Hello"
str2 = "World"
result = str1 + " " + str2  # "Hello World"
```

**執行過程：**
1. `str1 + " "` → "Hello "
2. `"Hello " + str2` → "Hello World"

## 建立字串處理函數

**為什麼需要函數？**
將字串處理邏輯封裝成函數，可以重複使用。

**範例：生成字元範圍**
```
def char_range(start, end):
    result = ""
    for i in range(ord(start), ord(end) + 1):
        result = result + chr(i)
    return result
```

**執行邏輯：**
1. 將起始字元轉為 ASCII 碼
2. 將結束字元轉為 ASCII 碼
3. 用迴圈從起始到結束，將每個 ASCII 碼轉回字元
4. 用 `+` 連接所有字元

**為什麼 `ord(end) + 1`？**
因為 `range()` 是「左閉右開」，所以需要 +1 才能包含結束字元。

## 實際範例

```
def char_string(start, end):
    result = ""
    for i in range(ord(start), ord(end) + 1):
        result = result + chr(i)
    return result

print(char_string('A', 'D'))
```

**執行過程：**
1. `ord('A')` = 65，`ord('D')` = 68
2. `range(65, 69)` → 65, 66, 67, 68
3. 迴圈：
   - `chr(65)` = 'A'，`result = "" + "A" = "A"`
   - `chr(66)` = 'B'，`result = "A" + "B" = "AB"`
   - `chr(67)` = 'C'，`result = "AB" + "C" = "ABC"`
   - `chr(68)` = 'D'，`result = "ABC" + "D" = "ABCD"`
4. 回傳 "ABCD"

**結果：** `ABCD`

**記住：** 
- `ord()` 字元 → 數字
- `chr()` 數字 → 字元
- 字串用 `+` 連接
- `range()` 是左閉右開，所以結束值要 +1
""",
        "exercise": "請定義一個函數 `char_string(start, end)`，回傳從 `start` 到 `end` 的所有字元連接成的字串。\n然後呼叫 `char_string('A', 'D')` 並印出結果。",
        "hint": "使用 `ord()` 和 `chr()`，用迴圈建立字串。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "ABCD\n"
        }
    },
    {
        "id": "EX10-5A",
        "title": "Local variable vs. Global variable",
        "explanation": """
## 什麼是變數的作用域？

變數的**作用域（scope）**決定了變數在哪裡可以被存取。

**為什麼需要作用域？**
作用域可以：
- 避免變數名稱衝突
- 讓函數獨立運作，不會互相干擾
- 讓程式碼更容易理解和維護

**生活中的類比：**
- 全域變數 = 公共區域的東西（大家都可以用）
- 區域變數 = 私人房間的東西（只有房間裡的人可以用）

## 全域變數（Global Variable）

**什麼是全域變數？**
在**函數外**定義的變數，整個程式都可以存取。

**為什麼叫「全域」？**
因為它可以在程式的任何地方（包括函數內）被存取。

**範例：**
```
global_var = 10  # 全域變數（在函數外定義）
```

## 區域變數（Local Variable）

**什麼是區域變數？**
在**函數內**定義的變數，只在函數內有效。

**為什麼叫「區域」？**
因為它只能在定義它的函數內使用，函數外無法存取。

**範例：**
```
def my_function():
    local_var = 20  # 區域變數（在函數內定義）
```

## 存取規則

### 函數內可以存取全域變數

**為什麼可以？**
因為全域變數是「公開的」，函數內可以直接讀取。

```
global_var = 10  # 全域變數

def my_function():
    print(global_var)  # 可以存取全域變數 ✓
```

### 函數外無法存取區域變數

**為什麼不能？**
因為區域變數是「私有的」，只在函數內有效。

```
def my_function():
    local_var = 20  # 區域變數

my_function()
print(local_var)  # 錯誤！無法存取區域變數 ✗
```

## 實際範例

```
global_var = 10  # 全域變數

def my_function():
    local_var = 20  # 區域變數
    print(global_var)  # 可以存取全域變數
    print(local_var)   # 可以存取區域變數

my_function()
print(global_var)  # 可以存取
# print(local_var)  # 錯誤！無法存取區域變數
```

**執行過程：**
1. 定義全域變數 `global_var = 10`
2. 定義函數 `my_function()`
3. 呼叫函數：
   - 建立區域變數 `local_var = 20`
   - 印出全域變數：10
   - 印出區域變數：20
4. 函數結束，區域變數消失
5. 印出全域變數：10（仍然可以存取）
6. 嘗試印出區域變數：錯誤！

**記住：** 
- 全域變數：函數外定義，整個程式都可以存取
- 區域變數：函數內定義，只在函數內有效
- 函數內可以讀取全域變數，但函數外無法存取區域變數
""",
        "exercise": "有一個全域變數 `x = 100`。請定義一個函數 `test()`，在函數內建立一個區域變數 `x = 50`，然後印出區域變數 `x`。\n呼叫函數後，再印出全域變數 `x`。",
        "hint": "函數內的 `x` 是區域變數，不會影響全域變數。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "50\n100\n"
        }
    },
    {
        "id": "EX10-5B",
        "title": "Local variable vs. Global variable (修改全域變數)",
        "explanation": """
## 為什麼需要 global 關鍵字？

如果要在函數內**修改**全域變數，需要使用 `global` 關鍵字。

**為什麼不能直接修改？**
因為 Python 的設計哲學：函數應該盡量獨立，不應該隨意修改全域變數。使用 `global` 是「明確宣告」要修改全域變數。

**沒有 global 會怎樣？**
如果函數內有 `變數 = 值`，Python 會認為這是「建立新的區域變數」，而不是修改全域變數。

**錯誤範例：**
```
count = 0

def increment():
    count = count + 1  # 錯誤！Python 認為這是區域變數

increment()
print(count)  # 還是 0，沒有改變！
```

**為什麼會出錯？**
因為 Python 看到 `count = count + 1` 時，會認為 `count` 是區域變數，但右邊的 `count` 還沒定義，所以出錯！

## global 關鍵字

**語法：**
```
global 變數名稱
```

**作用：** 告訴 Python「這個變數是全域變數，我要修改它」。

**為什麼叫 global？**
`global` 是「全域」的意思，明確告訴 Python 要使用全域變數。

**使用規則：**
- `global` 必須在函數內使用
- `global` 必須在修改變數之前宣告
- 一個函數可以宣告多個全域變數

## 實際範例

```
count = 0  # 全域變數

def increment():
    global count  # 宣告要使用全域變數
    count = count + 1

increment()
print(count)  # 1
```

**執行過程：**
1. 定義全域變數 `count = 0`
2. 定義函數 `increment()`
3. 呼叫函數：
   - `global count` → 告訴 Python 使用全域變數
   - `count = count + 1` → 修改全域變數：0 + 1 = 1
4. 函數結束
5. 印出 `count`：1（全域變數已被修改）

**如果沒有 global：**
```
count = 0

def increment():
    count = count + 1  # 錯誤！UnboundLocalError

increment()
```

**記住：** 
- 修改全域變數必須使用 `global` 關鍵字
- `global` 必須在修改之前宣告
- 讀取全域變數不需要 `global`，但修改需要
""",
        "exercise": "有一個全域變數 `counter = 10`。請定義一個函數 `add_one()`，使用 `global` 關鍵字將 `counter` 加 1。\n呼叫函數後，印出 `counter` 的值。",
        "hint": "在函數內使用 `global counter` 來修改全域變數。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "11\n"
        }
    },
    {
        "id": "EX10-5C",
        "title": "Local variable vs. Global variable (複雜情況)",
        "explanation": """
## 同名變數的優先順序

當全域變數和區域變數**同名**時，函數內預設使用區域變數。

**為什麼會這樣？**
這是 Python 的設計：區域變數會「遮蔽」（shadow）全域變數，優先使用區域變數。

**生活中的類比：**
- 全域變數 = 公共區域的公告
- 區域變數 = 房間內的公告
- 如果您在房間內，會先看到房間內的公告（區域變數）

## 變數遮蔽（Variable Shadowing）

**什麼是遮蔽？**
區域變數「遮住」了全域變數，讓函數內看不到全域變數。

**為什麼需要遮蔽？**
讓函數可以獨立運作，不會被全域變數干擾。

## 實際範例

```
x = 100  # 全域變數

def test():
    x = 50  # 區域變數，遮蔽了全域變數
    print(x)  # 印出 50（區域變數）

test()
print(x)  # 印出 100（全域變數不變）
```

**執行過程：**
1. 定義全域變數 `x = 100`
2. 定義函數 `test()`
3. 呼叫函數：
   - 建立區域變數 `x = 50`（遮蔽全域變數）
   - 印出 `x`：50（使用區域變數）
4. 函數結束，區域變數消失
5. 印出 `x`：100（使用全域變數，未被修改）

**重要：** 區域變數不會影響全域變數！它們是兩個不同的變數，只是名稱相同。

## 如何存取被遮蔽的全域變數？

**如果要在函數內存取全域變數（而不是區域變數），需要使用 `global`：**

```
x = 100  # 全域變數

def test():
    global x  # 使用全域變數
    x = 50    # 修改全域變數
    print(x)  # 50

test()
print(x)  # 50（全域變數被修改了）
```

**記住：** 
- 同名時，區域變數優先
- 區域變數不會影響全域變數
- 要用 `global` 才能修改全域變數
""",
        "exercise": "有一個全域變數 `value = 200`。請定義一個函數 `modify()`，在函數內建立區域變數 `value = 300` 並印出。\n呼叫函數後，再印出全域變數 `value`。",
        "hint": "區域變數不會影響全域變數。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "300\n200\n"
        }
    },
    {
        "id": "EX10-5D",
        "title": "Local variable vs. Global variable (列表)",
        "explanation": """
## 可變物件 vs 不可變物件

對於**可變物件**（如列表、字典），即使不使用 `global`，也可以修改其內容，但不能重新賦值。

**什麼是可變物件？**
可以修改內容的物件，例如列表、字典、集合。

**什麼是不可變物件？**
不能修改內容的物件，例如數字、字串、元組。

## 為什麼列表可以修改？

**重要區別：**
- **修改內容**：`my_list.append(4)` → 不需要 `global`
- **重新賦值**：`my_list = [5, 6]` → 需要 `global` 或會建立區域變數

**為什麼修改內容不需要 global？**
因為 Python 看到 `my_list.append()` 時，會先找 `my_list` 這個變數。如果函數內沒有定義 `my_list`，就會使用全域的 `my_list`。

**為什麼重新賦值需要 global？**
因為 `my_list = [5, 6]` 是「賦值」，Python 會認為這是建立新的區域變數。

## 實際範例

### 修改內容（不需要 global）

```
my_list = [1, 2, 3]  # 全域變數

def modify_list():
    my_list.append(4)  # 可以修改內容 ✓

modify_list()
print(my_list)  # [1, 2, 3, 4]
```

**執行過程：**
1. 定義全域列表 `my_list = [1, 2, 3]`
2. 呼叫函數 `modify_list()`
3. `my_list.append(4)`：
   - Python 找不到區域變數 `my_list`
   - 使用全域變數 `my_list`
   - 修改列表內容
4. 印出：`[1, 2, 3, 4]`（全域列表被修改）

### 重新賦值（會建立區域變數）

```
my_list = [1, 2, 3]  # 全域變數

def modify_list():
    my_list = [5, 6]  # 這樣會建立新的區域變數 ✗

modify_list()
print(my_list)  # [1, 2, 3]（全域列表沒有改變）
```

**執行過程：**
1. 定義全域列表 `my_list = [1, 2, 3]`
2. 呼叫函數 `modify_list()`
3. `my_list = [5, 6]`：
   - Python 認為這是「賦值」
   - 建立新的區域變數 `my_list = [5, 6]`
   - 全域變數不受影響
4. 函數結束，區域變數消失
5. 印出：`[1, 2, 3]`（全域列表沒有改變）

## 如果要重新賦值

**需要使用 global：**
```
my_list = [1, 2, 3]

def modify_list():
    global my_list
    my_list = [5, 6]  # 修改全域變數 ✓

modify_list()
print(my_list)  # [5, 6]
```

**記住：** 
- 修改可變物件的內容：不需要 `global`
- 重新賦值可變物件：需要 `global`
- 不可變物件（數字、字串）：修改需要 `global`
""",
        "exercise": "有一個全域列表 `data = [10, 20]`。請定義一個函數 `add_item()`，在函數內使用 `data.append(30)` 新增元素。\n呼叫函數後，印出 `data`。",
        "hint": "可以直接修改列表內容，不需要 `global`。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "[10, 20, 30]\n"
        }
    },
    {
        "id": "PT10-1",
        "title": "員工程式語言專長登錄，以function方式",
        "explanation": """
## 為什麼要用函數管理員工專長？

我們可以將員工專長管理改寫成函數，讓程式碼更模組化、更容易維護。

**實際應用：**
- 員工管理系統
- 技能搜尋
- 資料庫操作

**為什麼不用直接操作？**
- 函數可以封裝邏輯，避免重複程式碼
- 函數可以驗證資料，確保正確性
- 函數可以重用，提高效率

## 全域字典

**為什麼用全域字典？**
因為多個函數需要共用同一個員工資料庫。

**語法：**
```
employees = {}
```

**為什麼在函數外定義？**
因為要在多個函數間共用，所以定義在函數外（全域變數）。

## 新增員工函數

**為什麼需要這個函數？**
因為新增員工的邏輯可能很複雜，封裝成函數更方便。

**語法：**
```
def add_employee(name, skills):
    employees[name] = skills
    return "已新增員工"
```

**執行邏輯：**
1. 接收員工名稱和專長集合
2. 將資料存入字典
3. 回傳確認訊息

**為什麼用 return？**
因為呼叫者可能想知道操作是否成功。

## 搜尋專長函數

**為什麼需要這個函數？**
因為搜尋邏輯可能很複雜，封裝成函數可以重用。

**語法：**
```
def find_skill(skill_name):
    result = []
    for name, skills in employees.items():
        if skill_name in skills:
            result.append(name)
    return result
```

**執行邏輯：**
1. 建立空列表儲存結果
2. 遍歷所有員工
3. 如果該員工有這個專長，將名稱加入列表
4. 回傳結果列表

**為什麼用 items()？**
因為需要同時取得員工名稱和專長集合。

## 實際範例

```
employees = {}

def add_employee(name, skills):
    employees[name] = skills
    return "已新增員工"

def find_skill(skill_name):
    result = []
    for name, skills in employees.items():
        if skill_name in skills:
            result.append(name)
    return result

add_employee("Alice", {"Python", "Java"})
add_employee("Bob", {"Python", "C++"})
print(find_skill("Python"))
```

**執行過程：**
1. 新增 Alice：`employees = {"Alice": {"Python", "Java"}}`
2. 新增 Bob：`employees = {"Alice": {"Python", "Java"}, "Bob": {"Python", "C++"}}`
3. 搜尋 "Python"：
   - 遍歷員工：
     - Alice：`"Python" in {"Python", "Java"}` → `True`，加入 "Alice"
     - Bob：`"Python" in {"Python", "C++"}` → `True`，加入 "Bob"
   - 結果：`["Alice", "Bob"]`

**結果：** `['Alice', 'Bob']`

**記住：** 
- 用函數封裝邏輯，提高重用性
- 使用全域字典儲存共用資料
- 函數可以回傳結果，讓呼叫者使用
- 函數讓程式碼更模組化、更容易維護
""",
        "exercise": "請定義一個函數 add_skill(employee_dict, name, skills)，將員工和專長加入字典。\n然後建立一個空字典 emps = {}，呼叫 add_skill(emps, 'Alice', {'Python'})，最後印出字典。",
        "hint": "在函數內修改字典。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "{'Alice': {'Python'}}\n"
        }
    },
    {
        "id": "PT10-2",
        "title": "進制轉換: 十進位轉十六進位",
        "explanation": """
## 為什麼需要進制轉換？

我們可以建立函數來進行進制轉換，這是程式設計中常見的需求。

**實際應用：**
- 顏色碼（RGB 轉十六進位）
- 記憶體位址
- 資料編碼

**為什麼要手動轉換？**
雖然 Python 有內建函式，但理解轉換過程有助於理解進制概念。

## 十六進位系統

**什麼是十六進位？**
十六進位使用 0-9 和 A-F 來表示數字，每位的權值是 16 的次方。

**十六進位字元：**
- 0-9：對應十進位的 0-9
- A-F：對應十進位的 10-15

**為什麼需要 A-F？**
因為一位數只能表示 0-15，需要 16 個符號。

## 轉換策略

**為什麼用除法和取餘數？**
因為我們要「從低位到高位」建立結果，每次取餘數得到最低位。

**步驟：**
1. 如果數字是 0，直接回傳 "0"
2. 重複以下步驟直到數字為 0：
   - 取餘數（得到最低位）
   - 將餘數對應到十六進位字元
   - 將字元加到結果前面
   - 除以 16（去掉最低位）

## 字串連接

**為什麼用 `hex_digits[remainder] + result`？**
因為我們要將新字元加到結果的「前面」（因為是從低位到高位建立）。

**語法：**
```
result = hex_digits[remainder] + result
```

**為什麼是「前面」？**
因為我們先得到最低位，然後是次低位，所以要從前面加。

## 實際範例

```
def decimal_to_hex(decimal):
    hex_digits = "0123456789ABCDEF"
    result = ""
    if decimal == 0:
        return "0"
    while decimal > 0:
        remainder = decimal % 16
        result = hex_digits[remainder] + result
        decimal = decimal // 16
    return result

print(decimal_to_hex(255))
```

**執行過程（255）：**
1. `decimal = 255`
2. 第一次：
   - `remainder = 255 % 16 = 15`
   - `hex_digits[15] = "F"`
   - `result = "F" + "" = "F"`
   - `decimal = 255 // 16 = 15`
3. 第二次：
   - `remainder = 15 % 16 = 15`
   - `hex_digits[15] = "F"`
   - `result = "F" + "F" = "FF"`
   - `decimal = 15 // 16 = 0`
4. 迴圈結束（`decimal = 0`）
5. 回傳 `"FF"`

**結果：** `FF`

**驗證：** `15 * 16 + 15 = 240 + 15 = 255` ✓

**記住：** 
- 使用除法和取餘數進行進制轉換
- 從低位到高位建立結果
- 將新字元加到結果前面
- 使用字串索引對應到十六進位字元
""",
        "exercise": "請定義一個函數 `dec_to_hex(n)`，將十進位數轉換為十六進位字串。\n然後呼叫 `dec_to_hex(16)` 並印出結果。",
        "hint": "使用除法和取餘數，將餘數對應到十六進位字元。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "10\n"
        }
    },
    {
        "id": "HW10-1",
        "title": "班級成績統計:以function方式，改寫[HW9-1]",
        "explanation": """
## 為什麼要用函數改寫？

我們可以將成績統計改寫成函數，讓程式碼更模組化、更容易重用。

**實際應用：**
- 程式碼重用
- 邏輯封裝
- 更容易測試和維護

**為什麼不用直接寫？**
- 函數可以重用，不需要重複寫相同的邏輯
- 函數可以測試，確保正確性
- 函數讓程式碼更清楚

## 計算平均函數

**為什麼要單獨寫一個函數？**
因為計算平均是常用的功能，單獨寫成函數可以重用。

**語法：**
```
def calculate_average(scores):
    return sum(scores) / len(scores)
```

**執行邏輯：**
1. 接收成績列表
2. 計算總分（`sum(scores)`）
3. 計算科目數（`len(scores)`）
4. 回傳平均（總分 ÷ 科目數）

**為什麼用 return？**
因為呼叫者需要取得平均分數。

## 統計函數

**為什麼需要這個函數？**
因為統計所有學生的邏輯可以封裝成一個函數。

**語法：**
```
def student_stats(students):
    for student in students:
        name = student["name"]
        avg = calculate_average(student["scores"])
        print(name, "平均：", avg)
```

**執行邏輯：**
1. 遍歷每個學生
2. 取得學生姓名和成績
3. 呼叫 `calculate_average()` 計算平均
4. 印出結果

**為什麼呼叫其他函數？**
因為函數可以呼叫其他函數，讓程式碼更模組化。

## 實際範例

```
def calculate_average(scores):
    return sum(scores) / len(scores)

def student_stats(students):
    for student in students:
        name = student["name"]
        avg = calculate_average(student["scores"])
        print(name, "平均：", avg)

students = [{"name": "Alice", "scores": [85, 90]}, {"name": "Bob", "scores": [75, 80]}]
student_stats(students)
```

**執行過程：**
1. 定義 `calculate_average()` 函數
2. 定義 `student_stats()` 函數
3. 建立學生列表
4. 呼叫 `student_stats(students)`：
   - 第一次：`student = {"name": "Alice", "scores": [85, 90]}`
     - `name = "Alice"`
     - `calculate_average([85, 90])` → `(85 + 90) / 2 = 87.5`
     - 印出：`Alice 平均： 87.5`
   - 第二次：`student = {"name": "Bob", "scores": [75, 80]}`
     - `name = "Bob"`
     - `calculate_average([75, 80])` → `(75 + 80) / 2 = 77.5`
     - 印出：`Bob 平均： 77.5`

**結果：**
```
Alice 平均： 87.5
Bob 平均： 77.5
```

**記住：** 
- 用函數封裝邏輯，提高重用性
- 函數可以呼叫其他函數
- 將常用功能寫成函數，方便重用
- 函數讓程式碼更模組化、更容易維護
""",
        "exercise": "請定義一個函數 calc_avg(scores)，計算平均分數。\n然後定義 print_stats(students)，對每個學生計算並印出平均。\n最後建立 students = [{'name': 'Alice', 'scores': [85, 90]}]，呼叫 print_stats(students)。",
        "hint": "使用 `sum()` 和 `len()` 計算平均。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "Alice 平均： 87.5\n"
        }
    },
    {
        "id": "HW10-2",
        "title": "計算日期差距：以function方式，改寫[HW5-2]",
        "explanation": """
## 為什麼要用函數改寫日期計算？

我們可以將日期計算改寫成函數，讓程式碼更模組化、更容易重用。

**實際應用：**
- 日期計算工具
- 程式碼重用
- 邏輯封裝

**為什麼不用直接寫？**
- 函數可以重用，不需要重複寫相同的邏輯
- 函數可以測試，確保正確性
- 函數讓程式碼更清楚

## 日期計算函數

**為什麼要寫成函數？**
因為日期計算的邏輯可能很複雜，封裝成函數更方便。

**語法：**
```
def days_between(month1, day1, month2, day2):
    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    days1 = sum(days_in_month[:month1-1]) + day1
    days2 = sum(days_in_month[:month2-1]) + day2
    return abs(days2 - days1)
```

**參數說明：**
- `month1, day1`：第一個日期
- `month2, day2`：第二個日期

**執行邏輯：**
1. 定義月份天數列表
2. 計算從年初到第一個日期的天數
3. 計算從年初到第二個日期的天數
4. 計算差值並取絕對值
5. 回傳結果

**為什麼用 return？**
因為呼叫者需要取得日期差。

## 實際範例

```
def days_between(month1, day1, month2, day2):
    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    days1 = sum(days_in_month[:month1-1]) + day1
    days2 = sum(days_in_month[:month2-1]) + day2
    return abs(days2 - days1)

result = days_between(3, 15, 5, 20)
print(result)
```

**執行過程：**
1. 呼叫 `days_between(3, 15, 5, 20)`
2. 計算第一個日期（3月15日）：
   - `days_in_month[:2] = [31, 28]`
   - `sum([31, 28]) = 59`
   - `days1 = 59 + 15 = 74`
3. 計算第二個日期（5月20日）：
   - `days_in_month[:4] = [31, 28, 31, 30]`
   - `sum([31, 28, 31, 30]) = 120`
   - `days2 = 120 + 20 = 140`
4. 計算差值：`abs(140 - 74) = 66`
5. 回傳 `66`
6. 印出：`66`

**結果：** `66`

**記住：** 
- 用函數封裝邏輯，提高重用性
- 函數可以接收多個參數
- 函數可以回傳結果
- 將常用功能寫成函數，方便重用
""",
        "exercise": "請定義一個函數 `date_diff(m1, d1, m2, d2)`，計算兩個日期之間的天數。\n月份天數：`days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]`。\n然後呼叫 `date_diff(3, 15, 5, 20)` 並印出結果。",
        "hint": "計算從年初到每個日期的天數，然後相減。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "66\n"
        }
    },
    {
        "id": "HW10-3",
        "title": "進制轉換: 十進位轉其他進位(2, 8, 16) (-1 for exit)",
        "explanation": """
## 為什麼需要通用進制轉換函數？

我們可以建立一個通用的進制轉換函數，可以轉換到任何進位（2、8、16等）。

**實際應用：**
- 多種進制轉換
- 程式碼重用
- 統一介面

**為什麼不用多個函數？**
因為轉換邏輯相同，只是進位不同，用一個函數加上參數更簡潔。

## 通用轉換策略

**為什麼用 base 參數？**
因為不同的進位只是除數不同，邏輯相同。

**語法：**
```
def convert_base(decimal, base):
    digits = "0123456789ABCDEF"
    if decimal == 0:
        return "0"
    result = ""
    while decimal > 0:
        remainder = decimal % base
        result = digits[remainder] + result
        decimal = decimal // base
    return result
```

**參數說明：**
- `decimal`：十進位數字
- `base`：目標進位（2、8、16等）

**執行邏輯：**
1. 如果數字是 0，直接回傳 "0"
2. 重複以下步驟直到數字為 0：
   - 取餘數（`decimal % base`）
   - 將餘數對應到字元（`digits[remainder]`）
   - 將字元加到結果前面
   - 除以進位（`decimal // base`）

## 字元對應表

**為什麼用字串？**
因為可以用索引來對應數字和字元。

**語法：**
```
digits = "0123456789ABCDEF"
```

**對應關係：**
- 0-9：對應 0-9
- 10-15：對應 A-F（用於十六進位）

**為什麼只到 F？**
因為十六進位只需要 16 個字元，但這個字串可以支援到十六進位。

## 實際範例

### 二進位轉換（base=2）

```
print(convert_base(10, 2))
```

**執行過程：**
1. `decimal = 10`, `base = 2`
2. 第一次：`10 % 2 = 0` → `digits[0] = "0"` → `result = "0"`, `decimal = 10 // 2 = 5`
3. 第二次：`5 % 2 = 1` → `digits[1] = "1"` → `result = "1" + "0" = "10"`, `decimal = 5 // 2 = 2`
4. 第三次：`2 % 2 = 0` → `digits[0] = "0"` → `result = "0" + "10" = "010"`, `decimal = 2 // 2 = 1`
5. 第四次：`1 % 2 = 1` → `digits[1] = "1"` → `result = "1" + "010" = "1010"`, `decimal = 1 // 2 = 0`
6. 迴圈結束，回傳 `"1010"`

**結果：** `1010`

### 八進位轉換（base=8）

```
print(convert_base(10, 8))
```

**執行過程：**
1. `decimal = 10`, `base = 8`
2. 第一次：`10 % 8 = 2` → `digits[2] = "2"` → `result = "2"`, `decimal = 10 // 8 = 1`
3. 第二次：`1 % 8 = 1` → `digits[1] = "1"` → `result = "1" + "2" = "12"`, `decimal = 1 // 8 = 0`
4. 迴圈結束，回傳 `"12"`

**結果：** `12`

### 十六進位轉換（base=16）

```
print(convert_base(10, 16))
```

**執行過程：**
1. `decimal = 10`, `base = 16`
2. 第一次：`10 % 16 = 10` → `digits[10] = "A"` → `result = "A"`, `decimal = 10 // 16 = 0`
3. 迴圈結束，回傳 `"A"`

**結果：** `A`

**記住：** 
- 使用 `base` 參數支援多種進位
- 轉換邏輯相同，只是除數不同
- 使用字串索引對應數字和字元
- 從低位到高位建立結果
""",
        "exercise": "請定義一個函數 `convert(n, base)`，將十進位數 `n` 轉換為 `base` 進位。\n然後分別呼叫 `convert(10, 2)`、`convert(10, 8)`、`convert(10, 16)` 並印出結果（每個一行）。",
        "hint": "使用除法和取餘數，將餘數對應到對應進位的字元。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "1010\n12\nA\n"
        }
    },
    {
        "id": "EX11-0A",
        "title": "function: 參數傳遞(mutable / immutable)",
        "explanation": """
## 為什麼需要了解參數傳遞？

Python 中的參數傳遞有兩種情況，理解這些差異很重要，因為它影響函數是否會修改原變數。

**實際應用：**
- 理解函數行為
- 避免意外修改
- 正確設計函數

## 不可變物件（Immutable）

**什麼是不可變？**
建立後不能修改的物件，例如數字、字串、元組。

**為什麼叫 immutable？**
`immutable` 是「不可變」的意思。

**參數傳遞方式：**
傳遞的是「值的複本」，函數內修改不會影響原變數。

**為什麼不會影響？**
因為不可變物件不能修改，函數內只能建立新的物件。

## 可變物件（Mutable）

**什麼是可變？**
建立後可以修改的物件，例如列表、字典、集合。

**為什麼叫 mutable？**
`mutable` 是「可變」的意思。

**參數傳遞方式：**
傳遞的是「參考」（reference），函數內修改會影響原物件。

**為什麼會影響？**
因為函數內和函數外指向同一個物件，修改會影響原物件。

## 實際範例

### 不可變物件

```
def modify_immutable(x):
    x = x + 1  # 不會影響原變數
    print("函數內：", x)

num = 10
modify_immutable(num)
print("函數外：", num)
```

**執行過程：**
1. `num = 10`（原變數）
2. 呼叫 `modify_immutable(10)`：
   - `x = 10`（參數，是值的複本）
   - `x = 10 + 1 = 11`（修改的是複本，不影響原變數）
   - 印出：`函數內： 11`
3. 印出：`函數外： 10`（原變數沒有改變）

**結果：**
```
函數內： 11
函數外： 10
```

### 可變物件

```
def modify_mutable(lst):
    lst.append(99)  # 會影響原列表
    print("函數內：", lst)

my_list = [1, 2, 3]
modify_mutable(my_list)
print("函數外：", my_list)
```

**執行過程：**
1. `my_list = [1, 2, 3]`（原列表）
2. 呼叫 `modify_mutable([1, 2, 3])`：
   - `lst` 指向同一個列表（參考）
   - `lst.append(99)` → 修改原列表
   - 印出：`函數內： [1, 2, 3, 99]`
3. 印出：`函數外： [1, 2, 3, 99]`（原列表被修改了）

**結果：**
```
函數內： [1, 2, 3, 99]
函數外： [1, 2, 3, 99]
```

## 如何避免意外修改？

**如果不想修改原列表：**
```
def modify_mutable(lst):
    new_lst = lst.copy()  # 複製列表
    new_lst.append(99)
    return new_lst
```

**記住：** 
- 不可變物件：函數內修改不會影響原變數
- 可變物件：函數內修改會影響原物件
- 如果不想修改原物件，需要先複製
""",
        "exercise": "有一個數字 `x = 100` 和一個列表 `lst = [1, 2]`。\n請定義一個函數 `test(a, b)`，將 `a` 加 10，將 `b` 新增元素 3。\n呼叫 `test(x, lst)` 後，分別印出 `x` 和 `lst`。",
        "hint": "數字不會改變，列表會改變。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "100\n[1, 2, 3]\n"
        }
    },
    {
        "id": "EX11-0B",
        "title": "mutable/immutable, identity",
        "explanation": """
## 什麼是物件身份（Identity）？

`id()` 函數可以取得物件的身份（記憶體位址），每個物件都有唯一的身份。

**實際應用：**
- 檢查兩個變數是否指向同一個物件
- 理解物件重用機制
- 除錯和優化

**為什麼需要身份？**
因為有時候我們需要知道兩個變數是否指向同一個物件，而不只是值是否相同。

## id() 函數

**什麼是 id()？**
`id()` 是 Python 的內建函數，回傳物件的唯一識別碼（通常是記憶體位址）。

**語法：**
```
id(物件)
```

**為什麼叫 id？**
`id` 是 "identifier"（識別碼）的縮寫，表示物件的唯一標識。

**回傳值：**
一個整數，代表物件的身份（每個物件都有唯一的身份）。

## 不可變物件的重用

**為什麼會重用？**
Python 會重用一些小的不可變物件（例如小整數、短字串），以節省記憶體。

**範例：**
```
a = 10
b = 10
print(id(a) == id(b))  # True
```

**執行過程：**
1. `a = 10` → Python 建立或重用整數 10 的物件
2. `b = 10` → Python 重用同一個整數 10 的物件（因為是小整數）
3. `id(a) == id(b)` → `True`（是同一個物件）

**為什麼會重用？**
因為小整數（通常是 -5 到 256）是常用的，Python 會預先建立並重用它們。

## 可變物件的獨立性

**為什麼不會重用？**
因為可變物件可以修改，如果重用會造成問題。

**範例：**
```
list1 = [1, 2, 3]
list2 = [1, 2, 3]
print(id(list1) == id(list2))  # False
```

**執行過程：**
1. `list1 = [1, 2, 3]` → Python 建立一個新的列表物件
2. `list2 = [1, 2, 3]` → Python 建立另一個新的列表物件
3. `id(list1) == id(list2)` → `False`（是不同的物件）

**為什麼不同？**
因為列表是可變的，如果重用，修改一個會影響另一個。

## is 運算子

**什麼是 is？**
`is` 運算子檢查兩個變數是否指向同一個物件（身份是否相同）。

**語法：**
```
變數1 is 變數2
```

**為什麼叫 is？**
`is` 是「是」的意思，表示「是同一個物件」。

**與 == 的差異：**
- `==`：檢查值是否相等
- `is`：檢查身份是否相同（是否同一個物件）

## 實際範例

### 不可變物件

```
a = 10
b = 10
print(a is b)  # True
print(id(a) == id(b))  # True
```

**結果：** `True`（是同一個物件）

### 可變物件

```
list1 = [1, 2]
list2 = [1, 2]
print(list1 is list2)  # False
print(id(list1) == id(list2))  # False
```

**結果：** `False`（是不同的物件）

**即使值相同，也是不同的物件！**

**記住：** 
- `id()` 取得物件的唯一身份
- 不可變物件可能被重用（小整數、短字串）
- 可變物件不會被重用
- `is` 檢查身份是否相同
- `==` 檢查值是否相等
""",
        "exercise": "有兩個列表 `a = [1, 2]` 和 `b = [1, 2]`。請檢查它們是否是同一個物件（使用 `is`），如果不是，印出「不同物件」。",
        "hint": "使用 `is` 運算子檢查身份。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "不同物件\n"
        }
    },
    {
        "id": "EX11-0C",
        "title": "硬做成call by reference的效果",
        "explanation": """
## 為什麼需要「傳參考」的效果？

雖然 Python 對於不可變物件是「傳值」，但我們可以透過回傳值或列表包裝來達到類似「傳參考」的效果。

**實際應用：**
- 需要修改不可變物件
- 模擬其他語言的傳參考行為
- 函數需要修改參數

**為什麼需要？**
因為有時候我們希望函數能夠修改不可變物件的值。

## 方法 1：使用回傳值

**為什麼用回傳值？**
因為函數不能直接修改不可變物件，但可以回傳新值，讓呼叫者更新。

**語法：**
```
def increment(x):
    return x + 1

num = 10
num = increment(num)  # 透過回傳值來更新
```

**執行邏輯：**
1. 呼叫 `increment(10)`
2. 函數計算 `10 + 1 = 11`
3. 回傳 `11`
4. 呼叫者將結果賦值給 `num`：`num = 11`

**為什麼有效？**
因為雖然函數內不能修改原變數，但可以回傳新值，讓呼叫者更新。

## 方法 2：使用列表包裝

**為什麼用列表包裝？**
因為列表是可變物件，函數內可以修改列表的元素。

**語法：**
```
def increment_wrapper(lst):
    lst[0] = lst[0] + 1

num_list = [10]
increment_wrapper(num_list)
print(num_list[0])
```

**執行邏輯：**
1. `num_list = [10]`（用列表包裝數字）
2. 呼叫 `increment_wrapper([10])`
3. 函數內修改列表元素：`lst[0] = 10 + 1 = 11`
4. 因為列表是可變物件，原列表被修改
5. `num_list[0] = 11`

**為什麼有效？**
因為列表是可變物件，函數內修改會影響原列表。

## 兩種方法的比較

### 方法 1：回傳值（推薦）

**優點：**
- 清楚明確
- 不改變原變數的型態
- 符合 Python 的慣例

**缺點：**
- 需要記得賦值

### 方法 2：列表包裝

**優點：**
- 函數內直接修改
- 類似其他語言的傳參考

**缺點：**
- 改變了變數的型態（從數字變成列表）
- 需要包裝和解包

## 實際範例

### 方法 1：回傳值

```
def increment(x):
    return x + 1

num = 10
num = increment(num)
print(num)  # 11
```

**結果：** `11`

### 方法 2：列表包裝

```
def increment_wrapper(lst):
    lst[0] = lst[0] + 1

num_list = [10]
increment_wrapper(num_list)
print(num_list[0])  # 11
```

**結果：** `11`

**記住：** 
- 不可變物件不能直接修改
- 使用回傳值讓呼叫者更新（推薦）
- 使用列表包裝可以達到傳參考的效果
- 回傳值方法更符合 Python 的慣例
""",
        "exercise": "有一個數字 `x = 50`。請定義一個函數 `double(n)`，回傳 `n * 2`。\n然後將 `x` 設為 `double(x)` 的結果，並印出 `x`。",
        "hint": "透過回傳值來更新變數。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "100\n"
        }
    },
    {
        "id": "EX11-1",
        "title": "String",
        "explanation": """
## 為什麼需要字串方法？

字串是 Python 中重要的資料型態，有許多內建方法可以處理字串。

**實際應用：**
- 文字處理
- 資料清理
- 格式轉換

**為什麼不用手動處理？**
因為字串方法已經實作好常用的功能，使用更方便、更安全。

## 常用字串方法

### upper() - 轉大寫

**作用：** 將字串中所有字母轉換為大寫

**語法：**
```
字串.upper()
```

**為什麼叫 upper？**
`upper` 是「上面的」意思，表示大寫字母。

**範例：**
```
text = "python"
print(text.upper())  # "PYTHON"
```

### lower() - 轉小寫

**作用：** 將字串中所有字母轉換為小寫

**語法：**
```
字串.lower()
```

**範例：**
```
text = "PYTHON"
print(text.lower())  # "python"
```

### strip() - 去除首尾空白

**作用：** 去除字串開頭和結尾的空白字元（空格、換行等）

**語法：**
```
字串.strip()
```

**為什麼需要 strip()？**
因為使用者輸入或檔案讀取時，常常會有額外的空白。

**範例：**
```
text = "  Hello World  "
print(text.strip())  # "Hello World"
```

### split() - 分割字串

**作用：** 根據分隔符號將字串分割成列表

**語法：**
```
字串.split(分隔符號)
```

**為什麼需要 split()？**
因為有時候我們需要將一個字串拆成多個部分。

**範例：**
```
text = "Hello World"
words = text.split()  # 預設用空格分割
print(words)  # ['Hello', 'World']
```

### join() - 連接字串

**作用：** 用指定的分隔符號連接列表中的字串

**語法：**
```
分隔符號.join(字串列表)
```

**為什麼叫 join？**
`join` 是「連接」的意思，將多個字串連接成一個。

**範例：**
```
words = ['Hello', 'World']
result = "-".join(words)
print(result)  # "Hello-World"
```

**注意：** `join()` 是字串的方法，不是列表的方法！

## 方法鏈接

**為什麼可以鏈接？**
因為字串方法回傳的還是字串，可以繼續呼叫其他方法。

**語法：**
```
字串.方法1().方法2()
```

**範例：**
```
text = "  Hello World  "
result = text.strip().upper()
print(result)  # "HELLO WORLD"
```

**執行過程：**
1. `text.strip()` → `"Hello World"`（去除空白）
2. `"Hello World".upper()` → `"HELLO WORLD"`（轉大寫）

## 實際範例

```
text = "python programming"
result = text.upper().split()
final = "-".join(result)
print(final)
```

**執行過程：**
1. `text.upper()` → `"PYTHON PROGRAMMING"`（轉大寫）
2. `"PYTHON PROGRAMMING".split()` → `['PYTHON', 'PROGRAMMING']`（分割）
3. `"-".join(['PYTHON', 'PROGRAMMING'])` → `"PYTHON-PROGRAMMING"`（連接）

**結果：** `PYTHON-PROGRAMMING`

**記住：** 
- 字串方法回傳新的字串，不改變原字串
- 可以鏈接多個方法
- `split()` 將字串分割成列表
- `join()` 將列表連接成字串
- `join()` 是字串的方法，不是列表的方法
""",
        "exercise": "有一個字串 text = 'python programming'。請將它轉換為大寫，然後用空格分割，最後用 '-' 連接並印出。",
        "hint": "使用 `upper()`, `split()`, `join()` 方法。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "PYTHON-PROGRAMMING\n"
        }
    },
    {
        "id": "EX11-2",
        "title": "Recursive function n!",
        "explanation": """
## 什麼是遞迴？

遞迴（Recursion）是函數**呼叫自己**的技術。

**為什麼需要遞迴？**
有些問題可以分解為「相同類型的子問題」，遞迴可以優雅地解決這類問題。

**生活中的類比：**
- 俄羅斯娃娃：大娃娃裡面有小娃娃，小娃娃裡面有更小的娃娃...
- 階乘：5! = 5 × 4!，4! = 4 × 3!，...直到 1! = 1

## 遞迴函數的兩個必要條件

### 1. 基本情況（Base Case）

**什麼是基本情況？**
這是遞迴的**停止條件**，當達到這個條件時，不再呼叫自己，直接回傳結果。

**為什麼需要基本情況？**
如果沒有基本情況，函數會無限呼叫自己，造成無限遞迴（類似無限迴圈）！

### 2. 遞迴情況（Recursive Case）

**什麼是遞迴情況？**
這是函數**呼叫自己**的部分，但參數要「更接近基本情況」。

**為什麼參數要更接近基本情況？**
這樣才能最終達到基本情況，停止遞迴。

## 階乘的遞迴定義

**什麼是階乘？**
n! = n × (n-1) × (n-2) × ... × 2 × 1

**遞迴思考：**
- 5! = 5 × 4!
- 4! = 4 × 3!
- 3! = 3 × 2!
- 2! = 2 × 1!
- 1! = 1（基本情況）

**函數定義：**
```
def factorial(n):
    if n == 0 or n == 1:  # 基本情況
        return 1
    else:  # 遞迴情況
        return n * factorial(n - 1)
```

**為什麼基本情況是 n == 0 或 n == 1？**
因為 0! = 1 和 1! = 1，這是數學定義，也是遞迴的終點。

## 執行過程

```
print(factorial(5))
```

**執行流程：**
1. `factorial(5)` → 5 > 1，進入遞迴情況
   - 計算：`5 * factorial(4)`
2. `factorial(4)` → 4 > 1，進入遞迴情況
   - 計算：`4 * factorial(3)`
3. `factorial(3)` → 3 > 1，進入遞迴情況
   - 計算：`3 * factorial(2)`
4. `factorial(2)` → 2 > 1，進入遞迴情況
   - 計算：`2 * factorial(1)`
5. `factorial(1)` → 1 == 1，進入基本情況
   - 回傳：`1`
6. 開始回傳：
   - `factorial(2)` = 2 × 1 = 2
   - `factorial(3)` = 3 × 2 = 6
   - `factorial(4)` = 4 × 6 = 24
   - `factorial(5)` = 5 × 24 = 120

**結果：** 120

## 遞迴的優缺點

**優點：**
- 程式碼簡潔優雅
- 符合問題的自然結構

**缺點：**
- 可能消耗較多記憶體（每次呼叫都會建立新的函數框架）
- 可能較慢（函數呼叫有開銷）

**記住：** 
- 遞迴必須有基本情況（停止條件）
- 遞迴情況的參數要更接近基本情況
- 沒有基本情況會造成無限遞迴！
""",
        "exercise": "請定義一個遞迴函數 `factorial(n)` 來計算 n 的階乘。\n然後呼叫 `factorial(5)` 並印出結果。",
        "hint": "基本情況：n <= 1 時回傳 1；遞迴情況：回傳 n * factorial(n-1)。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "120\n"
        }
    },
    {
        "id": "PT11-1",
        "title": "Recursive function: DecimalToHexadecimal",
        "explanation": """
## 為什麼要用遞迴改寫進制轉換？

我們可以用遞迴的方式來實現十進位轉十六進位，這展示了遞迴的另一種應用場景。

**實際應用：**
- 理解遞迴在進制轉換中的應用
- 比較遞迴和迴圈的實現方式
- 掌握遞迴的設計模式

**為什麼要改寫？**
因為遞迴可以更優雅地處理「分解問題」的過程，讓程式碼更簡潔。

## 遞迴思考方式

**如何用遞迴思考進制轉換？**
- 要轉換 n，先轉換 n // 16（高位部分）
- 然後加上當前位（n % 16）對應的字元
- 直到 n < 16（基本情況）

**遞迴分解：**
- `decimal_to_hex(255)` → `decimal_to_hex(15) + "F"` → `"F" + "F"` → `"FF"`
- `decimal_to_hex(16)` → `decimal_to_hex(1) + "0"` → `"1" + "0"` → `"10"`

## 遞迴函數設計

### 基本情況（Base Case）

**什麼是基本情況？**
當數字小於 16 時，可以直接對應到十六進位字元，不需要再遞迴。

**語法：**
```
if n == 0:
    return "0"
if n < 16:
    return hex_digits[n]
```

**為什麼需要兩個基本情況？**
- `n == 0`：特殊情況，直接回傳 "0"
- `n < 16`：可以直接對應到單個字元

### 遞迴情況（Recursive Case）

**什麼是遞迴情況？**
當 n >= 16 時，需要先處理高位（n // 16），然後加上當前位（n % 16）。

**語法：**
```
return decimal_to_hex(n // 16) + hex_digits[n % 16]
```

**為什麼這樣寫？**
- `n // 16`：取得高位部分（更接近基本情況）
- `n % 16`：取得當前位（0-15）
- `hex_digits[n % 16]`：將當前位轉換為十六進位字元
- 將高位結果和當前位字元連接

## 完整函數

```
def decimal_to_hex(n):
    hex_digits = "0123456789ABCDEF"
    if n == 0:
        return "0"
    if n < 16:
        return hex_digits[n]
    return decimal_to_hex(n // 16) + hex_digits[n % 16]
```

## 執行過程

### 範例 1：decimal_to_hex(16)

**執行流程：**
1. `decimal_to_hex(16)` → 16 >= 16，進入遞迴情況
   - 計算：`decimal_to_hex(16 // 16) + hex_digits[16 % 16]`
   - = `decimal_to_hex(1) + hex_digits[0]`
2. `decimal_to_hex(1)` → 1 < 16，進入基本情況
   - 回傳：`hex_digits[1] = "1"`
3. 回傳：`"1" + "0" = "10"`

**結果：** `"10"`

### 範例 2：decimal_to_hex(255)

**執行流程：**
1. `decimal_to_hex(255)` → 255 >= 16
   - `decimal_to_hex(15) + "F"`
2. `decimal_to_hex(15)` → 15 < 16
   - 回傳：`"F"`
3. 回傳：`"F" + "F" = "FF"`

**結果：** `"FF"`

## 遞迴 vs 迴圈

**遞迴版本：**
```
def decimal_to_hex(n):
    if n == 0:
        return "0"
    if n < 16:
        return hex_digits[n]
    return decimal_to_hex(n // 16) + hex_digits[n % 16]
```

**迴圈版本（PT10-2）：**
```
def decimal_to_hex(n):
    result = ""
    if n == 0:
        return "0"
    while n > 0:
        result = hex_digits[n % 16] + result
        n = n // 16
    return result
```

**比較：**
- 遞迴：程式碼更簡潔，邏輯更直觀
- 迴圈：效率更高，記憶體使用更少

**記住：** 
- 遞迴的基本情況：n == 0 或 n < 16
- 遞迴情況：先處理高位（n // 16），再處理當前位（n % 16）
- 遞迴可以優雅地解決進制轉換問題
- 遞迴和迴圈可以互相改寫
""",
        "exercise": "請用遞迴方式定義一個函數 `dec_to_hex(n)`，將十進位數轉換為十六進位字串。\n然後呼叫 `dec_to_hex(16)` 並印出結果。",
        "hint": "基本情況：n == 0 回傳 \"0\"，n < 16 回傳對應字元；遞迴情況：回傳 dec_to_hex(n // 16) + 當前位字元。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "10\n",
            "code_requirements": {
                "requires_function": True,
                "forbids_hardcode": True
            }
        }
    },
    {
        "id": "HW11",
        "title": "函數綜合應用：參數傳遞、字串處理與遞迴",
        "explanation": """
## 為什麼需要綜合應用？

這個作業整合了函數的多個重要概念：參數傳遞（mutable/immutable）、字串處理和遞迴函數。

**實際應用：**
- 理解函數的參數傳遞機制
- 掌握字串的常用方法
- 運用遞迴解決問題

**為什麼要綜合練習？**
因為實際程式開發中，這些概念經常會一起使用。

## 本作業涵蓋的概念

### 1. 參數傳遞（Mutable / Immutable）

**不可變物件（Immutable）：**
- 數字、字串、元組
- 函數內修改不會影響原變數

**可變物件（Mutable）：**
- 列表、字典、集合
- 函數內修改會影響原物件

### 2. 字串處理

**常用方法：**
- `upper()`：轉大寫
- `lower()`：轉小寫
- `strip()`：去除首尾空白
- `split()`：分割字串
- `join()`：連接字串

### 3. 遞迴函數

**遞迴的兩個必要條件：**
- 基本情況（Base Case）：停止條件
- 遞迴情況（Recursive Case）：呼叫自己

## 實際範例

結合這些概念，我們可以建立更強大的函數：

```
def process_text(text, words_list):
    # 字串處理
    text = text.strip().upper()
    words = text.split()
    
    # 可變物件會被修改
    words_list.extend(words)
    
    return len(words)

def count_chars(text, n):
    # 遞迴計算字元數
    if n == 0:
        return 0
    return 1 + count_chars(text, n - 1)

# 使用範例
my_list = []
result = process_text("  hello world  ", my_list)
print(result)  # 2
print(my_list)  # ['HELLO', 'WORLD']（被修改了）
```

**記住：** 
- 理解 mutable/immutable 的差異
- 熟練使用字串方法
- 掌握遞迴的設計原則
- 綜合運用這些概念解決實際問題
""",
        "exercise": "請定義一個函數 `process_and_count(text, result_list)`：\n1. 將 `text` 轉換為大寫並去除首尾空白\n2. 用空格分割成單詞列表\n3. 將單詞列表加入到 `result_list`（可變物件會被修改）\n4. 回傳單詞數量\n\n然後定義一個遞迴函數 `factorial(n)` 計算階乘。\n\n最後執行：\n```\ntext = '  python programming  '\nwords = []\ncount = process_and_count(text, words)\nprint(count)\nprint(words)\nprint(factorial(3))\n```",
        "hint": "結合字串處理、可變物件修改和遞迴函數。",
        "validator": {
            "type": "stdout_equals",
            "expected_output": "2\n['PYTHON', 'PROGRAMMING']\n6\n",
            "code_requirements": {
                "requires_function": True,
                "requires_loop": False,
                "forbids_hardcode": True
            }
        }
    }
]

