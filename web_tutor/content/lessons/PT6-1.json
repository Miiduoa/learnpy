{
  "id": "PT6-1",
  "title": "調整成績(float)",
  "explanation": "\n## 為什麼用二維陣列儲存成績？\n\n我們可以使用二維陣列來儲存多個學生的多科成績。\n\n**實際應用：**\n- 儲存班級成績表\n- 管理多科成績\n- 進行成績調整\n\n**結構說明：**\n- 外層列表：每個元素代表一個學生\n- 內層列表：每個元素代表該學生的一科成績\n\n## 理解索引\n\n**範例：**\n```\nscores = [[85.5, 90.0], [75.5, 80.0], [92.0, 88.5]]\n```\n\n**索引說明：**\n- `scores[0]` → 第一個學生的成績 `[85.5, 90.0]`\n- `scores[0][0]` → 第一個學生的第一科成績 `85.5`\n- `scores[1][1]` → 第二個學生的第二科成績 `80.0`\n\n**視覺化：**\n```\nscores = [\n    [85.5, 90.0],  # 學生 0：科目 0=85.5, 科目 1=90.0\n    [75.5, 80.0],  # 學生 1：科目 0=75.5, 科目 1=80.0\n    [92.0, 88.5]   # 學生 2：科目 0=92.0, 科目 1=88.5\n]\n```\n\n## 批量調整成績\n\n**為什麼需要巢狀迴圈？**\n因為要遍歷所有學生和所有科目。\n\n**語法：**\n```\nfor i in range(len(scores)):        # 遍歷每個學生\n    for j in range(len(scores[i])): # 遍歷該學生的每科\n        scores[i][j] = scores[i][j] * 1.1  # 調整成績\n```\n\n**為什麼用 `len(scores)`？**\n`len(scores)` 是學生的數量（行數）。\n\n**為什麼用 `len(scores[i])`？**\n`len(scores[i])` 是第 i 個學生的科目數量（列數）。\n\n## 四捨五入：round() 函式\n\n**為什麼需要 round()？**\n因為成績調整後可能變成小數，需要四捨五入到整數。\n\n**語法：**\n```\nround(數字)\n```\n\n**為什麼叫 round？**\n`round` 是「四捨五入」的意思。\n\n**範例：**\n- `round(85.0 * 1.1)` = `round(93.5)` = `94`\n- `round(75.0 * 1.1)` = `round(82.5)` = `83`\n\n## 實際範例\n\n```\nscores = [[85.0, 90.0], [75.0, 80.0]]\nfor i in range(len(scores)):\n    for j in range(len(scores[i])):\n        scores[i][j] = round(scores[i][j] * 1.1)\nprint(scores)\n```\n\n**執行過程：**\n1. 外層迴圈：`i = 0`（第一個學生）\n   - 內層迴圈：`j = 0`（第一科）\n     - `scores[0][0] = round(85.0 * 1.1) = round(93.5) = 94`\n   - 內層迴圈：`j = 1`（第二科）\n     - `scores[0][1] = round(90.0 * 1.1) = round(99.0) = 99`\n2. 外層迴圈：`i = 1`（第二個學生）\n   - 內層迴圈：`j = 0`（第一科）\n     - `scores[1][0] = round(75.0 * 1.1) = round(82.5) = 83`\n   - 內層迴圈：`j = 1`（第二科）\n     - `scores[1][1] = round(80.0 * 1.1) = round(88.0) = 88`\n\n**結果：** `[[94, 99], [83, 88]]`\n\n**記住：** \n- 二維陣列：外層是學生，內層是科目\n- 使用巢狀迴圈遍歷所有元素\n- `round()` 四捨五入到整數\n",
  "exercise": "有一個成績陣列 `scores = [[85.0, 90.0], [75.0, 80.0]]`。請將所有成績乘以 1.1（四捨五入到整數），然後印出調整後的陣列。",
  "hint": "使用巢狀迴圈，每個成績乘以 1.1 後用 `round()` 四捨五入。",
  "validator": {
    "type": "stdout_equals",
    "expected_output": "[[94, 99], [83, 88]]\n"
  },
  "_order": 55
}