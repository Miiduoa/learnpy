{
  "id": "PT11-1",
  "title": "Recursive function: DecimalToHexadecimal",
  "explanation": "\n## 為什麼要用遞迴改寫進制轉換？\n\n我們可以用遞迴的方式來實現十進位轉十六進位，這展示了遞迴的另一種應用場景。\n\n**實際應用：**\n- 理解遞迴在進制轉換中的應用\n- 比較遞迴和迴圈的實現方式\n- 掌握遞迴的設計模式\n\n**為什麼要改寫？**\n因為遞迴可以更優雅地處理「分解問題」的過程，讓程式碼更簡潔。\n\n## 遞迴思考方式\n\n**如何用遞迴思考進制轉換？**\n- 要轉換 n，先轉換 n // 16（高位部分）\n- 然後加上當前位（n % 16）對應的字元\n- 直到 n < 16（基本情況）\n\n**遞迴分解：**\n- `decimal_to_hex(255)` → `decimal_to_hex(15) + \"F\"` → `\"F\" + \"F\"` → `\"FF\"`\n- `decimal_to_hex(16)` → `decimal_to_hex(1) + \"0\"` → `\"1\" + \"0\"` → `\"10\"`\n\n## 遞迴函數設計\n\n### 基本情況（Base Case）\n\n**什麼是基本情況？**\n當數字小於 16 時，可以直接對應到十六進位字元，不需要再遞迴。\n\n**語法：**\n```\nif n == 0:\n    return \"0\"\nif n < 16:\n    return hex_digits[n]\n```\n\n**為什麼需要兩個基本情況？**\n- `n == 0`：特殊情況，直接回傳 \"0\"\n- `n < 16`：可以直接對應到單個字元\n\n### 遞迴情況（Recursive Case）\n\n**什麼是遞迴情況？**\n當 n >= 16 時，需要先處理高位（n // 16），然後加上當前位（n % 16）。\n\n**語法：**\n```\nreturn decimal_to_hex(n // 16) + hex_digits[n % 16]\n```\n\n**為什麼這樣寫？**\n- `n // 16`：取得高位部分（更接近基本情況）\n- `n % 16`：取得當前位（0-15）\n- `hex_digits[n % 16]`：將當前位轉換為十六進位字元\n- 將高位結果和當前位字元連接\n\n## 完整函數\n\n```\ndef decimal_to_hex(n):\n    hex_digits = \"0123456789ABCDEF\"\n    if n == 0:\n        return \"0\"\n    if n < 16:\n        return hex_digits[n]\n    return decimal_to_hex(n // 16) + hex_digits[n % 16]\n```\n\n## 執行過程\n\n### 範例 1：decimal_to_hex(16)\n\n**執行流程：**\n1. `decimal_to_hex(16)` → 16 >= 16，進入遞迴情況\n   - 計算：`decimal_to_hex(16 // 16) + hex_digits[16 % 16]`\n   - = `decimal_to_hex(1) + hex_digits[0]`\n2. `decimal_to_hex(1)` → 1 < 16，進入基本情況\n   - 回傳：`hex_digits[1] = \"1\"`\n3. 回傳：`\"1\" + \"0\" = \"10\"`\n\n**結果：** `\"10\"`\n\n### 範例 2：decimal_to_hex(255)\n\n**執行流程：**\n1. `decimal_to_hex(255)` → 255 >= 16\n   - `decimal_to_hex(15) + \"F\"`\n2. `decimal_to_hex(15)` → 15 < 16\n   - 回傳：`\"F\"`\n3. 回傳：`\"F\" + \"F\" = \"FF\"`\n\n**結果：** `\"FF\"`\n\n## 遞迴 vs 迴圈\n\n**遞迴版本：**\n```\ndef decimal_to_hex(n):\n    if n == 0:\n        return \"0\"\n    if n < 16:\n        return hex_digits[n]\n    return decimal_to_hex(n // 16) + hex_digits[n % 16]\n```\n\n**迴圈版本（PT10-2）：**\n```\ndef decimal_to_hex(n):\n    result = \"\"\n    if n == 0:\n        return \"0\"\n    while n > 0:\n        result = hex_digits[n % 16] + result\n        n = n // 16\n    return result\n```\n\n**比較：**\n- 遞迴：程式碼更簡潔，邏輯更直觀\n- 迴圈：效率更高，記憶體使用更少\n\n**記住：** \n- 遞迴的基本情況：n == 0 或 n < 16\n- 遞迴情況：先處理高位（n // 16），再處理當前位（n % 16）\n- 遞迴可以優雅地解決進制轉換問題\n- 遞迴和迴圈可以互相改寫\n",
  "exercise": "請用遞迴方式定義一個函數 `dec_to_hex(n)`，將十進位數轉換為十六進位字串。\n然後呼叫 `dec_to_hex(16)` 並印出結果。",
  "hint": "基本情況：n == 0 回傳 \"0\"，n < 16 回傳對應字元；遞迴情況：回傳 dec_to_hex(n // 16) + 當前位字元。",
  "validator": {
    "type": "stdout_equals",
    "expected_output": "10\n",
    "code_requirements": {
      "requires_function": true,
      "forbids_hardcode": true
    }
  },
  "_order": 99
}