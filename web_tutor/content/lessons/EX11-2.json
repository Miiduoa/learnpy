{
  "id": "EX11-2",
  "title": "Recursive function n!",
  "explanation": "\n## 什麼是遞迴？\n\n遞迴（Recursion）是函數**呼叫自己**的技術。\n\n**為什麼需要遞迴？**\n有些問題可以分解為「相同類型的子問題」，遞迴可以優雅地解決這類問題。\n\n**生活中的類比：**\n- 俄羅斯娃娃：大娃娃裡面有小娃娃，小娃娃裡面有更小的娃娃...\n- 階乘：5! = 5 × 4!，4! = 4 × 3!，...直到 1! = 1\n\n## 遞迴函數的兩個必要條件\n\n### 1. 基本情況（Base Case）\n\n**什麼是基本情況？**\n這是遞迴的**停止條件**，當達到這個條件時，不再呼叫自己，直接回傳結果。\n\n**為什麼需要基本情況？**\n如果沒有基本情況，函數會無限呼叫自己，造成無限遞迴（類似無限迴圈）！\n\n### 2. 遞迴情況（Recursive Case）\n\n**什麼是遞迴情況？**\n這是函數**呼叫自己**的部分，但參數要「更接近基本情況」。\n\n**為什麼參數要更接近基本情況？**\n這樣才能最終達到基本情況，停止遞迴。\n\n## 階乘的遞迴定義\n\n**什麼是階乘？**\nn! = n × (n-1) × (n-2) × ... × 2 × 1\n\n**遞迴思考：**\n- 5! = 5 × 4!\n- 4! = 4 × 3!\n- 3! = 3 × 2!\n- 2! = 2 × 1!\n- 1! = 1（基本情況）\n\n**函數定義：**\n```\ndef factorial(n):\n    if n == 0 or n == 1:  # 基本情況\n        return 1\n    else:  # 遞迴情況\n        return n * factorial(n - 1)\n```\n\n**為什麼基本情況是 n == 0 或 n == 1？**\n因為 0! = 1 和 1! = 1，這是數學定義，也是遞迴的終點。\n\n## 執行過程\n\n```\nprint(factorial(5))\n```\n\n**執行流程：**\n1. `factorial(5)` → 5 > 1，進入遞迴情況\n   - 計算：`5 * factorial(4)`\n2. `factorial(4)` → 4 > 1，進入遞迴情況\n   - 計算：`4 * factorial(3)`\n3. `factorial(3)` → 3 > 1，進入遞迴情況\n   - 計算：`3 * factorial(2)`\n4. `factorial(2)` → 2 > 1，進入遞迴情況\n   - 計算：`2 * factorial(1)`\n5. `factorial(1)` → 1 == 1，進入基本情況\n   - 回傳：`1`\n6. 開始回傳：\n   - `factorial(2)` = 2 × 1 = 2\n   - `factorial(3)` = 3 × 2 = 6\n   - `factorial(4)` = 4 × 6 = 24\n   - `factorial(5)` = 5 × 24 = 120\n\n**結果：** 120\n\n## 遞迴的優缺點\n\n**優點：**\n- 程式碼簡潔優雅\n- 符合問題的自然結構\n\n**缺點：**\n- 可能消耗較多記憶體（每次呼叫都會建立新的函數框架）\n- 可能較慢（函數呼叫有開銷）\n\n**記住：** \n- 遞迴必須有基本情況（停止條件）\n- 遞迴情況的參數要更接近基本情況\n- 沒有基本情況會造成無限遞迴！\n",
  "exercise": "請定義一個遞迴函數 `factorial(n)` 來計算 n 的階乘。\n然後呼叫 `factorial(5)` 並印出結果。",
  "hint": "基本情況：n <= 1 時回傳 1；遞迴情況：回傳 n * factorial(n-1)。",
  "validator": {
    "type": "stdout_equals",
    "expected_output": "120\n"
  },
  "_order": 98
}