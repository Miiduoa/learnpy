{
  "id": "PT11-2",
  "title": "Recursive function: Reverse string",
  "explanation": "\n## 為什麼要用遞迴反轉字串？\n\n反轉字串是遞迴的經典應用，展示了如何用遞迴處理字串問題。\n\n**實際應用：**\n- 理解遞迴在字串處理中的應用\n- 掌握遞迴分解問題的思維方式\n- 比較遞迴和迴圈的實現方式\n\n**為什麼要學遞迴版本？**\n因為遞迴可以更直觀地展示「分解問題」的過程，讓程式碼更優雅。\n\n## 遞迴思考方式\n\n**如何用遞迴思考字串反轉？**\n- 要反轉字串 `s`，可以先反轉 `s[1:]`（除了第一個字元的部分）\n- 然後將第一個字元 `s[0]` 放在最後\n- 直到字串為空或只有一個字元（基本情況）\n\n**遞迴分解：**\n- `reverse(\"abc\")` → `reverse(\"bc\") + \"a\"` → `\"cb\" + \"a\"` → `\"cba\"`\n- `reverse(\"bc\")` → `reverse(\"c\") + \"b\"` → `\"c\" + \"b\"` → `\"cb\"`\n- `reverse(\"c\")` → `\"c\"`（基本情況）\n\n**另一種思考方式：**\n- 要反轉字串 `s`，可以取最後一個字元 `s[-1]`\n- 然後加上反轉剩餘部分 `reverse(s[:-1])`\n- 直到字串為空或只有一個字元（基本情況）\n\n**遞迴分解（方式二）：**\n- `reverse(\"abc\")` → `\"c\" + reverse(\"ab\")` → `\"c\" + \"ba\"` → `\"cba\"`\n- `reverse(\"ab\")` → `\"b\" + reverse(\"a\")` → `\"b\" + \"a\"` → `\"ba\"`\n- `reverse(\"a\")` → `\"a\"`（基本情況）\n\n## 遞迴函數設計\n\n### 基本情況（Base Case）\n\n**什麼是基本情況？**\n當字串為空或只有一個字元時，不需要反轉，直接回傳。\n\n**語法：**\n```\nif len(s) <= 1:\n    return s\n```\n\n**為什麼 len(s) <= 1？**\n- 空字串 `\"\"`：長度為 0，反轉後還是空字串\n- 單一字元 `\"a\"`：長度為 1，反轉後還是 `\"a\"`\n\n### 遞迴情況（Recursive Case）\n\n**方式一：取第一個字元，反轉剩餘部分**\n```\nreturn reverse(s[1:]) + s[0]\n```\n\n**為什麼這樣寫？**\n- `s[1:]`：取得除了第一個字元外的所有字元（更接近基本情況）\n- `reverse(s[1:])`：遞迴反轉剩餘部分\n- `s[0]`：第一個字元\n- 將反轉後的剩餘部分和第一個字元連接\n\n**方式二：取最後一個字元，反轉剩餘部分**\n```\nreturn s[-1] + reverse(s[:-1])\n```\n\n**為什麼這樣寫？**\n- `s[-1]`：取得最後一個字元\n- `s[:-1]`：取得除了最後一個字元外的所有字元（更接近基本情況）\n- `reverse(s[:-1])`：遞迴反轉剩餘部分\n- 將最後一個字元和反轉後的剩餘部分連接\n\n## 完整函數（方式一）\n\n```\ndef reverse_string(s):\n    if len(s) <= 1:  # 基本情況\n        return s\n    else:  # 遞迴情況\n        return reverse_string(s[1:]) + s[0]\n```\n\n## 完整函數（方式二）\n\n```\ndef reverse_string(s):\n    if len(s) <= 1:  # 基本情況\n        return s\n    else:  # 遞迴情況\n        return s[-1] + reverse_string(s[:-1])\n```\n\n## 執行過程（方式二）\n\n```\nprint(reverse_string(\"abc\"))\n```\n\n**執行流程：**\n1. `reverse_string(\"abc\")` → len(\"abc\") = 3 > 1，進入遞迴情況\n   - 計算：`\"c\" + reverse_string(\"ab\")`\n2. `reverse_string(\"ab\")` → len(\"ab\") = 2 > 1，進入遞迴情況\n   - 計算：`\"b\" + reverse_string(\"a\")`\n3. `reverse_string(\"a\")` → len(\"a\") = 1，進入基本情況\n   - 回傳：`\"a\"`\n4. 開始回傳：\n   - `reverse_string(\"ab\")` = `\"b\" + \"a\"` = `\"ba\"`\n   - `reverse_string(\"abc\")` = `\"c\" + \"ba\"` = `\"cba\"`\n\n**結果：** `cba`\n\n## 遞迴 vs 迴圈\n\n**遞迴版本：**\n```\ndef reverse_string(s):\n    if len(s) <= 1:\n        return s\n    return s[-1] + reverse_string(s[:-1])\n```\n\n**迴圈版本：**\n```\ndef reverse_string(s):\n    result = \"\"\n    for i in range(len(s) - 1, -1, -1):\n        result += s[i]\n    return result\n```\n\n**或者使用切片：**\n```\ndef reverse_string(s):\n    return s[::-1]\n```\n\n**比較：**\n- 遞迴：程式碼更簡潔，邏輯更直觀\n- 迴圈：效率更高，記憶體使用更少\n\n## 字串索引和切片\n\n**字串索引：**\n- `s[0]`：第一個字元\n- `s[-1]`：最後一個字元\n- `s[1]`：第二個字元\n\n**字串切片：**\n- `s[1:]`：從第二個字元到最後（不包含第一個字元）\n- `s[:-1]`：從第一個字元到倒數第二個（不包含最後一個字元）\n- `s[::-1]`：整個字串反轉（Python 的簡便寫法）\n\n**記住：** \n- 遞迴的基本情況：len(s) <= 1\n- 遞迴情況：取最後一個字元 + 反轉剩餘部分，或反轉剩餘部分 + 第一個字元\n- 遞迴可以優雅地解決字串反轉問題\n- 遞迴和迴圈可以互相改寫\n- 字串切片 `s[::-1]` 是最簡潔的反轉方式，但遞迴版本更有教育意義\n",
  "exercise": "請用遞迴方式定義一個函數 `reverse_string(s)`，將字串反轉。\n然後呼叫 `reverse_string('hello')` 並印出結果。",
  "hint": "基本情況：len(s) <= 1 時回傳 s；遞迴情況：回傳 s[-1] + reverse_string(s[:-1]) 或 reverse_string(s[1:]) + s[0]。",
  "validator": {
    "type": "stdout_equals",
    "expected_output": "olleh\n",
    "code_requirements": {
      "requires_function": true,
      "function_name": "reverse_string",
      "forbids_hardcode": true
    }
  },
  "_order": 100
}